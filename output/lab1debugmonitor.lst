680x0 MACRO ASSEMBLER   Version 5.00   (c) 1992-2005 Peter J. Fondse

Date: 05 Apr 2025      Time: 14:35:19          Source: C:\COSMICIMPALASM68K\OUTPUT\LAB1DEBUGMONITOR.SRC

                       1          section   code
                       2   ; for initial stack use $08040000 if your system uses SRAM for main memory (top of 256kbyte SRAM space)
                       3   ; When your system is converted to use DRAM for main memory set this constant to $0C000000 (top of 64MByte DRAM space
                       4   
                       5   ; StackPointerVal     equ $08040000      when using sram
          0C00 0000    6   StackPointerVal     equ $0C000000      when using dram
                       7   
                       8   ; define RamVectorTable as $0803000 if your system uses SRAM for main memory
                       9   ; When your system is converted to use DRAM for main memory define RamVectorTable constant as $0B000000 (top of 64MByte DRAM space)
                      10   
                      11   ;RamVectorTable      equ $08030000      when using sram
          0B00 0000   12   RamVectorTable      equ $0B000000      when using dram
                      13   
                      14   
                      15   
                      16   ; CSTART.ASM  -  C startup-code for Debug Monitor
00000000              17                   align
                      18   
00000000              19                   org $00000000          ;start of rom based vector table, 68k hard wired to expect this at $0
                      20   
00000000  0C00 0000   21   InitialSP       dc.l StackPointerVal   ;initial supervisor state stack pointer(stack decrements first before being used)
00000004  0000 0400   22   InitialPC       dc.l start             ;address of 1st instruction of program after a reset
00000008  0000 0802   23   BusError        dc.l E_BErro           ;bus error - stop program
0000000C  0000 0814   24   AddressError    dc.l E_AErro           ;address error - stop program
00000010  0000 0826   25   IllegalInstr    dc.l E_IInst           ;illegal instruction - stop program
00000014  0000 0838   26   DividebyZero    dc.l E_DZero           ;divide by zero error - stop program
00000018  0000 084A   27   Check           dc.l E_Check           ;Check instruction - stop program
0000001C  0000 085C   28   TrapV           dc.l E_Trapv           ;Trapv instruction - stop program
00000020  0000 086E   29   Privilege       dc.l E_Priv            ;privilige violation - stop program
00000024  0000 0880   30   Trace           dc.l E_Trace           ;stop on trace
00000028  0000 0892   31   Line1010emul    dc.l E_1010            ;1010 instructions stop
0000002C  0000 08A4   32   Line1111emul    dc.l E_1111            ;1111 instructions stop
00000030  0000 08B6   33   Unassigned1     dc.l E_Unnas1           ;unassigned vector
00000034  0000 08B6   34   Unassigned2     dc.l E_Unnas2           ;unassigned vector
00000038  0000 08B6   35   Unassigned3     dc.l E_Unnas3           ;unassigned vector
0000003C  0000 08B6   36   Uninit_IRQ      dc.l E_UnitI           ;uninitialised interrupt
00000040  0000 08B6   37   Unassigned4     dc.l E_Unnas4           ;unassigned vector
00000044  0000 08B6   38   Unassigned5     dc.l E_Unnas5           ;unassigned vector
00000048  0000 08B6   39   Unassigned6     dc.l E_Unnas6           ;unassigned vector
0000004C  0000 08B6   40   Unassigned7     dc.l E_Unnas7           ;unassigned vector
00000050  0000 08B6   41   Unassigned8     dc.l E_Unnas8           ;unassigned vector
00000054  0000 08B6   42   Unassigned9     dc.l E_Unnas9           ;unassigned vector
00000058  0000 08B6   43   Unassigned10    dc.l E_Unnas10           ;unassigned vector
0000005C  0000 08B6   44   Unassigned11    dc.l E_Unnas11           ;unassigned vector
00000060  0000 08B6   45   SpuriousIRQ     dc.l E_Spuri           ;stop on spurious irq
                      46   *
                      47   *
00000064  0000 049A   48   Level1IRQ       dc.l Level1RamISR
00000068  0000 04AC   49   Level2IRQ       dc.l Level2RamISR
0000006C  0000 04BE   50   Level3IRQ       dc.l Level3RamISR
00000070  0000 04D0   51   Level4IRQ       dc.l Level4RamISR
00000074  0000 04E2   52   Level5IRQ       dc.l Level5RamISR
00000078  0000 05EC   53   Level6IRQ       dc.l Level6RamISR
0000007C  0000 05FE   54   Level7IRQ       dc.l Level7RamISR
                      55   *
                      56   *
00000080  0000 0610   57   Trap0           dc.l Trap0RamISR        ; User installed trap handler
00000084  0000 0622   58   Trap1           dc.l Trap1RamISR        ; User installed trap handler
00000088  0000 0634   59   Trap2           dc.l Trap2RamISR        ; User installed trap handler
0000008C  0000 0646   60   Trap3           dc.l Trap3RamISR        ; User installed trap handler
00000090  0000 0658   61   Trap4           dc.l Trap4RamISR        ; User installed trap handler
00000094  0000 066A   62   Trap5           dc.l Trap5RamISR        ; User installed trap handler
00000098  0000 067C   63   Trap6           dc.l Trap6RamISR        ; User installed trap handler
0000009C  0000 068E   64   Trap7           dc.l Trap7RamISR        ; User installed trap handler
000000A0  0000 06A0   65   Trap8           dc.l Trap8RamISR        ; User installed trap handler
000000A4  0000 06B2   66   Trap9           dc.l Trap9RamISR        ; User installed trap handler
000000A8  0000 06C4   67   Trap10          dc.l Trap10RamISR       ; User installed trap handler
000000AC  0000 06D6   68   Trap11          dc.l Trap11RamISR       ; User installed trap handler
000000B0  0000 06E8   69   Trap12          dc.l Trap12RamISR       ; User installed trap handler
000000B4  0000 06FA   70   Trap13          dc.l Trap13RamISR       ; User installed trap handler
000000B8  0000 070C   71   Trap14          dc.l Trap14RamISR       ; User installed trap handler
000000BC  0000 07FC   72   Trap15          dc.l Trap15RamISR       ; User installed trap handler
                      73   
                      74   *
                      75   * Other vectors 64-255 are users vectors for autovectored IO device (not implemented in TG68)
                      76   *
                      77   
00000400              78                   org       $00000400
                      79   
00000400  46FC 2700   80   start:          move.w     #$2700,SR             set interrupts to disable until later
                      81   
                      82   *************************************************************************************
                      83   ** add some 68000 instruction to read and write to memory, IO etc. This doesn't do anything
                      84   ** important, it just creates read and write bus cycles to specific addresses which
                      85   ** help with debugging hardware in Quartus simulations
                      86   **************************************************************************************
                      87   
                      88                   ; perform some dummy read/write of 32 bit values to memory to see waveforms during a simulation
                      89   
00000404  23FC 1122   90                   move.l     #$11223344,$08060000 write 32 bits, to memory
00000408  3344 0806 
0000040C  0000      
0000040E  2039 0806   91                   move.l     $08060000,d0         read 32 bits back
00000412  0000      
00000414  13FC 0000   92                   move.b     #$00,$00400000         write to the output ports
00000418  0040 0000 
0000041C  13FC 0000   93                   move.b     #$00,$00400002         write to the output ports
00000420  0040 0002 
00000424  13FC 0000   94                   move.b     #$00,$00400004         write to the output ports
00000428  0040 0004 
0000042C  13FC 0000   95                   move.b     #$00,$00400006         write to the output ports
00000430  0040 0006 
00000434  13FC 0000   96                   move.b     #$00,$00400008         write to the output ports
00000438  0040 0008 
0000043C  13FC 0000   97                   move.b     #$00,$00400010         write to the hex display ports
00000440  0040 0010 
00000444  13FC 0000   98                   move.b     #$00,$00400012         write to the hex display ports
00000448  0040 0012 
0000044C  13FC 0000   99                   move.b     #$00,$00400014         write to the hex display ports
00000450  0040 0014 
00000454  13FC 0000  100                   move.b     #0,$00400020         write to the LCD
00000458  0040 0020 
0000045C  13FC 0000  101                   move.b     #0,$00400022         write to the LCD
00000460  0040 0022 
00000464  13FC 0000  102                   move.b     #0,$00400030         write to the Timer1 Data
00000468  0040 0030 
0000046C  13FC 0000  103                   move.b     #0,$00400032         write to the Timer1 Control
00000470  0040 0032 
                     104   
                     105                   ; some important initialisation do not modify
00000474  23FC FFFF  106                   move.l    #-1,__ungetbuf  ; unget-buffer for keyboard input
00000478  FFFF 0B00 
0000047C  00C0      
0000047E  23FC 0000  107                   move.l    #0,__allocp     ; pointer to allocated memory for malloc-function
00000482  0000 0B00 
00000486  00C4      
00000488  23FC 0B00  108                   move.l    #heap,__heap    ; pointer to free memory
0000048C  0596 0B00 
00000490  00C4      
                     109   
                     110   
00000492  4EB9 0000  111   mainloop        jsr       _main
00000496  375C      
00000498  60F8       112                   bra       mainloop
                     113   
                     114   *********************************************************************************************************
                     115   * Code to call Ram Based Interrupt handler and other exeception handler code
                     116   *********************************************************************************************************
0000049A  48E7 FFFE  117   Level1RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000049E  2079 0B00  118                   move.l    VL1IRQ,a0               get ram based address into a0
000004A2  0064      
000004A4  4E90       119                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
000004A6  4CDF 7FFF  120                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004AA  4E73       121                   rte
000004AC  48E7 FFFE  122   Level2RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004B0  2079 0B00  123                   move.l    VL2IRQ,a0               get ram based address into a0
000004B4  0068      
000004B6  4E90       124                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
000004B8  4CDF 7FFF  125                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004BC  4E73       126                   rte
000004BE  48E7 FFFE  127   Level3RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004C2  2079 0B00  128                   move.l    VL3IRQ,a0               get ram based address into a0
000004C6  006C      
000004C8  4E90       129                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
000004CA  4CDF 7FFF  130                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004CE  4E73       131                   rte
000004D0  48E7 FFFE  132   Level4RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004D4  2079 0B00  133                   move.l    VL4IRQ,a0               get ram based address into a0
000004D8  0070      
000004DA  4E90       134                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
000004DC  4CDF 7FFF  135                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004E0  4E73       136                   rte
                     137   
                     138   * Trace trap Handler
                     139   
                     140   Level5RamISR
                     141   *
                     142   **         Copy 68000 registers from debug monitor Variables,
                     143   *
                     144   *
000004E2  23FC 0000  145                   move.l    #1,_Trace              switch on Trace Mode
000004E6  0001 0B00 
000004EA  00D8      
000004EC  13FC 0000  146                   move.b    #$0,$0040000A          turn off a trace exception so we don't when generate a trace when disassembling instruction in the register dump (disassembling causes access to use program)
000004F0  0040 000A 
000004F4  33DF 0B00  147                   move.w    (sp)+,_SR              get at the users status register pointed to by stack pointer and copy
000004F8  012C      
000004FA  23DF 0B00  148                   move.l    (sp)+,_PC              get at the users program counter and copy
000004FE  0120      
                     149   *
00000500  23CF 0B00  150                   move.l    SP,_SSP                copy system stack pointer to debug monitor variable
00000504  0124      
00000506  23C0 0B00  151                   move.l    d0,_d0
0000050A  00E4      
0000050C  23C1 0B00  152                   move.l    d1,_d1
00000510  00E8      
00000512  23C2 0B00  153                   move.l    d2,_d2
00000516  00EC      
00000518  23C3 0B00  154                   move.l    d3,_d3
0000051C  00F0      
0000051E  23C4 0B00  155                   move.l    d4,_d4
00000522  00F4      
00000524  23C5 0B00  156                   move.l    d5,_d5
00000528  00F8      
0000052A  23C6 0B00  157                   move.l    d6,_d6
0000052E  00FC      
00000530  23C7 0B00  158                   move.l    d7,_d7
00000534  0100      
                     159   *
00000536  23C8 0B00  160                   move.l    a0,_a0
0000053A  0104      
0000053C  23C9 0B00  161                   move.l    a1,_a1
00000540  0108      
00000542  23CA 0B00  162                   move.l    a2,_a2
00000546  010C      
00000548  23CB 0B00  163                   move.l    a3,_a3
0000054C  0110      
0000054E  23CC 0B00  164                   move.l    a4,_a4
00000552  0114      
00000554  23CD 0B00  165                   move.l    a5,_a5
00000558  0118      
0000055A  23CE 0B00  166                   move.l    a6,_a6
0000055E  011C      
00000560  4E68       167                   move.l    usp,a0
00000562  23C8 0B00  168                   move.l    a0,_USP
00000566  0128      
                     169   *
00000568  2079 0B00  170                   move.l    VL5IRQ,a0              get ram based address into a0, trace exception for next instruction will be generated in Menu SPACE command
0000056C  0074      
0000056E  4E90       171                   jsr       0(a0)                  jump to the subroutine that is the trap handler, using ram based address
                     172   
                     173   ** After trace, reload 68000 registers with new values before continuing
                     174   
00000570  2039 0B00  175                   move.l   _d0,d0
00000574  00E4      
00000576  2239 0B00  176                   move.l   _d1,d1
0000057A  00E8      
0000057C  2439 0B00  177                   move.l   _d2,d2
00000580  00EC      
00000582  2639 0B00  178                   move.l   _d3,d3
00000586  00F0      
00000588  2839 0B00  179                   move.l   _d4,d4
0000058C  00F4      
0000058E  2A39 0B00  180                   move.l   _d5,d5
00000592  00F8      
00000594  2C39 0B00  181                   move.l   _d6,d6
00000598  00FC      
0000059A  2E39 0B00  182                   move.l   _d7,d7
0000059E  0100      
                     183   
000005A0  2079 0B00  184                   move.l   _USP,a0
000005A4  0128      
000005A6  4E60       185                   move.l   a0,USP                     load user stack pointer
000005A8  2079 0B00  186                   move.l   _a0,a0
000005AC  0104      
000005AE  2279 0B00  187                   move.l   _a1,a1
000005B2  0108      
000005B4  2479 0B00  188                   move.l   _a2,a2
000005B8  010C      
000005BA  2679 0B00  189                   move.l   _a3,a3
000005BE  0110      
000005C0  2879 0B00  190                   move.l   _a4,a4
000005C4  0114      
000005C6  2A79 0B00  191                   move.l   _a5,a5
000005CA  0118      
000005CC  2C79 0B00  192                   move.l   _a6,a6
000005D0  011C      
                     193   
000005D2  2E79 0B00  194                   move.l   _SSP,sp
000005D6  0124      
000005D8  2F39 0B00  195                   move.l   _PC,-(sp)
000005DC  0120      
000005DE  3F39 0B00  196                   move.w   _SR,-(sp)
000005E2  012C      
000005E4  11F8 0074  197                   move.b    $00000074,$0	          read trace exception vector after accessing disassembly to reset the trace request causes by disassembling program above
000005E8  0000      
000005EA  4E73       198                   rte
                     199   
                     200   * address trap handler
                     201   
000005EC  48E7 FFFE  202   Level6RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000005F0  2079 0B00  203                   move.l    VL6IRQ,a0               get ram based address into a0
000005F4  0078      
000005F6  4E90       204                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
000005F8  4CDF 7FFF  205                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000005FC  4E73       206                   rte
                     207   
000005FE  48E7 FFFE  208   Level7RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000602  2079 0B00  209                   move.l    VL7IRQ,a0               get ram based address into a0
00000606  007C      
00000608  4E90       210                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
0000060A  4CDF 7FFF  211                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000060E  4E73       212                   rte
                     213   
                     214   
                     215   ********************************************************************************************************
                     216   * Ram based Trap handler and other exeception handler code
                     217   *********************************************************************************************************
                     218   
00000610  48E7 FFFE  219   Trap0RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000614  2079 0B00  220                   move.l    VTrap0,a0                get ram based address into a0
00000618  0080      
0000061A  4E90       221                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000061C  4CDF 7FFF  222                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000620  4E73       223                   rte
                     224   
00000622  48E7 FFFE  225   Trap1RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000626  2079 0B00  226                   move.l    VTrap1,a0                get ram based address into a0
0000062A  0084      
0000062C  4E90       227                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000062E  4CDF 7FFF  228                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000632  4E73       229                   rte
                     230   
00000634  48E7 FFFE  231   Trap2RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000638  2079 0B00  232                   move.l    VTrap2,a0                get ram based address into a0
0000063C  0088      
0000063E  4E90       233                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000640  4CDF 7FFF  234                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000644  4E73       235                   rte
                     236   
00000646  48E7 FFFE  237   Trap3RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000064A  2079 0B00  238                   move.l    VTrap3,a0                get ram based address into a0
0000064E  008C      
00000650  4E90       239                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000652  4CDF 7FFF  240                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000656  4E73       241                   rte
                     242   
00000658  48E7 FFFE  243   Trap4RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000065C  2079 0B00  244                   move.l    VTrap4,a0                get ram based address into a0
00000660  0090      
00000662  4E90       245                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000664  4CDF 7FFF  246                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000668  4E73       247                   rte
                     248   
0000066A  48E7 FFFE  249   Trap5RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000066E  2079 0B00  250                   move.l    VTrap5,a0                get ram based address into a0
00000672  0094      
00000674  4E90       251                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000676  4CDF 7FFF  252                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000067A  4E73       253                   rte
                     254   
0000067C  48E7 FFFE  255   Trap6RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000680  2079 0B00  256                   move.l    VTrap6,a0                get ram based address into a0
00000684  0098      
00000686  4E90       257                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000688  4CDF 7FFF  258                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000068C  4E73       259                   rte
                     260   
0000068E  48E7 FFFE  261   Trap7RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000692  2079 0B00  262                   move.l    VTrap7,a0                get ram based address into a0
00000696  009C      
00000698  4E90       263                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000069A  4CDF 7FFF  264                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000069E  4E73       265                   rte
                     266   
000006A0  48E7 FFFE  267   Trap8RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006A4  2079 0B00  268                   move.l    VTrap8,a0                get ram based address into a0
000006A8  00A0      
000006AA  4E90       269                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000006AC  4CDF 7FFF  270                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000006B0  4E73       271                   rte
                     272   
000006B2  48E7 FFFE  273   Trap9RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006B6  2079 0B00  274                   move.l    VTrap9,a0                get ram based address into a0
000006BA  00A4      
000006BC  4E90       275                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000006BE  4CDF 7FFF  276                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000006C2  4E73       277                   rte
                     278   
000006C4  48E7 FFFE  279   Trap10RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006C8  2079 0B00  280                   move.l    VTrap10,a0                get ram based address into a0
000006CC  00A8      
000006CE  4E90       281                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000006D0  4CDF 7FFF  282                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000006D4  4E73       283                   rte
                     284   
000006D6  48E7 FFFE  285   Trap11RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006DA  2079 0B00  286                   move.l    VTrap11,a0                get ram based address into a0
000006DE  00AC      
000006E0  4E90       287                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000006E2  4CDF 7FFF  288                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000006E6  4E73       289                   rte
                     290   
000006E8  48E7 FFFE  291   Trap12RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006EC  2079 0B00  292                   move.l    VTrap12,a0                get ram based address into a0
000006F0  00B0      
000006F2  4E90       293                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000006F4  4CDF 7FFF  294                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000006F8  4E73       295                   rte
                     296   
000006FA  48E7 FFFE  297   Trap13RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006FE  2079 0B00  298                   move.l    VTrap13,a0                get ram based address into a0
00000702  00B4      
00000704  4E90       299                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000706  4CDF 7FFF  300                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000070A  4E73       301                   rte
                     302   
                     303   Trap14RamISR    ;Break Point Handler
                     304   *
                     305   **         Copy 68000 registers from debug monitor Variables
                     306   *
0000070C  23FC 0000  307                   move.l    #1,_Trace      switch on Trace Mode
00000710  0001 0B00 
00000714  00D8      
00000716  33DF 0B00  308                   move.w    (sp)+,_SR       get at the users status register pointed to by stack pointer and copy
0000071A  012C      
0000071C  23DF 0B00  309                   move.l    (sp)+,_PC      get at the users program counter and copy
00000720  0120      
                     310   *
00000722  23C0 0B00  311                   move.l    d0,_d0
00000726  00E4      
00000728  23C1 0B00  312                   move.l    d1,_d1
0000072C  00E8      
0000072E  23C2 0B00  313                   move.l    d2,_d2
00000732  00EC      
00000734  23C3 0B00  314                   move.l    d3,_d3
00000738  00F0      
0000073A  23C4 0B00  315                   move.l    d4,_d4
0000073E  00F4      
00000740  23C5 0B00  316                   move.l    d5,_d5
00000744  00F8      
00000746  23C6 0B00  317                   move.l    d6,_d6
0000074A  00FC      
0000074C  23C7 0B00  318                   move.l    d7,_d7
00000750  0100      
                     319   *
00000752  23C8 0B00  320                   move.l    a0,_a0
00000756  0104      
00000758  23C9 0B00  321                   move.l    a1,_a1
0000075C  0108      
0000075E  23CA 0B00  322                   move.l    a2,_a2
00000762  010C      
00000764  23CB 0B00  323                   move.l    a3,_a3
00000768  0110      
0000076A  23CC 0B00  324                   move.l    a4,_a4
0000076E  0114      
00000770  23CD 0B00  325                   move.l    a5,_a5
00000774  0118      
00000776  23CE 0B00  326                   move.l    a6,_a6
0000077A  011C      
0000077C  4E68       327                   move.l    USP,a0
0000077E  23C8 0B00  328                   move.l    a0,_USP
00000782  0128      
                     329   *
00000784  2079 0B00  330                   move.l    VTrap14,a0             get ram based address into a0
00000788  00B8      
0000078A  4E90       331                   jsr       0(a0)                  jump to the subroutine that is the trap handler, using ram based address
                     332   
                     333   ** After breakpoint reload 68000 registers with new values before continuing
                     334   
                     335   *                move.b    #$ff,$0040000A     generate a trace exception for the next instruction
0000078C  2039 0B00  336                   move.l   _d0,d0
00000790  00E4      
00000792  2239 0B00  337                   move.l   _d1,d1
00000796  00E8      
00000798  2439 0B00  338                   move.l   _d2,d2
0000079C  00EC      
0000079E  2639 0B00  339                   move.l   _d3,d3
000007A2  00F0      
000007A4  2839 0B00  340                   move.l   _d4,d4
000007A8  00F4      
000007AA  2A39 0B00  341                   move.l   _d5,d5
000007AE  00F8      
000007B0  2C39 0B00  342                   move.l   _d6,d6
000007B4  00FC      
000007B6  2E39 0B00  343                   move.l   _d7,d7
000007BA  0100      
                     344   
000007BC  2079 0B00  345                   move.l   _USP,a0
000007C0  0128      
000007C2  4E60       346                   move.l   a0,USP        load user stack pointer A7
000007C4  2079 0B00  347                   move.l   _a0,a0
000007C8  0104      
000007CA  2279 0B00  348                   move.l   _a1,a1
000007CE  0108      
000007D0  2479 0B00  349                   move.l   _a2,a2
000007D4  010C      
000007D6  2679 0B00  350                   move.l   _a3,a3
000007DA  0110      
000007DC  2879 0B00  351                   move.l   _a4,a4
000007E0  0114      
000007E2  2A79 0B00  352                   move.l   _a5,a5
000007E6  0118      
000007E8  2C79 0B00  353                   move.l   _a6,a6
000007EC  011C      
                     354   
000007EE  2F39 0B00  355                   move.l   _PC,-(sp)
000007F2  0120      
000007F4  3F39 0B00  356                   move.w   _SR,-(sp)
000007F8  012C      
000007FA  4E73       357                   rte
                     358   
000007FC  4EF9 0000  359   Trap15RamISR    jmp     _CallDebugMonitor
00000800  2DF0      
                     360   *                movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                     361   *                move.l    VTrap15,a0                get ram based address into a0
                     362   *                jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
                     363   *                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                     364   *                rte
                     365   
                     366   *********************************************************************************************************
                     367   *Default exception handler for everything without a specific handler
                     368   *********************************************************************************************************
                     369   
                     370   *
                     371   **              Jump here for each unhandled exception
                     372   **              If you need to, MAKE SURE YOU SAVE ALL IMPORTANT REGISTERS AND RESTORE THEM BEFORE RETURNING (IF APPROPRIATE)
                     373   *
                     374   
00000802  48E7 FFFE  375   E_BErro         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000806  2079 0B00  376                   move.l    VBusError,a0            get ram based address into a0
0000080A  0008      
0000080C  4E90       377                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000080E  4CDF 7FFF  378                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000812  4E73       379                   rte
00000814  48E7 FFFE  380   E_AErro         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000818  2079 0B00  381                   move.l    VAddressError,a0        get ram based address into a0
0000081C  000C      
0000081E  4E90       382                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000820  4CDF 7FFF  383                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000824  4E73       384                   rte
00000826  48E7 FFFE  385   E_IInst         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000082A  2079 0B00  386                   move.l    VIllegalInstr,a0        get ram based address into a0
0000082E  0010      
00000830  4E90       387                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000832  4CDF 7FFF  388                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000836  4E73       389                   rte
00000838  48E7 FFFE  390   E_DZero         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000083C  2079 0B00  391                   move.l    VDividebyZero,a0        get ram based address into a0
00000840  0014      
00000842  4E90       392                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000844  4CDF 7FFF  393                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000848  4E73       394                   rte
0000084A  48E7 FFFE  395   E_Check         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000084E  2079 0B00  396                   move.l    VCheck,a0               get ram based address into a0
00000852  0018      
00000854  4E90       397                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000856  4CDF 7FFF  398                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000085A  4E73       399                   rte
0000085C  48E7 FFFE  400   E_Trapv         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000860  2079 0B00  401                   move.l    VTrapV,a0               get ram based address into a0
00000864  001C      
00000866  4E90       402                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000868  4CDF 7FFF  403                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000086C  4E73       404                   rte
0000086E  48E7 FFFE  405   E_Priv          movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000872  2079 0B00  406                   move.l    VPrivilege,a0           get ram based address into a0
00000876  0020      
00000878  4E90       407                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000087A  4CDF 7FFF  408                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000087E  4E73       409                   rte
00000880  48E7 FFFE  410   E_Trace         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000884  2079 0B00  411                   move.l    VTrace,a0               get ram based address into a0
00000888  0024      
0000088A  4E90       412                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000088C  4CDF 7FFF  413                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000890  4E73       414                   rte
00000892  48E7 FFFE  415   E_1010          movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000896  2079 0B00  416                   move.l    VLine1010emul,a0        get ram based address into a0
0000089A  0028      
0000089C  4E90       417                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000089E  4CDF 7FFF  418                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000008A2  4E73       419                   rte
000008A4  48E7 FFFE  420   E_1111          movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000008A8  2079 0B00  421                   move.l    VLine1111emul,a0        get ram based address into a0
000008AC  002C      
000008AE  4E90       422                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000008B0  4CDF 7FFF  423                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000008B4  4E73       424                   rte
                     425   E_Unnas1
                     426   E_Unnas2
                     427   E_Unnas3
                     428   E_UnitI
                     429   E_Unnas4
                     430   E_Unnas5
                     431   E_Unnas6
                     432   E_Unnas7
                     433   E_Unnas8
                     434   E_Unnas9
                     435   E_Unnas10
                     436   E_Unnas11
                     437   E_Spuri
000008B6  60FE       438   _stop            bra _stop                         stop
                     439   ***************************************************************************************************
                     440   * Go() function in debug monitor
                     441   ***************************************************************************************************
                     442   _go
000008B8  2E79 0B00  443                   move.l   _SSP,a7        load system stack pointer (remember we are in supervisor mode when running this so a7 is the System stack pointer)
000008BC  0124      
000008BE  2F39 0B00  444                   move.l   _PC,-(sp)      copy debug monitor PC variable to the stack
000008C2  0120      
000008C4  3F39 0B00  445                   move.w   _SR,-(sp)      copy debug monitor status reg to the stack
000008C8  012C      
                     446   
000008CA  1038 0078  447                   move.b   $00000078,d0  remove any spurious address exception arising after power on
000008CE  2039 0B00  448                   move.l   _d0,d0
000008D2  00E4      
000008D4  2239 0B00  449                   move.l   _d1,d1
000008D8  00E8      
000008DA  2439 0B00  450                   move.l   _d2,d2
000008DE  00EC      
000008E0  2639 0B00  451                   move.l   _d3,d3
000008E4  00F0      
000008E6  2839 0B00  452                   move.l   _d4,d4
000008EA  00F4      
000008EC  2A39 0B00  453                   move.l   _d5,d5
000008F0  00F8      
000008F2  2C39 0B00  454                   move.l   _d6,d6
000008F6  00FC      
000008F8  2E39 0B00  455                   move.l   _d7,d7
000008FC  0100      
                     456   
000008FE  2079 0B00  457                   move.l   _USP,a0
00000902  0128      
00000904  4E60       458                   move.l   a0,USP        load user stack pointer (remember we are in supervisor mode when running this, so a7 is the System stack pointer)
00000906  2079 0B00  459                   move.l   _a0,a0
0000090A  0104      
0000090C  2279 0B00  460                   move.l   _a1,a1
00000910  0108      
00000912  2479 0B00  461                   move.l   _a2,a2
00000916  010C      
00000918  2679 0B00  462                   move.l   _a3,a3
0000091C  0110      
0000091E  2879 0B00  463                   move.l   _a4,a4
00000922  0114      
00000924  2A79 0B00  464                   move.l   _a5,a5
00000928  0118      
0000092A  2C79 0B00  465                   move.l   _a6,a6
0000092E  011C      
00000930  4E73       466                   rte                    load the status reg and PC from the stack and commence running
                     467                                          *used to be rte but this didn't load the status byte
                     468   
                     469   ; C:\M68KV6.0 - 800BY480\PROGRAMS\DEBUGMONITORCODE\CANBUS CONTROLLER ROUTINES - FOR STUDENTS.C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
                     470   ; /*********************************************************************************************
                     471   ; ** These addresses and definitions were taken from Appendix 7 of the Can Controller
                     472   ; ** application note and adapted for the 68k assignment
                     473   ; *********************************************************************************************/
                     474   ; /*
                     475   ; ** definition for the SJA1000 registers and bits based on 68k address map areas
                     476   ; ** assume the addresses for the 2 can controllers given in the assignment
                     477   ; **
                     478   ; ** Registers are defined in terms of the following Macro for each Can controller,
                     479   ; ** where (i) represents an registers number
                     480   ; */
                     481   ; #define CAN0_CONTROLLER(i) (*(volatile unsigned char *)(0x00500000 + (i << 1)))
                     482   ; #define CAN1_CONTROLLER(i) (*(volatile unsigned char *)(0x00500200 + (i << 1)))
                     483   ; /* Can 0 register definitions */
                     484   ; #define Can0_ModeControlReg      CAN0_CONTROLLER(0)
                     485   ; #define Can0_CommandReg          CAN0_CONTROLLER(1)
                     486   ; #define Can0_StatusReg           CAN0_CONTROLLER(2)
                     487   ; #define Can0_InterruptReg        CAN0_CONTROLLER(3)
                     488   ; #define Can0_InterruptEnReg      CAN0_CONTROLLER(4) /* PeliCAN mode */
                     489   ; #define Can0_BusTiming0Reg       CAN0_CONTROLLER(6)
                     490   ; #define Can0_BusTiming1Reg       CAN0_CONTROLLER(7)
                     491   ; #define Can0_OutControlReg       CAN0_CONTROLLER(8)
                     492   ; /* address definitions of Other Registers */
                     493   ; #define Can0_ArbLostCapReg       CAN0_CONTROLLER(11)
                     494   ; #define Can0_ErrCodeCapReg       CAN0_CONTROLLER(12)
                     495   ; #define Can0_ErrWarnLimitReg     CAN0_CONTROLLER(13)
                     496   ; #define Can0_RxErrCountReg       CAN0_CONTROLLER(14)
                     497   ; #define Can0_TxErrCountReg       CAN0_CONTROLLER(15)
                     498   ; #define Can0_RxMsgCountReg       CAN0_CONTROLLER(29)
                     499   ; #define Can0_RxBufStartAdr       CAN0_CONTROLLER(30)
                     500   ; #define Can0_ClockDivideReg      CAN0_CONTROLLER(31)
                     501   ; /* address definitions of Acceptance Code & Mask Registers - RESET MODE */
                     502   ; #define Can0_AcceptCode0Reg      CAN0_CONTROLLER(16)
                     503   ; #define Can0_AcceptCode1Reg      CAN0_CONTROLLER(17)
                     504   ; #define Can0_AcceptCode2Reg      CAN0_CONTROLLER(18)
                     505   ; #define Can0_AcceptCode3Reg      CAN0_CONTROLLER(19)
                     506   ; #define Can0_AcceptMask0Reg      CAN0_CONTROLLER(20)
                     507   ; #define Can0_AcceptMask1Reg      CAN0_CONTROLLER(21)
                     508   ; #define Can0_AcceptMask2Reg      CAN0_CONTROLLER(22)
                     509   ; #define Can0_AcceptMask3Reg      CAN0_CONTROLLER(23)
                     510   ; /* address definitions Rx Buffer - OPERATING MODE - Read only register*/
                     511   ; #define Can0_RxFrameInfo         CAN0_CONTROLLER(16)
                     512   ; #define Can0_RxBuffer1           CAN0_CONTROLLER(17)
                     513   ; #define Can0_RxBuffer2           CAN0_CONTROLLER(18)
                     514   ; #define Can0_RxBuffer3           CAN0_CONTROLLER(19)
                     515   ; #define Can0_RxBuffer4           CAN0_CONTROLLER(20)
                     516   ; #define Can0_RxBuffer5           CAN0_CONTROLLER(21)
                     517   ; #define Can0_RxBuffer6           CAN0_CONTROLLER(22)
                     518   ; #define Can0_RxBuffer7           CAN0_CONTROLLER(23)
                     519   ; #define Can0_RxBuffer8           CAN0_CONTROLLER(24)
                     520   ; #define Can0_RxBuffer9           CAN0_CONTROLLER(25)
                     521   ; #define Can0_RxBuffer10          CAN0_CONTROLLER(26)
                     522   ; #define Can0_RxBuffer11          CAN0_CONTROLLER(27)
                     523   ; #define Can0_RxBuffer12          CAN0_CONTROLLER(28)
                     524   ; /* address definitions of the Tx-Buffer - OPERATING MODE - Write only register */
                     525   ; #define Can0_TxFrameInfo         CAN0_CONTROLLER(16)
                     526   ; #define Can0_TxBuffer1           CAN0_CONTROLLER(17)
                     527   ; #define Can0_TxBuffer2           CAN0_CONTROLLER(18)
                     528   ; #define Can0_TxBuffer3           CAN0_CONTROLLER(19)
                     529   ; #define Can0_TxBuffer4           CAN0_CONTROLLER(20)
                     530   ; #define Can0_TxBuffer5           CAN0_CONTROLLER(21)
                     531   ; #define Can0_TxBuffer6           CAN0_CONTROLLER(22)
                     532   ; #define Can0_TxBuffer7           CAN0_CONTROLLER(23)
                     533   ; #define Can0_TxBuffer8           CAN0_CONTROLLER(24)
                     534   ; #define Can0_TxBuffer9           CAN0_CONTROLLER(25)
                     535   ; #define Can0_TxBuffer10          CAN0_CONTROLLER(26)
                     536   ; #define Can0_TxBuffer11          CAN0_CONTROLLER(27)
                     537   ; #define Can0_TxBuffer12          CAN0_CONTROLLER(28)
                     538   ; /* read only addresses */
                     539   ; #define Can0_TxFrameInfoRd       CAN0_CONTROLLER(96)
                     540   ; #define Can0_TxBufferRd1         CAN0_CONTROLLER(97)
                     541   ; #define Can0_TxBufferRd2         CAN0_CONTROLLER(98)
                     542   ; #define Can0_TxBufferRd3         CAN0_CONTROLLER(99)
                     543   ; #define Can0_TxBufferRd4         CAN0_CONTROLLER(100)
                     544   ; #define Can0_TxBufferRd5         CAN0_CONTROLLER(101)
                     545   ; #define Can0_TxBufferRd6         CAN0_CONTROLLER(102)
                     546   ; #define Can0_TxBufferRd7         CAN0_CONTROLLER(103)
                     547   ; #define Can0_TxBufferRd8         CAN0_CONTROLLER(104)
                     548   ; #define Can0_TxBufferRd9         CAN0_CONTROLLER(105)
                     549   ; #define Can0_TxBufferRd10        CAN0_CONTROLLER(106)
                     550   ; #define Can0_TxBufferRd11        CAN0_CONTROLLER(107)
                     551   ; #define Can0_TxBufferRd12        CAN0_CONTROLLER(108)
                     552   ; /* CAN1 Controller register definitions */
                     553   ; #define Can1_ModeControlReg      CAN1_CONTROLLER(0)
                     554   ; #define Can1_CommandReg          CAN1_CONTROLLER(1)
                     555   ; #define Can1_StatusReg           CAN1_CONTROLLER(2)
                     556   ; #define Can1_InterruptReg        CAN1_CONTROLLER(3)
                     557   ; #define Can1_InterruptEnReg      CAN1_CONTROLLER(4) /* PeliCAN mode */
                     558   ; #define Can1_BusTiming0Reg       CAN1_CONTROLLER(6)
                     559   ; #define Can1_BusTiming1Reg       CAN1_CONTROLLER(7)
                     560   ; #define Can1_OutControlReg       CAN1_CONTROLLER(8)
                     561   ; /* address definitions of Other Registers */
                     562   ; #define Can1_ArbLostCapReg       CAN1_CONTROLLER(11)
                     563   ; #define Can1_ErrCodeCapReg       CAN1_CONTROLLER(12)
                     564   ; #define Can1_ErrWarnLimitReg     CAN1_CONTROLLER(13)
                     565   ; #define Can1_RxErrCountReg       CAN1_CONTROLLER(14)
                     566   ; #define Can1_TxErrCountReg       CAN1_CONTROLLER(15)
                     567   ; #define Can1_RxMsgCountReg       CAN1_CONTROLLER(29)
                     568   ; #define Can1_RxBufStartAdr       CAN1_CONTROLLER(30)
                     569   ; #define Can1_ClockDivideReg      CAN1_CONTROLLER(31)
                     570   ; /* address definitions of Acceptance Code & Mask Registers - RESET MODE */
                     571   ; #define Can1_AcceptCode0Reg      CAN1_CONTROLLER(16)
                     572   ; #define Can1_AcceptCode1Reg      CAN1_CONTROLLER(17)
                     573   ; #define Can1_AcceptCode2Reg      CAN1_CONTROLLER(18)
                     574   ; #define Can1_AcceptCode3Reg      CAN1_CONTROLLER(19)
                     575   ; #define Can1_AcceptMask0Reg      CAN1_CONTROLLER(20)
                     576   ; #define Can1_AcceptMask1Reg      CAN1_CONTROLLER(21)
                     577   ; #define Can1_AcceptMask2Reg      CAN1_CONTROLLER(22)
                     578   ; #define Can1_AcceptMask3Reg      CAN1_CONTROLLER(23)
                     579   ; /* address definitions Rx Buffer - OPERATING MODE - Read only register*/
                     580   ; #define Can1_RxFrameInfo         CAN1_CONTROLLER(16)
                     581   ; #define Can1_RxBuffer1           CAN1_CONTROLLER(17)
                     582   ; #define Can1_RxBuffer2           CAN1_CONTROLLER(18)
                     583   ; #define Can1_RxBuffer3           CAN1_CONTROLLER(19)
                     584   ; #define Can1_RxBuffer4           CAN1_CONTROLLER(20)
                     585   ; #define Can1_RxBuffer5           CAN1_CONTROLLER(21)
                     586   ; #define Can1_RxBuffer6           CAN1_CONTROLLER(22)
                     587   ; #define Can1_RxBuffer7           CAN1_CONTROLLER(23)
                     588   ; #define Can1_RxBuffer8           CAN1_CONTROLLER(24)
                     589   ; #define Can1_RxBuffer9           CAN1_CONTROLLER(25)
                     590   ; #define Can1_RxBuffer10          CAN1_CONTROLLER(26)
                     591   ; #define Can1_RxBuffer11          CAN1_CONTROLLER(27)
                     592   ; #define Can1_RxBuffer12          CAN1_CONTROLLER(28)
                     593   ; /* address definitions of the Tx-Buffer - OPERATING MODE - Write only register */
                     594   ; #define Can1_TxFrameInfo         CAN1_CONTROLLER(16)
                     595   ; #define Can1_TxBuffer1           CAN1_CONTROLLER(17)
                     596   ; #define Can1_TxBuffer2           CAN1_CONTROLLER(18)
                     597   ; #define Can1_TxBuffer3           CAN1_CONTROLLER(19)
                     598   ; #define Can1_TxBuffer4           CAN1_CONTROLLER(20)
                     599   ; #define Can1_TxBuffer5           CAN1_CONTROLLER(21)
                     600   ; #define Can1_TxBuffer6           CAN1_CONTROLLER(22)
                     601   ; #define Can1_TxBuffer7           CAN1_CONTROLLER(23)
                     602   ; #define Can1_TxBuffer8           CAN1_CONTROLLER(24)
                     603   ; #define Can1_TxBuffer9           CAN1_CONTROLLER(25)
                     604   ; #define Can1_TxBuffer10          CAN1_CONTROLLER(26)
                     605   ; #define Can1_TxBuffer11          CAN1_CONTROLLER(27)
                     606   ; #define Can1_TxBuffer12          CAN1_CONTROLLER(28)
                     607   ; /* read only addresses */
                     608   ; #define Can1_TxFrameInfoRd       CAN1_CONTROLLER(96)
                     609   ; #define Can1_TxBufferRd1         CAN1_CONTROLLER(97)
                     610   ; #define Can1_TxBufferRd2         CAN1_CONTROLLER(98)
                     611   ; #define Can1_TxBufferRd3         CAN1_CONTROLLER(99)
                     612   ; #define Can1_TxBufferRd4         CAN1_CONTROLLER(100)
                     613   ; #define Can1_TxBufferRd5         CAN1_CONTROLLER(101)
                     614   ; #define Can1_TxBufferRd6         CAN1_CONTROLLER(102)
                     615   ; #define Can1_TxBufferRd7         CAN1_CONTROLLER(103)
                     616   ; #define Can1_TxBufferRd8         CAN1_CONTROLLER(104)
                     617   ; #define Can1_TxBufferRd9         CAN1_CONTROLLER(105)
                     618   ; #define Can1_TxBufferRd10        CAN1_CONTROLLER(106)
                     619   ; #define Can1_TxBufferRd11        CAN1_CONTROLLER(107)
                     620   ; #define Can1_TxBufferRd12        CAN1_CONTROLLER(108)
                     621   ; /* bit definitions for the Mode & Control Register */
                     622   ; #define RM_RR_Bit 0x01 /* reset mode (request) bit */
                     623   ; #define LOM_Bit 0x02 /* listen only mode bit */
                     624   ; #define STM_Bit 0x04 /* self test mode bit */
                     625   ; #define AFM_Bit 0x08 /* acceptance filter mode bit */
                     626   ; #define SM_Bit  0x10 /* enter sleep mode bit */
                     627   ; /* bit definitions for the Interrupt Enable & Control Register */
                     628   ; #define RIE_Bit 0x01 /* receive interrupt enable bit */
                     629   ; #define TIE_Bit 0x02 /* transmit interrupt enable bit */
                     630   ; #define EIE_Bit 0x04 /* error warning interrupt enable bit */
                     631   ; #define DOIE_Bit 0x08 /* data overrun interrupt enable bit */
                     632   ; #define WUIE_Bit 0x10 /* wake-up interrupt enable bit */
                     633   ; #define EPIE_Bit 0x20 /* error passive interrupt enable bit */
                     634   ; #define ALIE_Bit 0x40 /* arbitration lost interr. enable bit*/
                     635   ; #define BEIE_Bit 0x80 /* bus error interrupt enable bit */
                     636   ; /* bit definitions for the Command Register */
                     637   ; #define TR_Bit 0x01 /* transmission request bit */
                     638   ; #define AT_Bit 0x02 /* abort transmission bit */
                     639   ; #define RRB_Bit 0x04 /* release receive buffer bit */
                     640   ; #define CDO_Bit 0x08 /* clear data overrun bit */
                     641   ; #define SRR_Bit 0x10 /* self reception request bit */
                     642   ; /* bit definitions for the Status Register */
                     643   ; #define RBS_Bit 0x01 /* receive buffer status bit */
                     644   ; #define DOS_Bit 0x02 /* data overrun status bit */
                     645   ; #define TBS_Bit 0x04 /* transmit buffer status bit */
                     646   ; #define TCS_Bit 0x08 /* transmission complete status bit */
                     647   ; #define RS_Bit 0x10 /* receive status bit */
                     648   ; #define TS_Bit 0x20 /* transmit status bit */
                     649   ; #define ES_Bit 0x40 /* error status bit */
                     650   ; #define BS_Bit 0x80 /* bus status bit */
                     651   ; /* bit definitions for the Interrupt Register */
                     652   ; #define RI_Bit 0x01 /* receive interrupt bit */
                     653   ; #define TI_Bit 0x02 /* transmit interrupt bit */
                     654   ; #define EI_Bit 0x04 /* error warning interrupt bit */
                     655   ; #define DOI_Bit 0x08 /* data overrun interrupt bit */
                     656   ; #define WUI_Bit 0x10 /* wake-up interrupt bit */
                     657   ; #define EPI_Bit 0x20 /* error passive interrupt bit */
                     658   ; #define ALI_Bit 0x40 /* arbitration lost interrupt bit */
                     659   ; #define BEI_Bit 0x80 /* bus error interrupt bit */
                     660   ; /* bit definitions for the Bus Timing Registers */
                     661   ; #define SAM_Bit 0x80                        /* sample mode bit 1 == the bus is sampled 3 times, 0 == the bus is sampled once */
                     662   ; /* bit definitions for the Output Control Register OCMODE1, OCMODE0 */
                     663   ; #define BiPhaseMode 0x00 /* bi-phase output mode */
                     664   ; #define NormalMode 0x02 /* normal output mode */
                     665   ; #define ClkOutMode 0x03 /* clock output mode */
                     666   ; /* output pin configuration for TX1 */
                     667   ; #define OCPOL1_Bit 0x20 /* output polarity control bit */
                     668   ; #define Tx1Float 0x00 /* configured as float */
                     669   ; #define Tx1PullDn 0x40 /* configured as pull-down */
                     670   ; #define Tx1PullUp 0x80 /* configured as pull-up */
                     671   ; #define Tx1PshPull 0xC0 /* configured as push/pull */
                     672   ; /* output pin configuration for TX0 */
                     673   ; #define OCPOL0_Bit 0x04 /* output polarity control bit */
                     674   ; #define Tx0Float 0x00 /* configured as float */
                     675   ; #define Tx0PullDn 0x08 /* configured as pull-down */
                     676   ; #define Tx0PullUp 0x10 /* configured as pull-up */
                     677   ; #define Tx0PshPull 0x18 /* configured as push/pull */
                     678   ; /* bit definitions for the Clock Divider Register */
                     679   ; #define DivBy1 0x07 /* CLKOUT = oscillator frequency */
                     680   ; #define DivBy2 0x00 /* CLKOUT = 1/2 oscillator frequency */
                     681   ; #define ClkOff_Bit 0x08 /* clock off bit, control of the CLK OUT pin */
                     682   ; #define RXINTEN_Bit 0x20 /* pin TX1 used for receive interrupt */
                     683   ; #define CBP_Bit 0x40 /* CAN comparator bypass control bit */
                     684   ; #define CANMode_Bit 0x80 /* CAN mode definition bit */
                     685   ; /*- definition of used constants ---------------------------------------*/
                     686   ; #define YES 1
                     687   ; #define NO 0
                     688   ; #define ENABLE 1
                     689   ; #define DISABLE 0
                     690   ; #define ENABLE_N 0
                     691   ; #define DISABLE_N 1
                     692   ; #define INTLEVELACT 0
                     693   ; #define INTEDGEACT 1
                     694   ; #define PRIORITY_LOW 0
                     695   ; #define PRIORITY_HIGH 1
                     696   ; /* default (reset) value for register content, clear register */
                     697   ; #define ClrByte 0x00
                     698   ; /* constant: clear Interrupt Enable Register */
                     699   ; #define ClrIntEnSJA ClrByte
                     700   ; /* definitions for the acceptance code and mask register */
                     701   ; #define DontCare 0xFF
                     702   ; /*  bus timing values for
                     703   ; **  bit-rate : 100 kBit/s
                     704   ; **  oscillator frequency : 25 MHz, 1 sample per bit, 0 tolerance %
                     705   ; **  maximum tolerated propagation delay : 4450 ns
                     706   ; **  minimum requested propagation delay : 500 ns
                     707   ; **
                     708   ; **  https://www.kvaser.com/support/calculators/bit-timing-calculator/
                     709   ; **  T1 	T2 	BTQ 	SP% 	SJW 	BIT RATE 	ERR% 	BTR0 	BTR1
                     710   ; **  17	8	25	    68	     1	      100	    0	      04	7f
                     711   ; */
                     712   ; // initialisation for Can controller 0
                     713   ; void Init_CanBus_Controller0(void)
                     714   ; {
                     715   _Init_CanBus_Controller0:
00000932  4E75       716          rts
                     717   ; // TODO - put your Canbus initialisation code for CanController 0 here
                     718   ; // See section 4.2.1 in the application note for details (PELICAN MODE)
                     719   ; }
                     720   ; // initialisation for Can controller 1
                     721   ; void Init_CanBus_Controller1(void)
                     722   ; {
                     723   _Init_CanBus_Controller1:
00000934  4E75       724          rts
                     725   ; // TODO - put your Canbus initialisation code for CanController 1 here
                     726   ; // See section 4.2.1 in the application note for details (PELICAN MODE)
                     727   ; }
                     728   ; // Transmit for sending a message via Can controller 0
                     729   ; void CanBus0_Transmit(void)
                     730   ; {
                     731   _CanBus0_Transmit:
00000936  4E75       732          rts
                     733   ; // TODO - put your Canbus transmit code for CanController 0 here
                     734   ; // See section 4.2.2 in the application note for details (PELICAN MODE)
                     735   ; }
                     736   ; // Transmit for sending a message via Can controller 1
                     737   ; void CanBus1_Transmit(void)
                     738   ; {
                     739   _CanBus1_Transmit:
00000938  4E75       740          rts
                     741   ; // TODO - put your Canbus transmit code for CanController 1 here
                     742   ; // See section 4.2.2 in the application note for details (PELICAN MODE)
                     743   ; }
                     744   ; // Receive for reading a received message via Can controller 0
                     745   ; void CanBus0_Receive(void)
                     746   ; {
                     747   _CanBus0_Receive:
0000093A  4E75       748          rts
                     749   ; // TODO - put your Canbus receive code for CanController 0 here
                     750   ; // See section 4.2.4 in the application note for details (PELICAN MODE)
                     751   ; }
                     752   ; // Receive for reading a received message via Can controller 1
                     753   ; void CanBus1_Receive(void)
                     754   ; {
                     755   _CanBus1_Receive:
0000093C  4E75       756          rts
                     757   ; // TODO - put your Canbus receive code for CanController 1 here
                     758   ; // See section 4.2.4 in the application note for details (PELICAN MODE)
                     759   ; }
                     760   ; void delay(void)
                     761   ; {
                     762   _delay:
0000093E  4E75       763          rts
                     764   ; // TODO - put your delay code here
                     765   ; // This is a simple delay routine for 1/2 second
                     766   ; // You can use a loop or a timer to create the delay
                     767   ; }
                     768   ; void CanBusTest(void)
                     769   ; {
                     770   _CanBusTest:
00000940  2F0A       771          move.l    A2,-(A7)
00000942  45F9 0000  772          lea       _printf.L,A2
00000946  3A1C      
                     773   ; // initialise the two Can controllers
                     774   ; Init_CanBus_Controller0();
00000948  4EB8 0932  775          jsr       _Init_CanBus_Controller0
                     776   ; Init_CanBus_Controller1();
0000094C  4EB8 0934  777          jsr       _Init_CanBus_Controller1
                     778   ; printf("\r\n\r\n---- CANBUS Test ----\r\n") ;
00000950  4879 0000  779          pea       @canbus~1_1.L
00000954  4E9C      
00000956  4E92       780          jsr       (A2)
00000958  584F       781          addq.w    #4,A7
                     782   ; // simple application to alternately transmit and receive messages from each of two nodes
                     783   ; while(1)    {
                     784   CanBusTest_1:
                     785   ; delay();                    // write a routine to delay say 1/2 second so we don't flood the network with messages to0 quickly
0000095A  4EB8 093E  786          jsr       _delay
                     787   ; CanBus0_Transmit() ;       // transmit a message via Controller 0
0000095E  4EB8 0936  788          jsr       _CanBus0_Transmit
                     789   ; CanBus1_Receive() ;        // receive a message via Controller 1 (and display it)
00000962  4EB8 093C  790          jsr       _CanBus1_Receive
                     791   ; printf("\r\n") ;
00000966  4879 0000  792          pea       @canbus~1_2.L
0000096A  4EB8      
0000096C  4E92       793          jsr       (A2)
0000096E  584F       794          addq.w    #4,A7
                     795   ; delay();                    // write a routine to delay say 1/2 second so we don't flood the network with messages to0 quickly
00000970  4EB8 093E  796          jsr       _delay
                     797   ; CanBus1_Transmit() ;        // transmit a message via Controller 1
00000974  4EB8 0938  798          jsr       _CanBus1_Transmit
                     799   ; CanBus0_Receive() ;         // receive a message via Controller 0 (and display it)
00000978  4EB8 093A  800          jsr       _CanBus0_Receive
                     801   ; printf("\r\n") ;
0000097C  4879 0000  802          pea       @canbus~1_2.L
00000980  4EB8      
00000982  4E92       803          jsr       (A2)
00000984  584F       804          addq.w    #4,A7
00000986  60D2       805          bra       CanBusTest_1
                     806   ; }
                     807   ; }
                     808   ; C:\M68KV6.0 - 800BY480\PROGRAMS\DEBUGMONITORCODE\M68KDEBUG (NO DISASSEMBLER).C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
                     809   ; #include "DebugMonitor.h"
                     810   ; // use 08030000 for a system running from sram or 0B000000 for system running from dram
                     811   ; // #define StartOfExceptionVectorTable 0x08030000
                     812   ; #define StartOfExceptionVectorTable 0x0B000000
                     813   ; // use 0C000000 for dram or hex 08040000 for sram
                     814   ; //#define TopOfStack 0x08040000
                     815   ; #define TopOfStack 0x0C000000
                     816   ; /* DO NOT INITIALISE GLOBAL VARIABLES - DO IT in MAIN() */
                     817   ; unsigned int i, x, y, z, PortA_Count;
                     818   ; int     Trace, GoFlag, Echo;                       // used in tracing/single stepping
                     819   ; // 68000 register dump and preintialise value (these can be changed by the user program when it is running, e.g. stack pointer, registers etc
                     820   ; unsigned int d0,d1,d2,d3,d4,d5,d6,d7 ;
                     821   ; unsigned int a0,a1,a2,a3,a4,a5,a6 ;
                     822   ; unsigned int PC, SSP, USP ;
                     823   ; unsigned short int SR;
                     824   ; // Breakpoint variables
                     825   ; unsigned int BreakPointAddress[8];                      //array of 8 breakpoint addresses
                     826   ; unsigned short int BreakPointInstruction[8] ;           // to hold the instruction opcode at the breakpoint
                     827   ; unsigned int BreakPointSetOrCleared[8] ;
                     828   ; unsigned int InstructionSize ;
                     829   ; // watchpoint variables
                     830   ; unsigned int WatchPointAddress[8];                      //array of 8 breakpoint addresses
                     831   ; unsigned int WatchPointSetOrCleared[8] ;
                     832   ; char WatchPointString[8][100] ;
                     833   ; char    TempString[100] ;
                     834   ; /************************************************************************************
                     835   ; *Subroutine to give the 68000 something useless to do to waste 1 mSec
                     836   ; ************************************************************************************/
                     837   ; void Wait1ms(void)
                     838   ; {
                     839   _Wait1ms:
00000988  2F02       840          move.l    D2,-(A7)
                     841   ; long int  i ;
                     842   ; for(i = 0; i < 1000; i ++)
0000098A  4282       843          clr.l     D2
                     844   Wait1ms_1:
0000098C  0C82 0000  845          cmp.l     #1000,D2
00000990  03E8      
00000992  6C04       846          bge.s     Wait1ms_3
00000994  5282       847          addq.l    #1,D2
00000996  60F4       848          bra       Wait1ms_1
                     849   Wait1ms_3:
00000998  241F       850          move.l    (A7)+,D2
0000099A  4E75       851          rts
                     852   ; ;
                     853   ; }
                     854   ; /************************************************************************************
                     855   ; *Subroutine to give the 68000 something useless to do to waste 3 mSec
                     856   ; **************************************************************************************/
                     857   ; void Wait3ms(void)
                     858   ; {
                     859   _Wait3ms:
0000099C  2F02       860          move.l    D2,-(A7)
                     861   ; int i ;
                     862   ; for(i = 0; i < 3; i++)
0000099E  4282       863          clr.l     D2
                     864   Wait3ms_1:
000009A0  0C82 0000  865          cmp.l     #3,D2
000009A4  0003      
000009A6  6C08       866          bge.s     Wait3ms_3
                     867   ; Wait1ms() ;
000009A8  4EB8 0988  868          jsr       _Wait1ms
000009AC  5282       869          addq.l    #1,D2
000009AE  60F0       870          bra       Wait3ms_1
                     871   Wait3ms_3:
000009B0  241F       872          move.l    (A7)+,D2
000009B2  4E75       873          rts
                     874   ; }
                     875   ; /*********************************************************************************************
                     876   ; *Subroutine to initialise the display by writing some commands to the LCD internal registers
                     877   ; *********************************************************************************************/
                     878   ; void Init_LCD(void)
                     879   ; {
                     880   _Init_LCD:
                     881   ; LCDcommand = (char)(0x0c) ;
000009B4  13FC 000C  882          move.b    #12,4194336
000009B8  0040 0020 
                     883   ; Wait3ms() ;
000009BC  4EB8 099C  884          jsr       _Wait3ms
                     885   ; LCDcommand = (char)(0x38) ;
000009C0  13FC 0038  886          move.b    #56,4194336
000009C4  0040 0020 
                     887   ; Wait3ms() ;
000009C8  4EB8 099C  888          jsr       _Wait3ms
000009CC  4E75       889          rts
                     890   ; }
                     891   ; /******************************************************************************
                     892   ; *subroutine to output a single character held in d1 to the LCD display
                     893   ; *it is assumed the character is an ASCII code and it will be displayed at the
                     894   ; *current cursor position
                     895   ; *******************************************************************************/
                     896   ; void Outchar(int c)
                     897   ; {
                     898   _Outchar:
000009CE  4E56 0000  899          link      A6,#0
                     900   ; LCDdata = (char)(c);
000009D2  202E 0008  901          move.l    8(A6),D0
000009D6  13C0 0040  902          move.b    D0,4194338
000009DA  0022      
                     903   ; Wait1ms() ;
000009DC  4EB8 0988  904          jsr       _Wait1ms
000009E0  4E5E       905          unlk      A6
000009E2  4E75       906          rts
                     907   ; }
                     908   ; /**********************************************************************************
                     909   ; *subroutine to output a message at the current cursor position of the LCD display
                     910   ; ************************************************************************************/
                     911   ; void OutMess(char *theMessage)
                     912   ; {
                     913   _OutMess:
000009E4  4E56 FFFC  914          link      A6,#-4
                     915   ; char c ;
                     916   ; while((c = *theMessage++) != (char)(0))
                     917   OutMess_1:
000009E8  206E 0008  918          move.l    8(A6),A0
000009EC  52AE 0008  919          addq.l    #1,8(A6)
000009F0  1D50 FFFF  920          move.b    (A0),-1(A6)
000009F4  1010       921          move.b    (A0),D0
000009F6  6712       922          beq.s     OutMess_3
                     923   ; Outchar(c) ;
000009F8  122E FFFF  924          move.b    -1(A6),D1
000009FC  4881       925          ext.w     D1
000009FE  48C1       926          ext.l     D1
00000A00  2F01       927          move.l    D1,-(A7)
00000A02  4EB8 09CE  928          jsr       _Outchar
00000A06  584F       929          addq.w    #4,A7
00000A08  60DE       930          bra       OutMess_1
                     931   OutMess_3:
00000A0A  4E5E       932          unlk      A6
00000A0C  4E75       933          rts
                     934   ; }
                     935   ; /******************************************************************************
                     936   ; *subroutine to clear the line by issuing 24 space characters
                     937   ; *******************************************************************************/
                     938   ; void Clearln(void)
                     939   ; {
                     940   _Clearln:
00000A0E  2F02       941          move.l    D2,-(A7)
                     942   ; unsigned char i ;
                     943   ; for(i = 0; i < 24; i ++)
00000A10  4202       944          clr.b     D2
                     945   Clearln_1:
00000A12  0C02 0018  946          cmp.b     #24,D2
00000A16  640E       947          bhs.s     Clearln_3
                     948   ; Outchar(' ') ;  /* write a space char to the LCD display */
00000A18  4878 0020  949          pea       32
00000A1C  4EB8 09CE  950          jsr       _Outchar
00000A20  584F       951          addq.w    #4,A7
00000A22  5202       952          addq.b    #1,D2
00000A24  60EC       953          bra       Clearln_1
                     954   Clearln_3:
00000A26  241F       955          move.l    (A7)+,D2
00000A28  4E75       956          rts
                     957   ; }
                     958   ; /******************************************************************************
                     959   ; *subroutine to move the cursor to the start of line 1 and clear that line
                     960   ; *******************************************************************************/
                     961   ; void Oline0(char *theMessage)
                     962   ; {
                     963   _Oline0:
00000A2A  4E56 0000  964          link      A6,#0
                     965   ; LCDcommand = (char)(0x80) ;
00000A2E  13FC 0080  966          move.b    #128,4194336
00000A32  0040 0020 
                     967   ; Wait3ms();
00000A36  4EB8 099C  968          jsr       _Wait3ms
                     969   ; Clearln() ;
00000A3A  4EB8 0A0E  970          jsr       _Clearln
                     971   ; LCDcommand = (char)(0x80) ;
00000A3E  13FC 0080  972          move.b    #128,4194336
00000A42  0040 0020 
                     973   ; Wait3ms() ;
00000A46  4EB8 099C  974          jsr       _Wait3ms
                     975   ; OutMess(theMessage) ;
00000A4A  2F2E 0008  976          move.l    8(A6),-(A7)
00000A4E  4EB8 09E4  977          jsr       _OutMess
00000A52  584F       978          addq.w    #4,A7
00000A54  4E5E       979          unlk      A6
00000A56  4E75       980          rts
                     981   ; }
                     982   ; /******************************************************************************
                     983   ; *subroutine to move the cursor to the start of line 2 and clear that line
                     984   ; *******************************************************************************/
                     985   ; void Oline1(char *theMessage)
                     986   ; {
                     987   _Oline1:
00000A58  4E56 0000  988          link      A6,#0
                     989   ; LCDcommand = (char)(0xC0) ;
00000A5C  13FC 00C0  990          move.b    #192,4194336
00000A60  0040 0020 
                     991   ; Wait3ms();
00000A64  4EB8 099C  992          jsr       _Wait3ms
                     993   ; Clearln() ;
00000A68  4EB8 0A0E  994          jsr       _Clearln
                     995   ; LCDcommand = (char)(0xC0) ;
00000A6C  13FC 00C0  996          move.b    #192,4194336
00000A70  0040 0020 
                     997   ; Wait3ms() ;
00000A74  4EB8 099C  998          jsr       _Wait3ms
                     999   ; OutMess(theMessage) ;
00000A78  2F2E 0008 1000          move.l    8(A6),-(A7)
00000A7C  4EB8 09E4 1001          jsr       _OutMess
00000A80  584F      1002          addq.w    #4,A7
00000A82  4E5E      1003          unlk      A6
00000A84  4E75      1004          rts
                    1005   ; }
                    1006   ; void InstallExceptionHandler( void (*function_ptr)(), int level)
                    1007   ; {
                    1008   _InstallExceptionHandler:
00000A86  4E56 FFFC 1009          link      A6,#-4
                    1010   ; volatile long int *RamVectorAddress = (volatile long int *)(StartOfExceptionVectorTable) ;   // pointer to the Ram based interrupt vector table created in Cstart in debug monitor
00000A8A  2D7C 0B00 1011          move.l    #184549376,-4(A6)
00000A8E  0000 FFFC 
                    1012   ; RamVectorAddress[level] = (long int *)(function_ptr);
00000A92  206E FFFC 1013          move.l    -4(A6),A0
00000A96  202E 000C 1014          move.l    12(A6),D0
00000A9A  E588      1015          lsl.l     #2,D0
00000A9C  21AE 0008 1016          move.l    8(A6),0(A0,D0.L)
00000AA0  0800      
00000AA2  4E5E      1017          unlk      A6
00000AA4  4E75      1018          rts
                    1019   ; }
                    1020   ; void TestLEDS(void)
                    1021   ; {
                    1022   _TestLEDS:
00000AA6  48E7 3000 1023          movem.l   D2/D3,-(A7)
                    1024   ; int delay ;
                    1025   ; unsigned char count = 0 ;
00000AAA  4202      1026          clr.b     D2
                    1027   ; while(1)    {
                    1028   TestLEDS_1:
                    1029   ; PortA = PortB = PortC = PortD = HEX_A = HEX_B = HEX_C = HEX_D = ((count << 4) + (count & 0x0f)) ;
00000AAC  1002      1030          move.b    D2,D0
00000AAE  E908      1031          lsl.b     #4,D0
00000AB0  1202      1032          move.b    D2,D1
00000AB2  C23C 000F 1033          and.b     #15,D1
00000AB6  D001      1034          add.b     D1,D0
00000AB8  13C0 0040 1035          move.b    D0,4194326
00000ABC  0016      
00000ABE  13C0 0040 1036          move.b    D0,4194324
00000AC2  0014      
00000AC4  13C0 0040 1037          move.b    D0,4194322
00000AC8  0012      
00000ACA  13C0 0040 1038          move.b    D0,4194320
00000ACE  0010      
00000AD0  13C0 0040 1039          move.b    D0,4194310
00000AD4  0006      
00000AD6  13C0 0040 1040          move.b    D0,4194308
00000ADA  0004      
00000ADC  13C0 0040 1041          move.b    D0,4194306
00000AE0  0002      
00000AE2  13C0 0040 1042          move.b    D0,4194304
00000AE6  0000      
                    1043   ; for(delay = 0; delay < 200000; delay ++)
00000AE8  4283      1044          clr.l     D3
                    1045   TestLEDS_4:
00000AEA  0C83 0003 1046          cmp.l     #200000,D3
00000AEE  0D40      
00000AF0  6C04      1047          bge.s     TestLEDS_6
00000AF2  5283      1048          addq.l    #1,D3
00000AF4  60F4      1049          bra       TestLEDS_4
                    1050   TestLEDS_6:
                    1051   ; ;
                    1052   ; count ++;
00000AF6  5202      1053          addq.b    #1,D2
00000AF8  60B2      1054          bra       TestLEDS_1
                    1055   ; }
                    1056   ; }
                    1057   ; void SwitchTest(void)
                    1058   ; {
                    1059   _SwitchTest:
00000AFA  48E7 3020 1060          movem.l   D2/D3/A2,-(A7)
00000AFE  45F9 0000 1061          lea       _printf.L,A2
00000B02  3A1C      
                    1062   ; int i, switches = 0 ;
00000B04  4283      1063          clr.l     D3
                    1064   ; printf("\r\n") ;
00000B06  4879 0000 1065          pea       @m68kde~1_1.L
00000B0A  4EBC      
00000B0C  4E92      1066          jsr       (A2)
00000B0E  584F      1067          addq.w    #4,A7
                    1068   ; while(1)    {
                    1069   SwitchTest_1:
                    1070   ; switches = (PortB << 8) | (PortA) ;
00000B10  1039 0040 1071          move.b    4194306,D0
00000B14  0002      
00000B16  C0BC 0000 1072          and.l     #255,D0
00000B1A  00FF      
00000B1C  E188      1073          lsl.l     #8,D0
00000B1E  1239 0040 1074          move.b    4194304,D1
00000B22  0000      
00000B24  C2BC 0000 1075          and.l     #255,D1
00000B28  00FF      
00000B2A  8081      1076          or.l      D1,D0
00000B2C  2600      1077          move.l    D0,D3
                    1078   ; printf("\rSwitches SW[7-0] = ") ;
00000B2E  4879 0000 1079          pea       @m68kde~1_2.L
00000B32  4EC0      
00000B34  4E92      1080          jsr       (A2)
00000B36  584F      1081          addq.w    #4,A7
                    1082   ; for( i = (int)(0x00000080); i > 0; i = i >> 1)  {
00000B38  243C 0000 1083          move.l    #128,D2
00000B3C  0080      
                    1084   SwitchTest_4:
00000B3E  0C82 0000 1085          cmp.l     #0,D2
00000B42  0000      
00000B44  6F20      1086          ble.s     SwitchTest_6
                    1087   ; if((switches & i) == 0)
00000B46  2003      1088          move.l    D3,D0
00000B48  C082      1089          and.l     D2,D0
00000B4A  660C      1090          bne.s     SwitchTest_7
                    1091   ; printf("0") ;
00000B4C  4879 0000 1092          pea       @m68kde~1_3.L
00000B50  4ED6      
00000B52  4E92      1093          jsr       (A2)
00000B54  584F      1094          addq.w    #4,A7
00000B56  600A      1095          bra.s     SwitchTest_8
                    1096   SwitchTest_7:
                    1097   ; else
                    1098   ; printf("1") ;
00000B58  4879 0000 1099          pea       @m68kde~1_4.L
00000B5C  4ED8      
00000B5E  4E92      1100          jsr       (A2)
00000B60  584F      1101          addq.w    #4,A7
                    1102   SwitchTest_8:
00000B62  E282      1103          asr.l     #1,D2
00000B64  60D8      1104          bra       SwitchTest_4
                    1105   SwitchTest_6:
00000B66  60A8      1106          bra       SwitchTest_1
                    1107   ; }
                    1108   ; }
                    1109   ; }
                    1110   ; /*********************************************************************************************
                    1111   ; *Subroutine to initialise the RS232 Port by writing some commands to the internal registers
                    1112   ; *********************************************************************************************/
                    1113   ; void Init_RS232(void)
                    1114   ; {
                    1115   _Init_RS232:
                    1116   ; RS232_Control = (char)(0x15) ; //  %00010101    divide by 16 clock, set rts low, 8 bits no parity, 1 stop bit transmitter interrupt disabled
00000B68  13FC 0015 1117          move.b    #21,4194368
00000B6C  0040 0040 
                    1118   ; RS232_Baud = (char)(0x1) ;      // program baud rate generator 000 = 230k, 001 = 115k, 010 = 57.6k, 011 = 38.4k, 100 = 19.2, all others = 9600
00000B70  13FC 0001 1119          move.b    #1,4194372
00000B74  0040 0044 
00000B78  4E75      1120          rts
                    1121   ; }
                    1122   ; int kbhit(void)
                    1123   ; {
                    1124   _kbhit:
                    1125   ; if(((char)(RS232_Status) & (char)(0x01)) == (char)(0x01))    // wait for Rx bit in status register to be '1'
00000B7A  1039 0040 1126          move.b    4194368,D0
00000B7E  0040      
00000B80  C03C 0001 1127          and.b     #1,D0
00000B84  0C00 0001 1128          cmp.b     #1,D0
00000B88  6604      1129          bne.s     kbhit_1
                    1130   ; return 1 ;
00000B8A  7001      1131          moveq     #1,D0
00000B8C  6002      1132          bra.s     kbhit_3
                    1133   kbhit_1:
                    1134   ; else
                    1135   ; return 0 ;
00000B8E  4280      1136          clr.l     D0
                    1137   kbhit_3:
00000B90  4E75      1138          rts
                    1139   ; }
                    1140   ; /*********************************************************************************************************
                    1141   ; **  Subroutine to provide a low level output function to 6850 ACIA
                    1142   ; **  This routine provides the basic functionality to output a single character to the serial Port
                    1143   ; **  to allow the board to communicate with HyperTerminal Program
                    1144   ; **
                    1145   ; **  NOTE you do not call this function directly, instead you call the normal putchar() function
                    1146   ; **  which in turn calls _putch() below). Other functions like puts(), printf() call putchar() so will
                    1147   ; **  call _putch() also
                    1148   ; *********************************************************************************************************/
                    1149   ; int _putch( int c)
                    1150   ; {
                    1151   __putch:
00000B92  4E56 0000 1152          link      A6,#0
                    1153   ; while(((char)(RS232_Status) & (char)(0x02)) != (char)(0x02))    // wait for Tx bit in status register or 6850 serial comms chip to be '1'
                    1154   _putch_1:
00000B96  1039 0040 1155          move.b    4194368,D0
00000B9A  0040      
00000B9C  C03C 0002 1156          and.b     #2,D0
00000BA0  0C00 0002 1157          cmp.b     #2,D0
00000BA4  6702      1158          beq.s     _putch_3
00000BA6  60EE      1159          bra       _putch_1
                    1160   _putch_3:
                    1161   ; ;
                    1162   ; (char)(RS232_TxData) = ((char)(c) & (char)(0x7f));                      // write to the data register to output the character (mask off bit 8 to keep it 7 bit ASCII)
00000BA8  202E 0008 1163          move.l    8(A6),D0
00000BAC  C03C 007F 1164          and.b     #127,D0
00000BB0  13C0 0040 1165          move.b    D0,4194370
00000BB4  0042      
                    1166   ; return c ;                                              // putchar() expects the character to be returned
00000BB6  202E 0008 1167          move.l    8(A6),D0
00000BBA  4E5E      1168          unlk      A6
00000BBC  4E75      1169          rts
                    1170   ; }
                    1171   ; /*********************************************************************************************************
                    1172   ; **  Subroutine to provide a low level input function to 6850 ACIA
                    1173   ; **  This routine provides the basic functionality to input a single character from the serial Port
                    1174   ; **  to allow the board to communicate with HyperTerminal Program Keyboard (your PC)
                    1175   ; **
                    1176   ; **  NOTE you do not call this function directly, instead you call the normal _getch() function
                    1177   ; **  which in turn calls _getch() below). Other functions like gets(), scanf() call _getch() so will
                    1178   ; **  call _getch() also
                    1179   ; *********************************************************************************************************/
                    1180   ; int _getch( void )
                    1181   ; {
                    1182   __getch:
00000BBE  2F02      1183          move.l    D2,-(A7)
                    1184   ; int c ;
                    1185   ; while(((char)(RS232_Status) & (char)(0x01)) != (char)(0x01))    // wait for Rx bit in 6850 serial comms chip status register to be '1'
                    1186   _getch_1:
00000BC0  1039 0040 1187          move.b    4194368,D0
00000BC4  0040      
00000BC6  C03C 0001 1188          and.b     #1,D0
00000BCA  0C00 0001 1189          cmp.b     #1,D0
00000BCE  6702      1190          beq.s     _getch_3
00000BD0  60EE      1191          bra       _getch_1
                    1192   _getch_3:
                    1193   ; ;
                    1194   ; c = (RS232_RxData & (char)(0x7f));                   // read received character, mask off top bit and return as 7 bit ASCII character
00000BD2  1039 0040 1195          move.b    4194370,D0
00000BD6  0042      
00000BD8  C0BC 0000 1196          and.l     #255,D0
00000BDC  00FF      
00000BDE  C0BC 0000 1197          and.l     #127,D0
00000BE2  007F      
00000BE4  2400      1198          move.l    D0,D2
                    1199   ; // shall we echo the character? Echo is set to TRUE at reset, but for speed we don't want to echo when downloading code with the 'L' debugger command
                    1200   ; if(Echo)
00000BE6  4AB9 0B00 1201          tst.l     _Echo.L
00000BEA  00E0      
00000BEC  6708      1202          beq.s     _getch_4
                    1203   ; _putch(c);
00000BEE  2F02      1204          move.l    D2,-(A7)
00000BF0  4EB8 0B92 1205          jsr       __putch
00000BF4  584F      1206          addq.w    #4,A7
                    1207   _getch_4:
                    1208   ; return c ;
00000BF6  2002      1209          move.l    D2,D0
00000BF8  241F      1210          move.l    (A7)+,D2
00000BFA  4E75      1211          rts
                    1212   ; }
                    1213   ; // flush the input stream for any unread characters
                    1214   ; void FlushKeyboard(void)
                    1215   ; {
                    1216   _FlushKeyboard:
00000BFC  4E56 FFFC 1217          link      A6,#-4
                    1218   ; char c ;
                    1219   ; while(1)    {
                    1220   FlushKeyboard_1:
                    1221   ; if(((char)(RS232_Status) & (char)(0x01)) == (char)(0x01))    // if Rx bit in status register is '1'
00000C00  1039 0040 1222          move.b    4194368,D0
00000C04  0040      
00000C06  C03C 0001 1223          and.b     #1,D0
00000C0A  0C00 0001 1224          cmp.b     #1,D0
00000C0E  6610      1225          bne.s     FlushKeyboard_4
                    1226   ; c = ((char)(RS232_RxData) & (char)(0x7f)) ;
00000C10  1039 0040 1227          move.b    4194370,D0
00000C14  0042      
00000C16  C03C 007F 1228          and.b     #127,D0
00000C1A  1D40 FFFF 1229          move.b    D0,-1(A6)
00000C1E  6002      1230          bra.s     FlushKeyboard_5
                    1231   FlushKeyboard_4:
                    1232   ; else
                    1233   ; return ;
00000C20  6002      1234          bra.s     FlushKeyboard_6
                    1235   FlushKeyboard_5:
00000C22  60DC      1236          bra       FlushKeyboard_1
                    1237   FlushKeyboard_6:
00000C24  4E5E      1238          unlk      A6
00000C26  4E75      1239          rts
                    1240   ; }
                    1241   ; }
                    1242   ; // converts hex char to 4 bit binary equiv in range 0000-1111 (0-F)
                    1243   ; // char assumed to be a valid hex char 0-9, a-f, A-F
                    1244   ; char xtod(int c)
                    1245   ; {
                    1246   _xtod:
00000C28  4E56 0000 1247          link      A6,#0
00000C2C  2F02      1248          move.l    D2,-(A7)
00000C2E  242E 0008 1249          move.l    8(A6),D2
                    1250   ; if ((char)(c) <= (char)('9'))
00000C32  0C02 0039 1251          cmp.b     #57,D2
00000C36  6E08      1252          bgt.s     xtod_1
                    1253   ; return c - (char)(0x30);    // 0 - 9 = 0x30 - 0x39 so convert to number by sutracting 0x30
00000C38  1002      1254          move.b    D2,D0
00000C3A  0400 0030 1255          sub.b     #48,D0
00000C3E  6014      1256          bra.s     xtod_3
                    1257   xtod_1:
                    1258   ; else if((char)(c) > (char)('F'))    // assume lower case
00000C40  0C02 0046 1259          cmp.b     #70,D2
00000C44  6F08      1260          ble.s     xtod_4
                    1261   ; return c - (char)(0x57);    // a-f = 0x61-66 so needs to be converted to 0x0A - 0x0F so subtract 0x57
00000C46  1002      1262          move.b    D2,D0
00000C48  0400 0057 1263          sub.b     #87,D0
00000C4C  6006      1264          bra.s     xtod_3
                    1265   xtod_4:
                    1266   ; else
                    1267   ; return c - (char)(0x37);    // A-F = 0x41-46 so needs to be converted to 0x0A - 0x0F so subtract 0x37
00000C4E  1002      1268          move.b    D2,D0
00000C50  0400 0037 1269          sub.b     #55,D0
                    1270   xtod_3:
00000C54  241F      1271          move.l    (A7)+,D2
00000C56  4E5E      1272          unlk      A6
00000C58  4E75      1273          rts
                    1274   ; }
                    1275   ; int Get2HexDigits(char *CheckSumPtr)
                    1276   ; {
                    1277   _Get2HexDigits:
00000C5A  4E56 0000 1278          link      A6,#0
00000C5E  2F02      1279          move.l    D2,-(A7)
                    1280   ; register int i = (xtod(_getch()) << 4) | (xtod(_getch()));
00000C60  2F00      1281          move.l    D0,-(A7)
00000C62  4EB8 0BBE 1282          jsr       __getch
00000C66  2200      1283          move.l    D0,D1
00000C68  201F      1284          move.l    (A7)+,D0
00000C6A  2F01      1285          move.l    D1,-(A7)
00000C6C  4EB8 0C28 1286          jsr       _xtod
00000C70  584F      1287          addq.w    #4,A7
00000C72  C0BC 0000 1288          and.l     #255,D0
00000C76  00FF      
00000C78  E980      1289          asl.l     #4,D0
00000C7A  2F00      1290          move.l    D0,-(A7)
00000C7C  2F01      1291          move.l    D1,-(A7)
00000C7E  4EB8 0BBE 1292          jsr       __getch
00000C82  221F      1293          move.l    (A7)+,D1
00000C84  2F00      1294          move.l    D0,-(A7)
00000C86  4EB8 0C28 1295          jsr       _xtod
00000C8A  584F      1296          addq.w    #4,A7
00000C8C  2200      1297          move.l    D0,D1
00000C8E  201F      1298          move.l    (A7)+,D0
00000C90  C2BC 0000 1299          and.l     #255,D1
00000C94  00FF      
00000C96  8081      1300          or.l      D1,D0
00000C98  2400      1301          move.l    D0,D2
                    1302   ; if(CheckSumPtr)
00000C9A  4AAE 0008 1303          tst.l     8(A6)
00000C9E  6706      1304          beq.s     Get2HexDigits_1
                    1305   ; *CheckSumPtr += i ;
00000CA0  206E 0008 1306          move.l    8(A6),A0
00000CA4  D510      1307          add.b     D2,(A0)
                    1308   Get2HexDigits_1:
                    1309   ; return i ;
00000CA6  2002      1310          move.l    D2,D0
00000CA8  241F      1311          move.l    (A7)+,D2
00000CAA  4E5E      1312          unlk      A6
00000CAC  4E75      1313          rts
                    1314   ; }
                    1315   ; int Get4HexDigits(char *CheckSumPtr)
                    1316   ; {
                    1317   _Get4HexDigits:
00000CAE  4E56 0000 1318          link      A6,#0
                    1319   ; return (Get2HexDigits(CheckSumPtr) << 8) | (Get2HexDigits(CheckSumPtr));
00000CB2  2F2E 0008 1320          move.l    8(A6),-(A7)
00000CB6  4EB8 0C5A 1321          jsr       _Get2HexDigits
00000CBA  584F      1322          addq.w    #4,A7
00000CBC  E180      1323          asl.l     #8,D0
00000CBE  2F00      1324          move.l    D0,-(A7)
00000CC0  2F2E 0008 1325          move.l    8(A6),-(A7)
00000CC4  4EB8 0C5A 1326          jsr       _Get2HexDigits
00000CC8  584F      1327          addq.w    #4,A7
00000CCA  2200      1328          move.l    D0,D1
00000CCC  201F      1329          move.l    (A7)+,D0
00000CCE  8081      1330          or.l      D1,D0
00000CD0  4E5E      1331          unlk      A6
00000CD2  4E75      1332          rts
                    1333   ; }
                    1334   ; int Get6HexDigits(char *CheckSumPtr)
                    1335   ; {
                    1336   _Get6HexDigits:
00000CD4  4E56 0000 1337          link      A6,#0
                    1338   ; return (Get4HexDigits(CheckSumPtr) << 8) | (Get2HexDigits(CheckSumPtr));
00000CD8  2F2E 0008 1339          move.l    8(A6),-(A7)
00000CDC  4EB8 0CAE 1340          jsr       _Get4HexDigits
00000CE0  584F      1341          addq.w    #4,A7
00000CE2  E180      1342          asl.l     #8,D0
00000CE4  2F00      1343          move.l    D0,-(A7)
00000CE6  2F2E 0008 1344          move.l    8(A6),-(A7)
00000CEA  4EB8 0C5A 1345          jsr       _Get2HexDigits
00000CEE  584F      1346          addq.w    #4,A7
00000CF0  2200      1347          move.l    D0,D1
00000CF2  201F      1348          move.l    (A7)+,D0
00000CF4  8081      1349          or.l      D1,D0
00000CF6  4E5E      1350          unlk      A6
00000CF8  4E75      1351          rts
                    1352   ; }
                    1353   ; int Get8HexDigits(char *CheckSumPtr)
                    1354   ; {
                    1355   _Get8HexDigits:
00000CFA  4E56 0000 1356          link      A6,#0
                    1357   ; return (Get4HexDigits(CheckSumPtr) << 16) | (Get4HexDigits(CheckSumPtr));
00000CFE  2F2E 0008 1358          move.l    8(A6),-(A7)
00000D02  4EB8 0CAE 1359          jsr       _Get4HexDigits
00000D06  584F      1360          addq.w    #4,A7
00000D08  E180      1361          asl.l     #8,D0
00000D0A  E180      1362          asl.l     #8,D0
00000D0C  2F00      1363          move.l    D0,-(A7)
00000D0E  2F2E 0008 1364          move.l    8(A6),-(A7)
00000D12  4EB8 0CAE 1365          jsr       _Get4HexDigits
00000D16  584F      1366          addq.w    #4,A7
00000D18  2200      1367          move.l    D0,D1
00000D1A  201F      1368          move.l    (A7)+,D0
00000D1C  8081      1369          or.l      D1,D0
00000D1E  4E5E      1370          unlk      A6
00000D20  4E75      1371          rts
                    1372   ; }
                    1373   ; void DumpMemory(void)   // simple dump memory fn
                    1374   ; {
                    1375   _DumpMemory:
00000D22  48E7 3C30 1376          movem.l   D2/D3/D4/D5/A2/A3,-(A7)
00000D26  45F9 0000 1377          lea       _printf.L,A2
00000D2A  3A1C      
00000D2C  47F9 0000 1378          lea       _putch.L,A3
00000D30  3B3C      
                    1379   ; int i, j ;
                    1380   ; unsigned char *RamPtr,c ; // pointer to where the program is download (assumed)
                    1381   ; printf("\r\nDump Memory Block: <ESC> to Abort, <SPACE> to Continue") ;
00000D32  4879 0000 1382          pea       @m68kde~1_5.L
00000D36  4EDA      
00000D38  4E92      1383          jsr       (A2)
00000D3A  584F      1384          addq.w    #4,A7
                    1385   ; printf("\r\nEnter Start Address: ") ;
00000D3C  4879 0000 1386          pea       @m68kde~1_6.L
00000D40  4F14      
00000D42  4E92      1387          jsr       (A2)
00000D44  584F      1388          addq.w    #4,A7
                    1389   ; RamPtr = Get8HexDigits(0) ;
00000D46  42A7      1390          clr.l     -(A7)
00000D48  4EB8 0CFA 1391          jsr       _Get8HexDigits
00000D4C  584F      1392          addq.w    #4,A7
00000D4E  2600      1393          move.l    D0,D3
                    1394   ; while(1)    {
                    1395   DumpMemory_1:
                    1396   ; for(i = 0; i < 16; i ++)    {
00000D50  4285      1397          clr.l     D5
                    1398   DumpMemory_4:
00000D52  0C85 0000 1399          cmp.l     #16,D5
00000D56  0010      
00000D58  6C00 0096 1400          bge       DumpMemory_6
                    1401   ; printf("\r\n%08x ", RamPtr) ;
00000D5C  2F03      1402          move.l    D3,-(A7)
00000D5E  4879 0000 1403          pea       @m68kde~1_7.L
00000D62  4F2C      
00000D64  4E92      1404          jsr       (A2)
00000D66  504F      1405          addq.w    #8,A7
                    1406   ; for(j=0; j < 16; j ++)  {
00000D68  4282      1407          clr.l     D2
                    1408   DumpMemory_7:
00000D6A  0C82 0000 1409          cmp.l     #16,D2
00000D6E  0010      
00000D70  6C24      1410          bge.s     DumpMemory_9
                    1411   ; printf("%02X",RamPtr[j]) ;
00000D72  2043      1412          move.l    D3,A0
00000D74  1230 2800 1413          move.b    0(A0,D2.L),D1
00000D78  C2BC 0000 1414          and.l     #255,D1
00000D7C  00FF      
00000D7E  2F01      1415          move.l    D1,-(A7)
00000D80  4879 0000 1416          pea       @m68kde~1_8.L
00000D84  4F34      
00000D86  4E92      1417          jsr       (A2)
00000D88  504F      1418          addq.w    #8,A7
                    1419   ; putchar(' ') ;
00000D8A  4878 0020 1420          pea       32
00000D8E  4E93      1421          jsr       (A3)
00000D90  584F      1422          addq.w    #4,A7
00000D92  5282      1423          addq.l    #1,D2
00000D94  60D4      1424          bra       DumpMemory_7
                    1425   DumpMemory_9:
                    1426   ; }
                    1427   ; // now display the data as ASCII at the end
                    1428   ; printf("  ") ;
00000D96  4879 0000 1429          pea       @m68kde~1_9.L
00000D9A  4F3A      
00000D9C  4E92      1430          jsr       (A2)
00000D9E  584F      1431          addq.w    #4,A7
                    1432   ; for(j = 0; j < 16; j++) {
00000DA0  4282      1433          clr.l     D2
                    1434   DumpMemory_10:
00000DA2  0C82 0000 1435          cmp.l     #16,D2
00000DA6  0010      
00000DA8  6C00 003A 1436          bge       DumpMemory_12
                    1437   ; c = ((char)(RamPtr[j]) & 0x7f) ;
00000DAC  2043      1438          move.l    D3,A0
00000DAE  1030 2800 1439          move.b    0(A0,D2.L),D0
00000DB2  C03C 007F 1440          and.b     #127,D0
00000DB6  1800      1441          move.b    D0,D4
                    1442   ; if((c > (char)(0x7f)) || (c < ' '))
00000DB8  0C04 007F 1443          cmp.b     #127,D4
00000DBC  6206      1444          bhi.s     DumpMemory_15
00000DBE  0C04 0020 1445          cmp.b     #32,D4
00000DC2  640A      1446          bhs.s     DumpMemory_13
                    1447   DumpMemory_15:
                    1448   ; putchar('.') ;
00000DC4  4878 002E 1449          pea       46
00000DC8  4E93      1450          jsr       (A3)
00000DCA  584F      1451          addq.w    #4,A7
00000DCC  6012      1452          bra.s     DumpMemory_14
                    1453   DumpMemory_13:
                    1454   ; else
                    1455   ; putchar(RamPtr[j]) ;
00000DCE  2043      1456          move.l    D3,A0
00000DD0  1230 2800 1457          move.b    0(A0,D2.L),D1
00000DD4  C2BC 0000 1458          and.l     #255,D1
00000DD8  00FF      
00000DDA  2F01      1459          move.l    D1,-(A7)
00000DDC  4E93      1460          jsr       (A3)
00000DDE  584F      1461          addq.w    #4,A7
                    1462   DumpMemory_14:
00000DE0  5282      1463          addq.l    #1,D2
00000DE2  60BE      1464          bra       DumpMemory_10
                    1465   DumpMemory_12:
                    1466   ; }
                    1467   ; RamPtr = RamPtr + 16 ;
00000DE4  0683 0000 1468          add.l     #16,D3
00000DE8  0010      
00000DEA  5285      1469          addq.l    #1,D5
00000DEC  6000 FF64 1470          bra       DumpMemory_4
                    1471   DumpMemory_6:
                    1472   ; }
                    1473   ; printf("\r\n") ;
00000DF0  4879 0000 1474          pea       @m68kde~1_1.L
00000DF4  4EBC      
00000DF6  4E92      1475          jsr       (A2)
00000DF8  584F      1476          addq.w    #4,A7
                    1477   ; c = _getch() ;
00000DFA  4EB8 0BBE 1478          jsr       __getch
00000DFE  1800      1479          move.b    D0,D4
                    1480   ; if(c == 0x1b)          // break on ESC
00000E00  0C04 001B 1481          cmp.b     #27,D4
00000E04  6602      1482          bne.s     DumpMemory_16
                    1483   ; break ;
00000E06  6004      1484          bra.s     DumpMemory_3
                    1485   DumpMemory_16:
00000E08  6000 FF46 1486          bra       DumpMemory_1
                    1487   DumpMemory_3:
00000E0C  4CDF 0C3C 1488          movem.l   (A7)+,D2/D3/D4/D5/A2/A3
00000E10  4E75      1489          rts
                    1490   ; }
                    1491   ; }
                    1492   ; void FillMemory()
                    1493   ; {
                    1494   _FillMemory:
00000E12  48E7 3820 1495          movem.l   D2/D3/D4/A2,-(A7)
00000E16  45F9 0000 1496          lea       _printf.L,A2
00000E1A  3A1C      
                    1497   ; char *StartRamPtr, *EndRamPtr ;
                    1498   ; unsigned char FillData ;
                    1499   ; printf("\r\nFill Memory Block") ;
00000E1C  4879 0000 1500          pea       @m68kde~1_10.L
00000E20  4F3E      
00000E22  4E92      1501          jsr       (A2)
00000E24  584F      1502          addq.w    #4,A7
                    1503   ; printf("\r\nEnter Start Address: ") ;
00000E26  4879 0000 1504          pea       @m68kde~1_6.L
00000E2A  4F14      
00000E2C  4E92      1505          jsr       (A2)
00000E2E  584F      1506          addq.w    #4,A7
                    1507   ; StartRamPtr = Get8HexDigits(0) ;
00000E30  42A7      1508          clr.l     -(A7)
00000E32  4EB8 0CFA 1509          jsr       _Get8HexDigits
00000E36  584F      1510          addq.w    #4,A7
00000E38  2400      1511          move.l    D0,D2
                    1512   ; printf("\r\nEnter End Address: ") ;
00000E3A  4879 0000 1513          pea       @m68kde~1_11.L
00000E3E  4F52      
00000E40  4E92      1514          jsr       (A2)
00000E42  584F      1515          addq.w    #4,A7
                    1516   ; EndRamPtr = Get8HexDigits(0) ;
00000E44  42A7      1517          clr.l     -(A7)
00000E46  4EB8 0CFA 1518          jsr       _Get8HexDigits
00000E4A  584F      1519          addq.w    #4,A7
00000E4C  2800      1520          move.l    D0,D4
                    1521   ; printf("\r\nEnter Fill Data: ") ;
00000E4E  4879 0000 1522          pea       @m68kde~1_12.L
00000E52  4F68      
00000E54  4E92      1523          jsr       (A2)
00000E56  584F      1524          addq.w    #4,A7
                    1525   ; FillData = Get2HexDigits(0) ;
00000E58  42A7      1526          clr.l     -(A7)
00000E5A  4EB8 0C5A 1527          jsr       _Get2HexDigits
00000E5E  584F      1528          addq.w    #4,A7
00000E60  1600      1529          move.b    D0,D3
                    1530   ; printf("\r\nFilling Addresses [$%08X - $%08X] with $%02X", StartRamPtr, EndRamPtr, FillData) ;
00000E62  C6BC 0000 1531          and.l     #255,D3
00000E66  00FF      
00000E68  2F03      1532          move.l    D3,-(A7)
00000E6A  2F04      1533          move.l    D4,-(A7)
00000E6C  2F02      1534          move.l    D2,-(A7)
00000E6E  4879 0000 1535          pea       @m68kde~1_13.L
00000E72  4F7C      
00000E74  4E92      1536          jsr       (A2)
00000E76  DEFC 0010 1537          add.w     #16,A7
                    1538   ; while(StartRamPtr < EndRamPtr)
                    1539   FillMemory_1:
00000E7A  B484      1540          cmp.l     D4,D2
00000E7C  6408      1541          bhs.s     FillMemory_3
                    1542   ; *StartRamPtr++ = FillData ;
00000E7E  2042      1543          move.l    D2,A0
00000E80  5282      1544          addq.l    #1,D2
00000E82  1083      1545          move.b    D3,(A0)
00000E84  60F4      1546          bra       FillMemory_1
                    1547   FillMemory_3:
00000E86  4CDF 041C 1548          movem.l   (A7)+,D2/D3/D4/A2
00000E8A  4E75      1549          rts
                    1550   ; }
                    1551   ; void Load_SRecordFile()
                    1552   ; {
                    1553   _Load_SRecordFile:
00000E8C  4E56 FFDC 1554          link      A6,#-36
00000E90  48E7 3F3C 1555          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
00000E94  45EE FFFA 1556          lea       -6(A6),A2
00000E98  47F8 0C5A 1557          lea       _Get2HexDigits.L,A3
00000E9C  49F9 0000 1558          lea       _printf.L,A4
00000EA0  3A1C      
                    1559   ; int i, Address, AddressSize, DataByte, NumDataBytesToRead, LoadFailed, FailedAddress, AddressFail, SRecordCount = 0, ByteTotal = 0 ;
00000EA2  42AE FFEE 1560          clr.l     -18(A6)
00000EA6  3A7C 0000 1561          move.w    #0,A5
                    1562   ; int result, ByteCount ;
                    1563   ; char c, CheckSum, ReadCheckSum, HeaderType ;
                    1564   ; char *RamPtr ;                          // pointer to Memory where downloaded program will be stored
                    1565   ; LoadFailed = 0 ;                        //assume LOAD operation will pass
00000EAA  7E00      1566          moveq     #0,D7
                    1567   ; AddressFail = 0 ;
00000EAC  42AE FFEA 1568          clr.l     -22(A6)
                    1569   ; Echo = 0 ;                              // don't echo S records during download
00000EB0  42B9 0B00 1570          clr.l     _Echo.L
00000EB4  00E0      
                    1571   ; printf("\r\nUse HyperTerminal to Send Text File (.hex)\r\n") ;
00000EB6  4879 0000 1572          pea       @m68kde~1_14.L
00000EBA  4FAC      
00000EBC  4E94      1573          jsr       (A4)
00000EBE  584F      1574          addq.w    #4,A7
                    1575   ; while(1)    {
                    1576   Load_SRecordFile_1:
                    1577   ; CheckSum = 0 ;
00000EC0  4212      1578          clr.b     (A2)
                    1579   ; do {
                    1580   Load_SRecordFile_4:
                    1581   ; c = toupper(_getch()) ;
00000EC2  2F00      1582          move.l    D0,-(A7)
00000EC4  4EB8 0BBE 1583          jsr       __getch
00000EC8  2200      1584          move.l    D0,D1
00000ECA  201F      1585          move.l    (A7)+,D0
00000ECC  2F01      1586          move.l    D1,-(A7)
00000ECE  4EB9 0000 1587          jsr       _toupper
00000ED2  3C36      
00000ED4  584F      1588          addq.w    #4,A7
00000ED6  1C00      1589          move.b    D0,D6
                    1590   ; if(c == 0x1b )      // if break
00000ED8  0C06 001B 1591          cmp.b     #27,D6
00000EDC  6604      1592          bne.s     Load_SRecordFile_6
                    1593   ; return;
00000EDE  6000 0132 1594          bra       Load_SRecordFile_8
                    1595   Load_SRecordFile_6:
00000EE2  0C06 0053 1596          cmp.b     #83,D6
00000EE6  66DA      1597          bne       Load_SRecordFile_4
                    1598   ; }while(c != (char)('S'));   // wait for S start of header
                    1599   ; HeaderType = _getch() ;
00000EE8  4EB8 0BBE 1600          jsr       __getch
00000EEC  1600      1601          move.b    D0,D3
                    1602   ; if(HeaderType == (char)('0') || HeaderType == (char)('5'))       // ignore s0, s5 records
00000EEE  0C03 0030 1603          cmp.b     #48,D3
00000EF2  6706      1604          beq.s     Load_SRecordFile_11
00000EF4  0C03 0035 1605          cmp.b     #53,D3
00000EF8  6604      1606          bne.s     Load_SRecordFile_9
                    1607   Load_SRecordFile_11:
                    1608   ; continue ;
00000EFA  6000 00D2 1609          bra       Load_SRecordFile_23
                    1610   Load_SRecordFile_9:
                    1611   ; if(HeaderType >= (char)('7'))
00000EFE  0C03 0037 1612          cmp.b     #55,D3
00000F02  6D04      1613          blt.s     Load_SRecordFile_12
                    1614   ; break ;                 // end load on s7,s8,s9 records
00000F04  6000 00CC 1615          bra       Load_SRecordFile_3
                    1616   Load_SRecordFile_12:
                    1617   ; // get the bytecount
                    1618   ; ByteCount = Get2HexDigits(&CheckSum) ;
00000F08  2F0A      1619          move.l    A2,-(A7)
00000F0A  4E93      1620          jsr       (A3)
00000F0C  584F      1621          addq.w    #4,A7
00000F0E  2D40 FFF6 1622          move.l    D0,-10(A6)
                    1623   ; // get the address, 4 digits for s1, 6 digits for s2, and 8 digits for s3 record
                    1624   ; if(HeaderType == (char)('1')) {
00000F12  0C03 0031 1625          cmp.b     #49,D3
00000F16  660E      1626          bne.s     Load_SRecordFile_14
                    1627   ; AddressSize = 2 ;       // 2 byte address
00000F18  7A02      1628          moveq     #2,D5
                    1629   ; Address = Get4HexDigits(&CheckSum);
00000F1A  2F0A      1630          move.l    A2,-(A7)
00000F1C  4EB8 0CAE 1631          jsr       _Get4HexDigits
00000F20  584F      1632          addq.w    #4,A7
00000F22  2800      1633          move.l    D0,D4
00000F24  6020      1634          bra.s     Load_SRecordFile_17
                    1635   Load_SRecordFile_14:
                    1636   ; }
                    1637   ; else if (HeaderType == (char)('2')) {
00000F26  0C03 0032 1638          cmp.b     #50,D3
00000F2A  660E      1639          bne.s     Load_SRecordFile_16
                    1640   ; AddressSize = 3 ;       // 3 byte address
00000F2C  7A03      1641          moveq     #3,D5
                    1642   ; Address = Get6HexDigits(&CheckSum) ;
00000F2E  2F0A      1643          move.l    A2,-(A7)
00000F30  4EB8 0CD4 1644          jsr       _Get6HexDigits
00000F34  584F      1645          addq.w    #4,A7
00000F36  2800      1646          move.l    D0,D4
00000F38  600C      1647          bra.s     Load_SRecordFile_17
                    1648   Load_SRecordFile_16:
                    1649   ; }
                    1650   ; else    {
                    1651   ; AddressSize = 4 ;       // 4 byte address
00000F3A  7A04      1652          moveq     #4,D5
                    1653   ; Address = Get8HexDigits(&CheckSum) ;
00000F3C  2F0A      1654          move.l    A2,-(A7)
00000F3E  4EB8 0CFA 1655          jsr       _Get8HexDigits
00000F42  584F      1656          addq.w    #4,A7
00000F44  2800      1657          move.l    D0,D4
                    1658   Load_SRecordFile_17:
                    1659   ; }
                    1660   ; RamPtr = (char *)(Address) ;                            // point to download area
00000F46  2D44 FFFC 1661          move.l    D4,-4(A6)
                    1662   ; NumDataBytesToRead = ByteCount - AddressSize - 1 ;
00000F4A  202E FFF6 1663          move.l    -10(A6),D0
00000F4E  9085      1664          sub.l     D5,D0
00000F50  5380      1665          subq.l    #1,D0
00000F52  2D40 FFE2 1666          move.l    D0,-30(A6)
                    1667   ; for(i = 0; i < NumDataBytesToRead; i ++) {     // read in remaining data bytes (ignore address and checksum at the end
00000F56  4282      1668          clr.l     D2
                    1669   Load_SRecordFile_18:
00000F58  B4AE FFE2 1670          cmp.l     -30(A6),D2
00000F5C  6C1E      1671          bge.s     Load_SRecordFile_20
                    1672   ; DataByte = Get2HexDigits(&CheckSum) ;
00000F5E  2F0A      1673          move.l    A2,-(A7)
00000F60  4E93      1674          jsr       (A3)
00000F62  584F      1675          addq.w    #4,A7
00000F64  2D40 FFDE 1676          move.l    D0,-34(A6)
                    1677   ; *RamPtr++ = DataByte ;                      // store downloaded byte in Ram at specified address
00000F68  202E FFDE 1678          move.l    -34(A6),D0
00000F6C  206E FFFC 1679          move.l    -4(A6),A0
00000F70  52AE FFFC 1680          addq.l    #1,-4(A6)
00000F74  1080      1681          move.b    D0,(A0)
                    1682   ; ByteTotal++;
00000F76  524D      1683          addq.w    #1,A5
00000F78  5282      1684          addq.l    #1,D2
00000F7A  60DC      1685          bra       Load_SRecordFile_18
                    1686   Load_SRecordFile_20:
                    1687   ; }
                    1688   ; // checksum is the 1's complement of the sum of all data pairs following the bytecount, i.e. it includes the address and the data itself
                    1689   ; ReadCheckSum = Get2HexDigits(0) ;
00000F7C  42A7      1690          clr.l     -(A7)
00000F7E  4E93      1691          jsr       (A3)
00000F80  584F      1692          addq.w    #4,A7
00000F82  1D40 FFFB 1693          move.b    D0,-5(A6)
                    1694   ; if((~CheckSum&0Xff) != (ReadCheckSum&0Xff))   {
00000F86  1012      1695          move.b    (A2),D0
00000F88  4600      1696          not.b     D0
00000F8A  4880      1697          ext.w     D0
00000F8C  C07C 00FF 1698          and.w     #255,D0
00000F90  122E FFFB 1699          move.b    -5(A6),D1
00000F94  4881      1700          ext.w     D1
00000F96  C27C 00FF 1701          and.w     #255,D1
00000F9A  B041      1702          cmp.w     D1,D0
00000F9C  6708      1703          beq.s     Load_SRecordFile_21
                    1704   ; LoadFailed = 1 ;
00000F9E  7E01      1705          moveq     #1,D7
                    1706   ; FailedAddress = Address ;
00000FA0  2D44 FFE6 1707          move.l    D4,-26(A6)
                    1708   ; break;
00000FA4  602C      1709          bra.s     Load_SRecordFile_3
                    1710   Load_SRecordFile_21:
                    1711   ; }
                    1712   ; SRecordCount++ ;
00000FA6  52AE FFEE 1713          addq.l    #1,-18(A6)
                    1714   ; // display feedback on progress
                    1715   ; if(SRecordCount % 25 == 0)
00000FAA  2F2E FFEE 1716          move.l    -18(A6),-(A7)
00000FAE  4878 0019 1717          pea       25
00000FB2  4EB9 0000 1718          jsr       LDIV
00000FB6  3A70      
00000FB8  202F 0004 1719          move.l    4(A7),D0
00000FBC  504F      1720          addq.w    #8,A7
00000FBE  4A80      1721          tst.l     D0
00000FC0  660C      1722          bne.s     Load_SRecordFile_23
                    1723   ; putchar('.') ;
00000FC2  4878 002E 1724          pea       46
00000FC6  4EB9 0000 1725          jsr       _putch
00000FCA  3B3C      
00000FCC  584F      1726          addq.w    #4,A7
                    1727   Load_SRecordFile_23:
00000FCE  6000 FEF0 1728          bra       Load_SRecordFile_1
                    1729   Load_SRecordFile_3:
                    1730   ; }
                    1731   ; if(LoadFailed == 1) {
00000FD2  0C87 0000 1732          cmp.l     #1,D7
00000FD6  0001      
00000FD8  6610      1733          bne.s     Load_SRecordFile_25
                    1734   ; printf("\r\nLoad Failed at Address = [$%08X]\r\n", FailedAddress) ;
00000FDA  2F2E FFE6 1735          move.l    -26(A6),-(A7)
00000FDE  4879 0000 1736          pea       @m68kde~1_15.L
00000FE2  4FDC      
00000FE4  4E94      1737          jsr       (A4)
00000FE6  504F      1738          addq.w    #8,A7
00000FE8  600C      1739          bra.s     Load_SRecordFile_26
                    1740   Load_SRecordFile_25:
                    1741   ; }
                    1742   ; else
                    1743   ; printf("\r\nSuccess: Downloaded %d bytes\r\n", ByteTotal) ;
00000FEA  2F0D      1744          move.l    A5,-(A7)
00000FEC  4879 0000 1745          pea       @m68kde~1_16.L
00000FF0  5002      
00000FF2  4E94      1746          jsr       (A4)
00000FF4  504F      1747          addq.w    #8,A7
                    1748   Load_SRecordFile_26:
                    1749   ; // pause at the end to wait for download to finish transmitting at the end of S8 etc
                    1750   ; for(i = 0; i < 400000; i ++)
00000FF6  4282      1751          clr.l     D2
                    1752   Load_SRecordFile_27:
00000FF8  0C82 0006 1753          cmp.l     #400000,D2
00000FFC  1A80      
00000FFE  6C04      1754          bge.s     Load_SRecordFile_29
00001000  5282      1755          addq.l    #1,D2
00001002  60F4      1756          bra       Load_SRecordFile_27
                    1757   Load_SRecordFile_29:
                    1758   ; ;
                    1759   ; FlushKeyboard() ;
00001004  4EB8 0BFC 1760          jsr       _FlushKeyboard
                    1761   ; Echo = 1;
00001008  23FC 0000 1762          move.l    #1,_Echo.L
0000100C  0001 0B00 
00001010  00E0      
                    1763   Load_SRecordFile_8:
00001012  4CDF 3CFC 1764          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
00001016  4E5E      1765          unlk      A6
00001018  4E75      1766          rts
                    1767   ; }
                    1768   ; void MemoryChange(void)
                    1769   ; {
                    1770   _MemoryChange:
0000101A  48E7 3820 1771          movem.l   D2/D3/D4/A2,-(A7)
0000101E  45F9 0000 1772          lea       _printf.L,A2
00001022  3A1C      
                    1773   ; unsigned char *RamPtr,c ; // pointer to memory
                    1774   ; int Data ;
                    1775   ; printf("\r\nExamine and Change Memory") ;
00001024  4879 0000 1776          pea       @m68kde~1_17.L
00001028  5024      
0000102A  4E92      1777          jsr       (A2)
0000102C  584F      1778          addq.w    #4,A7
                    1779   ; printf("\r\n<ESC> to Stop, <SPACE> to Advance, '-' to Go Back, <DATA> to change") ;
0000102E  4879 0000 1780          pea       @m68kde~1_18.L
00001032  5040      
00001034  4E92      1781          jsr       (A2)
00001036  584F      1782          addq.w    #4,A7
                    1783   ; printf("\r\nEnter Address: ") ;
00001038  4879 0000 1784          pea       @m68kde~1_19.L
0000103C  5086      
0000103E  4E92      1785          jsr       (A2)
00001040  584F      1786          addq.w    #4,A7
                    1787   ; RamPtr = Get8HexDigits(0) ;
00001042  42A7      1788          clr.l     -(A7)
00001044  4EB8 0CFA 1789          jsr       _Get8HexDigits
00001048  584F      1790          addq.w    #4,A7
0000104A  2600      1791          move.l    D0,D3
                    1792   ; while(1)    {
                    1793   MemoryChange_1:
                    1794   ; printf("\r\n[%08x] : %02x  ", RamPtr, *RamPtr) ;
0000104C  2043      1795          move.l    D3,A0
0000104E  1210      1796          move.b    (A0),D1
00001050  C2BC 0000 1797          and.l     #255,D1
00001054  00FF      
00001056  2F01      1798          move.l    D1,-(A7)
00001058  2F03      1799          move.l    D3,-(A7)
0000105A  4879 0000 1800          pea       @m68kde~1_20.L
0000105E  5098      
00001060  4E92      1801          jsr       (A2)
00001062  DEFC 000C 1802          add.w     #12,A7
                    1803   ; c = tolower(_getch()) ;
00001066  2F00      1804          move.l    D0,-(A7)
00001068  4EB8 0BBE 1805          jsr       __getch
0000106C  2200      1806          move.l    D0,D1
0000106E  201F      1807          move.l    (A7)+,D0
00001070  2F01      1808          move.l    D1,-(A7)
00001072  4EB9 0000 1809          jsr       _tolower
00001076  3BA8      
00001078  584F      1810          addq.w    #4,A7
0000107A  1400      1811          move.b    D0,D2
                    1812   ; if(c == (char)(0x1b))
0000107C  0C02 001B 1813          cmp.b     #27,D2
00001080  6604      1814          bne.s     MemoryChange_4
                    1815   ; return ;                                // abort on escape
00001082  6000 0090 1816          bra       MemoryChange_6
                    1817   MemoryChange_4:
                    1818   ; else if((c >= '0' && c <= '9') || (c >= 'a' && c <= 'f')) {  // are we trying to change data at this location by entering a hex char
00001086  0C02 0030 1819          cmp.b     #48,D2
0000108A  6506      1820          blo.s     MemoryChange_10
0000108C  0C02 0039 1821          cmp.b     #57,D2
00001090  6310      1822          bls.s     MemoryChange_9
                    1823   MemoryChange_10:
00001092  0C02 0061 1824          cmp.b     #97,D2
00001096  6500 006E 1825          blo       MemoryChange_7
0000109A  0C02 0066 1826          cmp.b     #102,D2
0000109E  6200 0066 1827          bhi       MemoryChange_7
                    1828   MemoryChange_9:
                    1829   ; Data = (xtod(c) << 4) | (xtod(_getch()));
000010A2  C4BC 0000 1830          and.l     #255,D2
000010A6  00FF      
000010A8  2F02      1831          move.l    D2,-(A7)
000010AA  4EB8 0C28 1832          jsr       _xtod
000010AE  584F      1833          addq.w    #4,A7
000010B0  C0BC 0000 1834          and.l     #255,D0
000010B4  00FF      
000010B6  E980      1835          asl.l     #4,D0
000010B8  2F00      1836          move.l    D0,-(A7)
000010BA  2F01      1837          move.l    D1,-(A7)
000010BC  4EB8 0BBE 1838          jsr       __getch
000010C0  221F      1839          move.l    (A7)+,D1
000010C2  2F00      1840          move.l    D0,-(A7)
000010C4  4EB8 0C28 1841          jsr       _xtod
000010C8  584F      1842          addq.w    #4,A7
000010CA  2200      1843          move.l    D0,D1
000010CC  201F      1844          move.l    (A7)+,D0
000010CE  C2BC 0000 1845          and.l     #255,D1
000010D2  00FF      
000010D4  8081      1846          or.l      D1,D0
000010D6  2800      1847          move.l    D0,D4
                    1848   ; *RamPtr = (char)(Data) ;
000010D8  2043      1849          move.l    D3,A0
000010DA  1084      1850          move.b    D4,(A0)
                    1851   ; if(*RamPtr != Data) {
000010DC  2043      1852          move.l    D3,A0
000010DE  1010      1853          move.b    (A0),D0
000010E0  C0BC 0000 1854          and.l     #255,D0
000010E4  00FF      
000010E6  B084      1855          cmp.l     D4,D0
000010E8  671A      1856          beq.s     MemoryChange_11
                    1857   ; printf("\r\nWarning Change Failed: Wrote [%02x], Read [%02x]", Data, *RamPtr) ;
000010EA  2043      1858          move.l    D3,A0
000010EC  1210      1859          move.b    (A0),D1
000010EE  C2BC 0000 1860          and.l     #255,D1
000010F2  00FF      
000010F4  2F01      1861          move.l    D1,-(A7)
000010F6  2F04      1862          move.l    D4,-(A7)
000010F8  4879 0000 1863          pea       @m68kde~1_21.L
000010FC  50AA      
000010FE  4E92      1864          jsr       (A2)
00001100  DEFC 000C 1865          add.w     #12,A7
                    1866   MemoryChange_11:
00001104  6008      1867          bra.s     MemoryChange_13
                    1868   MemoryChange_7:
                    1869   ; }
                    1870   ; }
                    1871   ; else if(c == (char)('-'))
00001106  0C02 002D 1872          cmp.b     #45,D2
0000110A  6602      1873          bne.s     MemoryChange_13
                    1874   ; RamPtr -= 2 ; ;
0000110C  5583      1875          subq.l    #2,D3
                    1876   MemoryChange_13:
                    1877   ; RamPtr ++ ;
0000110E  5283      1878          addq.l    #1,D3
00001110  6000 FF3A 1879          bra       MemoryChange_1
                    1880   MemoryChange_6:
00001114  4CDF 041C 1881          movem.l   (A7)+,D2/D3/D4/A2
00001118  4E75      1882          rts
                    1883   ; }
                    1884   ; }
                    1885   ; /******************************************************************************************
                    1886   ; ** The following code is for the SPI controller
                    1887   ; *******************************************************************************************/
                    1888   ; int SPISafeWrite(unsigned char data) {
                    1889   _SPISafeWrite:
0000111A  4E56 FFFC 1890          link      A6,#-4
                    1891   ; unsigned char returnVal;
                    1892   ; // Wait while Write FIFO is full by checking WFFULL bit
                    1893   ; // while((SPI_Status & 0x08) == 0x08);
                    1894   ; SPI_Data = data;
0000111E  13EE 000B 1895          move.b    11(A6),4227108
00001122  0040 8024 
                    1896   ; WaitForSPITransmitComplete();
00001126  4EB9 0000 1897          jsr       _WaitForSPITransmitComplete
0000112A  1172      
                    1898   ; returnVal = SPI_Data;
0000112C  1D79 0040 1899          move.b    4227108,-1(A6)
00001130  8024 FFFF 
                    1900   ; return returnVal;
00001134  102E FFFF 1901          move.b    -1(A6),D0
00001138  C0BC 0000 1902          and.l     #255,D0
0000113C  00FF      
0000113E  4E5E      1903          unlk      A6
00001140  4E75      1904          rts
                    1905   ; }
                    1906   ; // return true if the SPI has finished transmitting a byte (to say the Flash chip) return false otherwise
                    1907   ; // this can be used in a polling algorithm to know when the controller is busy or idle.
                    1908   ; int TestForSPITransmitDataComplete(void) {
                    1909   _TestForSPITransmitDataComplete:
                    1910   ; /* TODO replace 0 below with a test for status register SPIF bit and if set, return true */
                    1911   ; return (SPI_Status >> 7);
00001142  1039 0040 1912          move.b    4227106,D0
00001146  8022      
00001148  C0BC 0000 1913          and.l     #255,D0
0000114C  00FF      
0000114E  EE88      1914          lsr.l     #7,D0
00001150  4E75      1915          rts
                    1916   ; }
                    1917   ; /************************************************************************************
                    1918   ; ** initialises the SPI controller chip to set speed, interrupt capability etc.
                    1919   ; ************************************************************************************/
                    1920   ; void SPI_Init(void)
                    1921   ; {
                    1922   _SPI_Init:
                    1923   ; // TODO
                    1924   ; // Program the SPI Control, EXT, CS and Status registers to initialise the SPI controller
                    1925   ; // Don't forget to call this routine from main() before you do anything else with SPI
                    1926   ; //
                    1927   ; // Here are some settings we want to create
                    1928   ; //
                    1929   ; // Control Reg - interrupts disabled, core enabled, Master mode, Polarity and Phase of clock = [0,0], speed = divide by 32 (b'11) = approx 700Khz
                    1930   ; // Ext Reg - in conjunction with control reg, sets speed above and also sets interrupt flag after every completed transfer (each byte)
                    1931   ; // SPI_CS Reg - control selection of slave SPI chips via their CS# signals
                    1932   ; // Status Reg - status of SPI controller chip and used to clear any write collision and interrupt on transmit complete flag
                    1933   ; SPI_Control = 0x50; // 0101_0011 // This might need to be 0x53
00001152  13FC 0050 1934          move.b    #80,4227104
00001156  0040 8020 
                    1935   ; SPI_Ext     = 0x0;  // 00_0000_00
0000115A  4239 0040 1936          clr.b     4227110
0000115E  8026      
                    1937   ; SPI_CS      = 0xFF; // 1111_1111 // Set all CS inactive by default. We should set CS active when we want to write/read
00001160  13FC 00FF 1938          move.b    #255,4227112
00001164  0040 8028 
                    1939   ; SPI_Status  = 0xC0; // 1100_0000 // Everything other than bits [7:6] are read only
00001168  13FC 00C0 1940          move.b    #192,4227106
0000116C  0040 8022 
00001170  4E75      1941          rts
                    1942   ; }
                    1943   ; /************************************************************************************
                    1944   ; ** return ONLY when the SPI controller has finished transmitting a byte
                    1945   ; ************************************************************************************/
                    1946   ; void WaitForSPITransmitComplete(void)
                    1947   ; {
                    1948   _WaitForSPITransmitComplete:
                    1949   ; // TODO : poll the status register SPIF bit looking for completion of transmission
                    1950   ; // once transmission is complete, clear the write collision and interrupt on transmit complete flags in the status register (read documentation)
                    1951   ; // just in case they were set
                    1952   ; while (TestForSPITransmitDataComplete() == 0);
                    1953   WaitForSPITransmitComplete_1:
00001172  4EB8 1142 1954          jsr       _TestForSPITransmitDataComplete
00001176  4A80      1955          tst.l     D0
00001178  6602      1956          bne.s     WaitForSPITransmitComplete_3
0000117A  60F6      1957          bra       WaitForSPITransmitComplete_1
                    1958   WaitForSPITransmitComplete_3:
                    1959   ; SPI_Status |= 0xC0;
0000117C  0039 00C0 1960          or.b      #192,4227106
00001180  0040 8022 
00001184  4E75      1961          rts
                    1962   ; }
                    1963   ; // Clear read FIFO by reading from SPI_Data until FIFO is empty
                    1964   ; void ClearSPIReadFIFO(void) {
                    1965   _ClearSPIReadFIFO:
00001186  4E56 FFFC 1966          link      A6,#-4
                    1967   ; volatile unsigned char dummy;
                    1968   ; while((SPI_Status & 0x01) == 0) {
                    1969   ClearSPIReadFIFO_1:
0000118A  1039 0040 1970          move.b    4227106,D0
0000118E  8022      
00001190  C03C 0001 1971          and.b     #1,D0
00001194  660A      1972          bne.s     ClearSPIReadFIFO_3
                    1973   ; dummy = SPI_Data;
00001196  1D79 0040 1974          move.b    4227108,-1(A6)
0000119A  8024 FFFF 
0000119E  60EA      1975          bra       ClearSPIReadFIFO_1
                    1976   ClearSPIReadFIFO_3:
000011A0  4E5E      1977          unlk      A6
000011A2  4E75      1978          rts
                    1979   ; }
                    1980   ; }
                    1981   ; void SPIFlashPollStatusWLE(void) {
                    1982   _SPIFlashPollStatusWLE:
000011A4  4E56 FFFC 1983          link      A6,#-4
                    1984   ; unsigned char status;
                    1985   ; unsigned char dummy;
                    1986   ; do {
                    1987   SPIFlashPollStatusWLE_1:
                    1988   ; // Start a new read status register command each time
                    1989   ; SPI_CS = 0xFE;
000011A8  13FC 00FE 1990          move.b    #254,4227112
000011AC  0040 8028 
                    1991   ; SPISafeWrite(0x05);  // Send Read Status Register command
000011B0  4878 0005 1992          pea       5
000011B4  4EB8 111A 1993          jsr       _SPISafeWrite
000011B8  584F      1994          addq.w    #4,A7
                    1995   ; status = SPISafeWrite(0xFF);  // Dummy write to clock in data
000011BA  4878 00FF 1996          pea       255
000011BE  4EB8 111A 1997          jsr       _SPISafeWrite
000011C2  584F      1998          addq.w    #4,A7
000011C4  1D40 FFFE 1999          move.b    D0,-2(A6)
                    2000   ; SPI_CS = 0xFF;           
000011C8  13FC 00FF 2001          move.b    #255,4227112
000011CC  0040 8028 
000011D0  102E FFFE 2002          move.b    -2(A6),D0
000011D4  C03C 0002 2003          and.b     #2,D0
000011D8  67CE      2004          beq       SPIFlashPollStatusWLE_1
000011DA  4E5E      2005          unlk      A6
000011DC  4E75      2006          rts
                    2007   ; // printf("\r\n WLE Status: %02x \n", status);
                    2008   ; } while ((status & 0x02) == 0);  // Continue polling until WEL bit (bit 1) is set and BUSY is not active
                    2009   ; }
                    2010   ; void SPIFlashPollStatusBusy(void) {
                    2011   _SPIFlashPollStatusBusy:
000011DE  4E56 FFFC 2012          link      A6,#-4
                    2013   ; unsigned char status;
                    2014   ; unsigned char dummy;
                    2015   ; do {
                    2016   SPIFlashPollStatusBusy_1:
                    2017   ; // Start a new read status register command each time
                    2018   ; SPI_CS = 0xFE;
000011E2  13FC 00FE 2019          move.b    #254,4227112
000011E6  0040 8028 
                    2020   ; SPISafeWrite(0x05);  // Send Read Status Register command
000011EA  4878 0005 2021          pea       5
000011EE  4EB8 111A 2022          jsr       _SPISafeWrite
000011F2  584F      2023          addq.w    #4,A7
                    2024   ; status = SPISafeWrite(0xFF);  // Dummy write to clock in data
000011F4  4878 00FF 2025          pea       255
000011F8  4EB8 111A 2026          jsr       _SPISafeWrite
000011FC  584F      2027          addq.w    #4,A7
000011FE  1D40 FFFE 2028          move.b    D0,-2(A6)
                    2029   ; SPI_CS = 0xFF;
00001202  13FC 00FF 2030          move.b    #255,4227112
00001206  0040 8028 
0000120A  102E FFFE 2031          move.b    -2(A6),D0
0000120E  C03C 0001 2032          and.b     #1,D0
00001212  66CE      2033          bne       SPIFlashPollStatusBusy_1
00001214  4E5E      2034          unlk      A6
00001216  4E75      2035          rts
                    2036   ; // printf("\r\n Busy Status: %02x \n", status);
                    2037   ; } while (status & 0x01);  // Continue polling until BUSY bit (bit 0) is cleared
                    2038   ; }
                    2039   ; /************************************************************************************
                    2040   ; ** Write a byte to the SPI flash chip via the controller and returns (reads) whatever was
                    2041   ; ** given back by SPI device at the same time (removes the read byte from the FIFO)
                    2042   ; ************************************************************************************/
                    2043   ; int WriteSPIChar(int c)
                    2044   ; {
                    2045   _WriteSPIChar:
00001218  4E56 0000 2046          link      A6,#0
                    2047   ; SPISafeWrite((unsigned char)c);
0000121C  222E 0008 2048          move.l    8(A6),D1
00001220  C2BC 0000 2049          and.l     #255,D1
00001224  00FF      
00001226  2F01      2050          move.l    D1,-(A7)
00001228  4EB8 111A 2051          jsr       _SPISafeWrite
0000122C  584F      2052          addq.w    #4,A7
                    2053   ; return SPI_Data;
0000122E  1039 0040 2054          move.b    4227108,D0
00001232  8024      
00001234  C0BC 0000 2055          and.l     #255,D0
00001238  00FF      
0000123A  4E5E      2056          unlk      A6
0000123C  4E75      2057          rts
                    2058   ; }
                    2059   ; void SPIFlashWriteEnable() {
                    2060   _SPIFlashWriteEnable:
                    2061   ; SPI_CS = 0xFE;
0000123E  13FC 00FE 2062          move.b    #254,4227112
00001242  0040 8028 
                    2063   ; SPISafeWrite(0x06);
00001246  4878 0006 2064          pea       6
0000124A  4EB8 111A 2065          jsr       _SPISafeWrite
0000124E  584F      2066          addq.w    #4,A7
                    2067   ; SPI_CS = 0xFF;
00001250  13FC 00FF 2068          move.b    #255,4227112
00001254  0040 8028 
                    2069   ; // Read and Poll for the write enable latch (WEL) to wait until we finished write enable to exit this isntruction
                    2070   ; SPIFlashPollStatusWLE();
00001258  4EB8 11A4 2071          jsr       _SPIFlashPollStatusWLE
0000125C  4E75      2072          rts
                    2073   ; }
                    2074   ; void SPISendAddress(int c) {
                    2075   _SPISendAddress:
0000125E  4E56 0000 2076          link      A6,#0
00001262  48E7 2020 2077          movem.l   D2/A2,-(A7)
00001266  242E 0008 2078          move.l    8(A6),D2
0000126A  45F8 111A 2079          lea       _SPISafeWrite.L,A2
                    2080   ; SPISafeWrite((c >> 16) & 0xFF);     // First byte
0000126E  2202      2081          move.l    D2,D1
00001270  E081      2082          asr.l     #8,D1
00001272  E081      2083          asr.l     #8,D1
00001274  C2BC 0000 2084          and.l     #255,D1
00001278  00FF      
0000127A  C2BC 0000 2085          and.l     #255,D1
0000127E  00FF      
00001280  2F01      2086          move.l    D1,-(A7)
00001282  4E92      2087          jsr       (A2)
00001284  584F      2088          addq.w    #4,A7
                    2089   ; SPISafeWrite((c >> 8) & 0xFF);      // second byte
00001286  2202      2090          move.l    D2,D1
00001288  E081      2091          asr.l     #8,D1
0000128A  C2BC 0000 2092          and.l     #255,D1
0000128E  00FF      
00001290  C2BC 0000 2093          and.l     #255,D1
00001294  00FF      
00001296  2F01      2094          move.l    D1,-(A7)
00001298  4E92      2095          jsr       (A2)
0000129A  584F      2096          addq.w    #4,A7
                    2097   ; SPISafeWrite(c & 0xFF);             // third byte
0000129C  2202      2098          move.l    D2,D1
0000129E  C2BC 0000 2099          and.l     #255,D1
000012A2  00FF      
000012A4  C2BC 0000 2100          and.l     #255,D1
000012A8  00FF      
000012AA  2F01      2101          move.l    D1,-(A7)
000012AC  4E92      2102          jsr       (A2)
000012AE  584F      2103          addq.w    #4,A7
000012B0  4CDF 0404 2104          movem.l   (A7)+,D2/A2
000012B4  4E5E      2105          unlk      A6
000012B6  4E75      2106          rts
                    2107   ; }
                    2108   ; void SPIFlashPageProgram(int addr) {
                    2109   _SPIFlashPageProgram:
000012B8  4E56 FFF8 2110          link      A6,#-8
000012BC  2F02      2111          move.l    D2,-(A7)
                    2112   ; unsigned char *sramMemoryPtr;
                    2113   ; int flashAddr = addr - 0x08000000;
000012BE  202E 0008 2114          move.l    8(A6),D0
000012C2  0480 0800 2115          sub.l     #134217728,D0
000012C6  0000      
000012C8  2D40 FFFC 2116          move.l    D0,-4(A6)
                    2117   ; int i;
                    2118   ; SPI_CS = 0xFE;
000012CC  13FC 00FE 2119          move.b    #254,4227112
000012D0  0040 8028 
                    2120   ; SPISafeWrite(0x02); // Write command so that we wait for write FIFO to not be full before giving a byte
000012D4  4878 0002 2121          pea       2
000012D8  4EB8 111A 2122          jsr       _SPISafeWrite
000012DC  584F      2123          addq.w    #4,A7
                    2124   ; SPISendAddress(flashAddr);
000012DE  2F2E FFFC 2125          move.l    -4(A6),-(A7)
000012E2  4EB8 125E 2126          jsr       _SPISendAddress
000012E6  584F      2127          addq.w    #4,A7
                    2128   ; for (i = 0; i < 256; i++) {
000012E8  4282      2129          clr.l     D2
                    2130   SPIFlashPageProgram_1:
000012EA  0C82 0000 2131          cmp.l     #256,D2
000012EE  0100      
000012F0  6C22      2132          bge.s     SPIFlashPageProgram_3
                    2133   ; sramMemoryPtr = (unsigned char*) (addr + i);
000012F2  202E 0008 2134          move.l    8(A6),D0
000012F6  D082      2135          add.l     D2,D0
000012F8  2D40 FFF8 2136          move.l    D0,-8(A6)
                    2137   ; WriteSPIChar(*sramMemoryPtr); // Random value for testing purposes
000012FC  206E FFF8 2138          move.l    -8(A6),A0
00001300  1210      2139          move.b    (A0),D1
00001302  C2BC 0000 2140          and.l     #255,D1
00001306  00FF      
00001308  2F01      2141          move.l    D1,-(A7)
0000130A  4EB8 1218 2142          jsr       _WriteSPIChar
0000130E  584F      2143          addq.w    #4,A7
00001310  5282      2144          addq.l    #1,D2
00001312  60D6      2145          bra       SPIFlashPageProgram_1
                    2146   SPIFlashPageProgram_3:
                    2147   ; // printf("%02x ", *sramMemoryPtr);
                    2148   ; }
                    2149   ; SPI_CS = 0xFF;
00001314  13FC 00FF 2150          move.b    #255,4227112
00001318  0040 8028 
                    2151   ; // Poll the status register to see when the flash write is finished before exiting this command fully
                    2152   ; SPIFlashPollStatusBusy();
0000131C  4EB8 11DE 2153          jsr       _SPIFlashPollStatusBusy
00001320  241F      2154          move.l    (A7)+,D2
00001322  4E5E      2155          unlk      A6
00001324  4E75      2156          rts
                    2157   ; }
                    2158   ; void SPIFlashErase(void) {
                    2159   _SPIFlashErase:
                    2160   ; // TODO: Give a parameter for the sector to erase instead of hardcode
                    2161   ; printf("\nErasing...\n");
00001326  4879 0000 2162          pea       @m68kde~1_22.L
0000132A  50DE      
0000132C  4EB9 0000 2163          jsr       _printf
00001330  3A1C      
00001332  584F      2164          addq.w    #4,A7
                    2165   ; SPI_CS = 0xFE;
00001334  13FC 00FE 2166          move.b    #254,4227112
00001338  0040 8028 
                    2167   ; SPISafeWrite(0xC7);
0000133C  4878 00C7 2168          pea       199
00001340  4EB8 111A 2169          jsr       _SPISafeWrite
00001344  584F      2170          addq.w    #4,A7
                    2171   ; SPI_CS = 0xFF;
00001346  13FC 00FF 2172          move.b    #255,4227112
0000134A  0040 8028 
                    2173   ; SPIFlashPollStatusBusy();
0000134E  4EB8 11DE 2174          jsr       _SPIFlashPollStatusBusy
00001352  4E75      2175          rts
                    2176   ; }
                    2177   ; int SPIFlashRead() {
                    2178   _SPIFlashRead:
00001354  4E56 FFFC 2179          link      A6,#-4
00001358  48E7 3000 2180          movem.l   D2/D3,-(A7)
                    2181   ; unsigned char readData;
                    2182   ; unsigned char *sramMemoryPtr;
                    2183   ; int addr;
                    2184   ; ClearSPIReadFIFO();
0000135C  4EB8 1186 2185          jsr       _ClearSPIReadFIFO
                    2186   ; SPI_CS = 0xFE;
00001360  13FC 00FE 2187          move.b    #254,4227112
00001364  0040 8028 
                    2188   ; SPISafeWrite(0x03);
00001368  4878 0003 2189          pea       3
0000136C  4EB8 111A 2190          jsr       _SPISafeWrite
00001370  584F      2191          addq.w    #4,A7
                    2192   ; SPISendAddress(0x0);
00001372  42A7      2193          clr.l     -(A7)
00001374  4EB8 125E 2194          jsr       _SPISendAddress
00001378  584F      2195          addq.w    #4,A7
                    2196   ; for (addr = 0x08000000; addr < (0x08040000); addr ++) {
0000137A  243C 0800 2197          move.l    #134217728,D2
0000137E  0000      
                    2198   SPIFlashRead_1:
00001380  0C82 0804 2199          cmp.l     #134479872,D2
00001384  0000      
00001386  6C1A      2200          bge.s     SPIFlashRead_3
                    2201   ; sramMemoryPtr = (unsigned char*) addr;
00001388  2D42 FFFC 2202          move.l    D2,-4(A6)
                    2203   ; readData = SPISafeWrite(0xFF); // Dummy byte (1 dummy byte == 1 byte read)
0000138C  4878 00FF 2204          pea       255
00001390  4EB8 111A 2205          jsr       _SPISafeWrite
00001394  584F      2206          addq.w    #4,A7
00001396  1600      2207          move.b    D0,D3
                    2208   ; *sramMemoryPtr = readData;
00001398  206E FFFC 2209          move.l    -4(A6),A0
0000139C  1083      2210          move.b    D3,(A0)
0000139E  5282      2211          addq.l    #1,D2
000013A0  60DE      2212          bra       SPIFlashRead_1
                    2213   SPIFlashRead_3:
                    2214   ; }
                    2215   ; SPI_CS = 0xFF;
000013A2  13FC 00FF 2216          move.b    #255,4227112
000013A6  0040 8028 
                    2217   ; SPIFlashPollStatusBusy();
000013AA  4EB8 11DE 2218          jsr       _SPIFlashPollStatusBusy
                    2219   ; return readData;
000013AE  C6BC 0000 2220          and.l     #255,D3
000013B2  00FF      
000013B4  2003      2221          move.l    D3,D0
000013B6  4CDF 000C 2222          movem.l   (A7)+,D2/D3
000013BA  4E5E      2223          unlk      A6
000013BC  4E75      2224          rts
                    2225   ; }
                    2226   ; /*******************************************************************
                    2227   ; ** Write a program to SPI Flash Chip from memory and verify by reading back
                    2228   ; ********************************************************************/
                    2229   ; void ProgramFlashChip(void)
                    2230   ; {
                    2231   _ProgramFlashChip:
000013BE  4E56 FFFC 2232          link      A6,#-4
                    2233   ; int addr;
                    2234   ; SPIFlashPollStatusBusy();
000013C2  4EB8 11DE 2235          jsr       _SPIFlashPollStatusBusy
                    2236   ; SPIFlashWriteEnable();
000013C6  4EB8 123E 2237          jsr       _SPIFlashWriteEnable
                    2238   ; SPIFlashErase();
000013CA  4EB8 1326 2239          jsr       _SPIFlashErase
                    2240   ; // 256KB = 262144 bytes (0x40000)
                    2241   ; // We need to write one page at a time (256 bytes at a time)
                    2242   ; // This code writes the user program from DRAM to FLASH
                    2243   ; // printf("\r\n Starting Programming...");
                    2244   ; // for (addr = 0x08000000; addr < (0x08040000); addr += 256) {
                    2245   ; //     SPIFlashWriteEnable(); 
                    2246   ; //     // printf("\r\n Addr: %08x \n", addr);
                    2247   ; //     SPIFlashPageProgram(addr);
                    2248   ; // }
                    2249   ; printf("\r\n Programming Complete!");
000013CE  4879 0000 2250          pea       @m68kde~1_23.L
000013D2  50EC      
000013D4  4EB9 0000 2251          jsr       _printf
000013D8  3A1C      
000013DA  584F      2252          addq.w    #4,A7
000013DC  4E5E      2253          unlk      A6
000013DE  4E75      2254          rts
                    2255   ; }
                    2256   ; /*************************************************************************
                    2257   ; ** Load a program from SPI Flash Chip and copy to Dram
                    2258   ; **************************************************************************/
                    2259   ; void LoadFromFlashChip(void)
                    2260   ; {
                    2261   _LoadFromFlashChip:
000013E0  4E56 FFFC 2262          link      A6,#-4
                    2263   ; int readData;
                    2264   ; printf("\r\n Loading Program From SPI Flash....") ;
000013E4  4879 0000 2265          pea       @m68kde~1_24.L
000013E8  5106      
000013EA  4EB9 0000 2266          jsr       _printf
000013EE  3A1C      
000013F0  584F      2267          addq.w    #4,A7
                    2268   ; SPIFlashPollStatusBusy();
000013F2  4EB8 11DE 2269          jsr       _SPIFlashPollStatusBusy
                    2270   ; readData = SPIFlashRead();
000013F6  4EB8 1354 2271          jsr       _SPIFlashRead
000013FA  2D40 FFFC 2272          move.l    D0,-4(A6)
                    2273   ; printf("\r\n Read Data: %08x \n", readData);
000013FE  2F2E FFFC 2274          move.l    -4(A6),-(A7)
00001402  4879 0000 2275          pea       @m68kde~1_25.L
00001406  512C      
00001408  4EB9 0000 2276          jsr       _printf
0000140C  3A1C      
0000140E  504F      2277          addq.w    #8,A7
00001410  4E5E      2278          unlk      A6
00001412  4E75      2279          rts
                    2280   ; }
                    2281   ; void printBinary(unsigned char value) {
                    2282   _printBinary:
00001414  4E56 0000 2283          link      A6,#0
00001418  48E7 2020 2284          movem.l   D2/A2,-(A7)
0000141C  45F9 0000 2285          lea       _printf.L,A2
00001420  3A1C      
                    2286   ; int i;
                    2287   ; printf("IIC_CRSR Transmit (Binary): ");
00001422  4879 0000 2288          pea       @m68kde~1_26.L
00001426  5142      
00001428  4E92      2289          jsr       (A2)
0000142A  584F      2290          addq.w    #4,A7
                    2291   ; for (i = 7; i >= 0; i--) { // Loop through each bit (from MSB to LSB)
0000142C  7407      2292          moveq     #7,D2
                    2293   printBinary_1:
0000142E  0C82 0000 2294          cmp.l     #0,D2
00001432  0000      
00001434  6D22      2295          blt.s     printBinary_3
                    2296   ; printf("%d", (value >> i) & 1); // Shift and mask to extract each bit
00001436  122E 000B 2297          move.b    11(A6),D1
0000143A  C2BC 0000 2298          and.l     #255,D1
0000143E  00FF      
00001440  E4A1      2299          asr.l     D2,D1
00001442  C2BC 0000 2300          and.l     #1,D1
00001446  0001      
00001448  2F01      2301          move.l    D1,-(A7)
0000144A  4879 0000 2302          pea       @m68kde~1_27.L
0000144E  5160      
00001450  4E92      2303          jsr       (A2)
00001452  504F      2304          addq.w    #8,A7
00001454  5382      2305          subq.l    #1,D2
00001456  60D6      2306          bra       printBinary_1
                    2307   printBinary_3:
                    2308   ; }
                    2309   ; printf("\n");
00001458  4879 0000 2310          pea       @m68kde~1_28.L
0000145C  5164      
0000145E  4E92      2311          jsr       (A2)
00001460  584F      2312          addq.w    #4,A7
00001462  4CDF 0404 2313          movem.l   (A7)+,D2/A2
00001466  4E5E      2314          unlk      A6
00001468  4E75      2315          rts
                    2316   ; }
                    2317   ; void IICCoreEnable() {
                    2318   _IICCoreEnable:
                    2319   ; IIC_CTR |= 0x80;     // Enable I2C core in control register (1000_0000)
0000146A  0039 0080 2320          or.b      #128,4227076
0000146E  0040 8004 
00001472  4E75      2321          rts
                    2322   ; }
                    2323   ; void IICCoreDisable() {
                    2324   _IICCoreDisable:
                    2325   ; IIC_CTR &= 0x7F;    // Disable I2C core in control register (0011_1111)
00001474  0239 007F 2326          and.b     #127,4227076
00001478  0040 8004 
0000147C  4E75      2327          rts
                    2328   ; }
                    2329   ; // I2C Driver Functions
                    2330   ; void IIC_Init(void) {
                    2331   _IIC_Init:
                    2332   ; IIC_PRER_LO = 0x59;  // Scale the I2C clock from 45 Mhz to 100 Khz
0000147E  13FC 0059 2333          move.b    #89,4227072
00001482  0040 8000 
                    2334   ; IIC_PRER_HI = 0x00;  // Scale the I2C clock from 45 Mhz to 100 Khz
00001486  4239 0040 2335          clr.b     4227074
0000148A  8002      
                    2336   ; IIC_CTR &= 0xBF;     // Disable interrupt in control register (1011_1111)
0000148C  0239 00BF 2337          and.b     #191,4227076
00001490  0040 8004 
                    2338   ; IICCoreEnable();
00001494  4EB8 146A 2339          jsr       _IICCoreEnable
00001498  4E75      2340          rts
                    2341   ; }
                    2342   ; void wait5ms(void) {
                    2343   _wait5ms:
0000149A  2F02      2344          move.l    D2,-(A7)
                    2345   ; int i;
                    2346   ; for (i = 0; i < 10000; i++); // Wait for 5 ms
0000149C  4282      2347          clr.l     D2
                    2348   wait5ms_1:
0000149E  0C82 0000 2349          cmp.l     #10000,D2
000014A2  2710      
000014A4  6C04      2350          bge.s     wait5ms_3
000014A6  5282      2351          addq.l    #1,D2
000014A8  60F4      2352          bra       wait5ms_1
                    2353   wait5ms_3:
000014AA  241F      2354          move.l    (A7)+,D2
000014AC  4E75      2355          rts
                    2356   ; }
                    2357   ; void checkTIP() {
                    2358   _checkTIP:
                    2359   ; while (IIC_CRSR & TIP);
                    2360   checkTIP_1:
000014AE  1039 0040 2361          move.b    4227080,D0
000014B2  8008      
000014B4  C03C 0002 2362          and.b     #2,D0
000014B8  6702      2363          beq.s     checkTIP_3
000014BA  60F2      2364          bra       checkTIP_1
                    2365   checkTIP_3:
000014BC  4E75      2366          rts
                    2367   ; }
                    2368   ; void checkAck() {
                    2369   _checkAck:
                    2370   ; while ((IIC_CRSR & RXACK) == 1);
                    2371   checkAck_1:
000014BE  1039 0040 2372          move.b    4227080,D0
000014C2  8008      
000014C4  C07C 00FF 2373          and.w     #255,D0
000014C8  C07C 0080 2374          and.w     #128,D0
000014CC  0C40 0001 2375          cmp.w     #1,D0
000014D0  6602      2376          bne.s     checkAck_3
000014D2  60EA      2377          bra       checkAck_1
                    2378   checkAck_3:
000014D4  4E75      2379          rts
                    2380   ; }
                    2381   ; void IICStopCondition() {
                    2382   _IICStopCondition:
                    2383   ; IIC_CRSR |= STOP | READ | IACK; // STOP + READ + IACK
000014D6  0039 0061 2384          or.b      #97,4227080
000014DA  0040 8008 
                    2385   ; checkTIP();
000014DE  4EB8 14AE 2386          jsr       _checkTIP
000014E2  4E75      2387          rts
                    2388   ; }
                    2389   ; void IICStartCondition(int rwBit) {
                    2390   _IICStartCondition:
000014E4  4E56 0000 2391          link      A6,#0
                    2392   ; if (rwBit == 0) {
000014E8  202E 0008 2393          move.l    8(A6),D0
000014EC  660A      2394          bne.s     IICStartCondition_1
                    2395   ; IIC_CRSR |= START | WRITE | IACK; // START + WRITE + IACK
000014EE  0039 0091 2396          or.b      #145,4227080
000014F2  0040 8008 
000014F6  6008      2397          bra.s     IICStartCondition_2
                    2398   IICStartCondition_1:
                    2399   ; } else {
                    2400   ; IIC_CRSR |= START | READ | IACK; // Start condition with read bit set
000014F8  0039 00A1 2401          or.b      #161,4227080
000014FC  0040 8008 
                    2402   IICStartCondition_2:
                    2403   ; }
                    2404   ; checkTIP();
00001500  4EB8 14AE 2405          jsr       _checkTIP
                    2406   ; checkAck();
00001504  4EB8 14BE 2407          jsr       _checkAck
00001508  4E5E      2408          unlk      A6
0000150A  4E75      2409          rts
                    2410   ; }
                    2411   ; // EEPROM Address: 101000{B0} 
                    2412   ; // EEPROM Specific Functions
                    2413   ; void EEPROMByteWrite(unsigned int data, unsigned int deviceAddr, unsigned int memoryAddr) {
                    2414   _EEPROMByteWrite:
0000150C  4E56 0000 2415          link      A6,#0
00001510  48E7 3030 2416          movem.l   D2/D3/A2/A3,-(A7)
00001514  45F8 14AE 2417          lea       _checkTIP.L,A2
00001518  47F8 14BE 2418          lea       _checkAck.L,A3
0000151C  242E 000C 2419          move.l    12(A6),D2
00001520  262E 0010 2420          move.l    16(A6),D3
                    2421   ; // Check if there is a transmission in progress
                    2422   ; // IICCoreEnable();
                    2423   ; if (memoryAddr < 0x10000) {
00001524  0C83 0001 2424          cmp.l     #65536,D3
00001528  0000      
0000152A  6404      2425          bhs.s     EEPROMByteWrite_1
                    2426   ; deviceAddr = EEPROM0;
0000152C  7450      2427          moveq     #80,D2
0000152E  6002      2428          bra.s     EEPROMByteWrite_2
                    2429   EEPROMByteWrite_1:
                    2430   ; } else {
                    2431   ; deviceAddr = EEPROM1;
00001530  7451      2432          moveq     #81,D2
                    2433   EEPROMByteWrite_2:
                    2434   ; }
                    2435   ; checkTIP();
00001532  4E92      2436          jsr       (A2)
                    2437   ; // Set the start condition
                    2438   ; // IICStartCondition(0);
                    2439   ; // printf("Status Register 1: %x\n", IIC_CRSR);
                    2440   ; // printf("Status Register 1: %x\n", IIC_CRSR);
                    2441   ; // Control code, chip select, and block select (ie: Slave Address) and the R/W bit (== 0) are sent
                    2442   ; IIC_TXRX = ((deviceAddr << 1) & 0xFE);
00001534  2002      2443          move.l    D2,D0
00001536  E388      2444          lsl.l     #1,D0
00001538  C0BC 0000 2445          and.l     #254,D0
0000153C  00FE      
0000153E  13C0 0040 2446          move.b    D0,4227078
00001542  8006      
                    2447   ; IIC_CRSR = START | WRITE | IACK;
00001544  13FC 0091 2448          move.b    #145,4227080
00001548  0040 8008 
                    2449   ; // printf("Sent Slave Address: %02x\n", (deviceAddr << 1) & 0xFE);
                    2450   ; checkTIP();
0000154C  4E92      2451          jsr       (A2)
                    2452   ; checkAck();
0000154E  4E93      2453          jsr       (A3)
                    2454   ; // printf("Status Register 2: %x\n", IIC_CRSR);
                    2455   ; // Check for ACK
                    2456   ; // printf("\r\n Slave Address Ack Status: : %d\n", checkAck()); //TIP is checked in checkAck function
                    2457   ; // Send the high-order byte of the address
                    2458   ; IIC_TXRX = (memoryAddr >> 8) & 0xFF;
00001550  2003      2459          move.l    D3,D0
00001552  E088      2460          lsr.l     #8,D0
00001554  C0BC 0000 2461          and.l     #255,D0
00001558  00FF      
0000155A  13C0 0040 2462          move.b    D0,4227078
0000155E  8006      
                    2463   ; IIC_CRSR = WRITE | IACK;
00001560  13FC 0011 2464          move.b    #17,4227080
00001564  0040 8008 
                    2465   ; checkTIP();
00001568  4E92      2466          jsr       (A2)
                    2467   ; checkAck();
0000156A  4E93      2468          jsr       (A3)
                    2469   ; // printf("Sent Upper Memory Byte: %02x\n", memoryAddr >> 8);
                    2470   ; // Send the lower-order byte of the address
                    2471   ; IIC_TXRX = (memoryAddr & 0xFF);
0000156C  2003      2472          move.l    D3,D0
0000156E  C0BC 0000 2473          and.l     #255,D0
00001572  00FF      
00001574  13C0 0040 2474          move.b    D0,4227078
00001578  8006      
                    2475   ; IIC_CRSR = WRITE | IACK;
0000157A  13FC 0011 2476          move.b    #17,4227080
0000157E  0040 8008 
                    2477   ; checkTIP();
00001582  4E92      2478          jsr       (A2)
                    2479   ; checkAck();
00001584  4E93      2480          jsr       (A3)
                    2481   ; //printf("Sent Lower Memory Byte: %02x\n", memoryAddr & 0xFF);
                    2482   ; // printf("Status Register 4: %x\n", IIC_CRSR);
                    2483   ; // Transmit byte to be written
                    2484   ; IIC_TXRX = data;
00001586  202E 0008 2485          move.l    8(A6),D0
0000158A  13C0 0040 2486          move.b    D0,4227078
0000158E  8006      
                    2487   ; IIC_CRSR = STOP | WRITE | IACK;
00001590  13FC 0051 2488          move.b    #81,4227080
00001594  0040 8008 
                    2489   ; checkTIP();
00001598  4E92      2490          jsr       (A2)
                    2491   ; checkAck();
0000159A  4E93      2492          jsr       (A3)
                    2493   ; wait5ms();
0000159C  4EB8 149A 2494          jsr       _wait5ms
000015A0  4CDF 0C0C 2495          movem.l   (A7)+,D2/D3/A2/A3
000015A4  4E5E      2496          unlk      A6
000015A6  4E75      2497          rts
                    2498   ; // printf("Sent Data: %02x\n", data);
                    2499   ; // printf("Sent Stop Condition");
                    2500   ; // printf("Status Register 6: %x\n", IIC_CRSR);
                    2501   ; // IICCoreDisable();
                    2502   ; //printf("\r\nI2C Byte Write Complete\n");
                    2503   ; }
                    2504   ; void EEPROMFlashPageWrite(int* data, unsigned int startingGlobalAddress, unsigned int numBytes, int fullMemory) {
                    2505   _EEPROMFlashPageWrite:
000015A8  4E56 0000 2506          link      A6,#0
000015AC  48E7 3F3C 2507          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
000015B0  282E 000C 2508          move.l    12(A6),D4
000015B4  45F8 14AE 2509          lea       _checkTIP.L,A2
000015B8  47F8 14BE 2510          lea       _checkAck.L,A3
000015BC  2A6E 0010 2511          move.l    16(A6),A5
                    2512   ; unsigned int currentAddress = startingGlobalAddress; 
000015C0  2404      2513          move.l    D4,D2
                    2514   ; unsigned int endAddress = startingGlobalAddress + numBytes;
000015C2  2004      2515          move.l    D4,D0
000015C4  D08D      2516          add.l     A5,D0
000015C6  2C00      2517          move.l    D0,D6
                    2518   ; unsigned int blockAddress;
                    2519   ; unsigned int deviceAddress;
                    2520   ; unsigned int pageFlag;
                    2521   ; unsigned int currIndex = 0;
000015C8  387C 0000 2522          move.w    #0,A4
                    2523   ; startingGlobalAddress = startingGlobalAddress & 0xFFFF; // Mask to 16 bits
000015CC  C8BC 0000 2524          and.l     #65535,D4
000015D0  FFFF      
                    2525   ; currentAddress = startingGlobalAddress; 
000015D2  2404      2526          move.l    D4,D2
                    2527   ; endAddress = startingGlobalAddress + numBytes;
000015D4  2004      2528          move.l    D4,D0
000015D6  D08D      2529          add.l     A5,D0
000015D8  2C00      2530          move.l    D0,D6
                    2531   ; printf("EEPROM Flash Page Write: Start Address: 0x%x, numbytes: %d\n", startingGlobalAddress, numBytes);
000015DA  2F0D      2532          move.l    A5,-(A7)
000015DC  2F04      2533          move.l    D4,-(A7)
000015DE  4879 0000 2534          pea       @m68kde~1_29.L
000015E2  5166      
000015E4  4EB9 0000 2535          jsr       _printf
000015E8  3A1C      
000015EA  DEFC 000C 2536          add.w     #12,A7
                    2537   ; if (currentAddress < 0x10000) {
000015EE  0C82 0001 2538          cmp.l     #65536,D2
000015F2  0000      
000015F4  6406      2539          bhs.s     EEPROMFlashPageWrite_1
                    2540   ; blockAddress = startingGlobalAddress; // Lower 64KB block
000015F6  2604      2541          move.l    D4,D3
                    2542   ; deviceAddress = EEPROM0;
000015F8  7A50      2543          moveq     #80,D5
000015FA  600C      2544          bra.s     EEPROMFlashPageWrite_2
                    2545   EEPROMFlashPageWrite_1:
                    2546   ; } else {
                    2547   ; blockAddress = startingGlobalAddress - 0x10000; // Upper 64KB block
000015FC  2004      2548          move.l    D4,D0
000015FE  0480 0001 2549          sub.l     #65536,D0
00001602  0000      
00001604  2600      2550          move.l    D0,D3
                    2551   ; deviceAddress = EEPROM1;
00001606  7A51      2552          moveq     #81,D5
                    2553   EEPROMFlashPageWrite_2:
                    2554   ; }
                    2555   ; checkTIP();
00001608  4E92      2556          jsr       (A2)
                    2557   ; while (currentAddress < endAddress) {
                    2558   EEPROMFlashPageWrite_3:
0000160A  B486      2559          cmp.l     D6,D2
0000160C  6400 0106 2560          bhs       EEPROMFlashPageWrite_5
                    2561   ; // printf("Entered New Page, Current Address: %d, End Address: %d\n", currentAddress, endAddress);
                    2562   ; if (currentAddress == 0x10000) {
00001610  0C82 0001 2563          cmp.l     #65536,D2
00001614  0000      
00001616  6604      2564          bne.s     EEPROMFlashPageWrite_6
                    2565   ; blockAddress = 0; // Reset to beginning of Block 1
00001618  4283      2566          clr.l     D3
0000161A  6016      2567          bra.s     EEPROMFlashPageWrite_7
                    2568   EEPROMFlashPageWrite_6:
                    2569   ; } 
                    2570   ; else {
                    2571   ; blockAddress = (currentAddress < 0x10000) ? currentAddress : (currentAddress - 0x10000);
0000161C  0C82 0001 2572          cmp.l     #65536,D2
00001620  0000      
00001622  6404      2573          bhs.s     EEPROMFlashPageWrite_8
00001624  2002      2574          move.l    D2,D0
00001626  6008      2575          bra.s     EEPROMFlashPageWrite_9
                    2576   EEPROMFlashPageWrite_8:
00001628  2002      2577          move.l    D2,D0
0000162A  0480 0001 2578          sub.l     #65536,D0
0000162E  0000      
                    2579   EEPROMFlashPageWrite_9:
00001630  2600      2580          move.l    D0,D3
                    2581   EEPROMFlashPageWrite_7:
                    2582   ; }    
                    2583   ; pageFlag = 1;
00001632  7E01      2584          moveq     #1,D7
                    2585   ; // START condition
                    2586   ; IIC_TXRX = (deviceAddress << 1) & 0xFE;    // Upper 64KB block
00001634  2005      2587          move.l    D5,D0
00001636  E388      2588          lsl.l     #1,D0
00001638  C0BC 0000 2589          and.l     #254,D0
0000163C  00FE      
0000163E  13C0 0040 2590          move.b    D0,4227078
00001642  8006      
                    2591   ; IIC_CRSR = START | WRITE | IACK;
00001644  13FC 0091 2592          move.b    #145,4227080
00001648  0040 8008 
                    2593   ; checkTIP();
0000164C  4E92      2594          jsr       (A2)
                    2595   ; checkAck();
0000164E  4E93      2596          jsr       (A3)
                    2597   ; // Send the two address bytes
                    2598   ; // Send the high-order byte of the address
                    2599   ; IIC_TXRX = (blockAddress >> 8) & 0xFF;
00001650  2003      2600          move.l    D3,D0
00001652  E088      2601          lsr.l     #8,D0
00001654  C0BC 0000 2602          and.l     #255,D0
00001658  00FF      
0000165A  13C0 0040 2603          move.b    D0,4227078
0000165E  8006      
                    2604   ; IIC_CRSR = WRITE | IACK;
00001660  13FC 0011 2605          move.b    #17,4227080
00001664  0040 8008 
                    2606   ; checkTIP();
00001668  4E92      2607          jsr       (A2)
                    2608   ; checkAck();
0000166A  4E93      2609          jsr       (A3)
                    2610   ; // printf("Sent Upper Memory Byte: %02x\n", memoryAddr >> 8);
                    2611   ; // Send the lower-order byte of the address
                    2612   ; IIC_TXRX = (blockAddress & 0xFF);
0000166C  2003      2613          move.l    D3,D0
0000166E  C0BC 0000 2614          and.l     #255,D0
00001672  00FF      
00001674  13C0 0040 2615          move.b    D0,4227078
00001678  8006      
                    2616   ; IIC_CRSR = WRITE | IACK;
0000167A  13FC 0011 2617          move.b    #17,4227080
0000167E  0040 8008 
                    2618   ; checkTIP();
00001682  4E92      2619          jsr       (A2)
                    2620   ; checkAck();
00001684  4E93      2621          jsr       (A3)
                    2622   ; while (pageFlag) {
                    2623   EEPROMFlashPageWrite_10:
00001686  4A87      2624          tst.l     D7
00001688  6700 0086 2625          beq       EEPROMFlashPageWrite_12
                    2626   ; if (fullMemory) {        
0000168C  4AAE 0014 2627          tst.l     20(A6)
00001690  670E      2628          beq.s     EEPROMFlashPageWrite_13
                    2629   ; IIC_TXRX = data[0];
00001692  206E 0008 2630          move.l    8(A6),A0
00001696  2010      2631          move.l    (A0),D0
00001698  13C0 0040 2632          move.b    D0,4227078
0000169C  8006      
0000169E  6012      2633          bra.s     EEPROMFlashPageWrite_14
                    2634   EEPROMFlashPageWrite_13:
                    2635   ; } else {
                    2636   ; IIC_TXRX = data[currIndex];
000016A0  206E 0008 2637          move.l    8(A6),A0
000016A4  200C      2638          move.l    A4,D0
000016A6  E588      2639          lsl.l     #2,D0
000016A8  2030 0800 2640          move.l    0(A0,D0.L),D0
000016AC  13C0 0040 2641          move.b    D0,4227078
000016B0  8006      
                    2642   EEPROMFlashPageWrite_14:
                    2643   ; }
                    2644   ; if (currentAddress == 0xFFFF) {
000016B2  0C82 0000 2645          cmp.l     #65535,D2
000016B6  FFFF      
000016B8  6602      2646          bne.s     EEPROMFlashPageWrite_15
                    2647   ; deviceAddress = EEPROM1;  // Switch to next device for next byte
000016BA  7A51      2648          moveq     #81,D5
                    2649   EEPROMFlashPageWrite_15:
                    2650   ; }
                    2651   ; if (blockAddress % 128 == 127 || currentAddress == endAddress - 1 || currentAddress == 0xFFFF) {
000016BC  2F03      2652          move.l    D3,-(A7)
000016BE  4878 0080 2653          pea       128
000016C2  4EB9 0000 2654          jsr       ULDIV
000016C6  3A5E      
000016C8  202F 0004 2655          move.l    4(A7),D0
000016CC  504F      2656          addq.w    #8,A7
000016CE  0C80 0000 2657          cmp.l     #127,D0
000016D2  007F      
000016D4  6710      2658          beq.s     EEPROMFlashPageWrite_19
000016D6  2006      2659          move.l    D6,D0
000016D8  5380      2660          subq.l    #1,D0
000016DA  B480      2661          cmp.l     D0,D2
000016DC  6708      2662          beq.s     EEPROMFlashPageWrite_19
000016DE  0C82 0000 2663          cmp.l     #65535,D2
000016E2  FFFF      
000016E4  6614      2664          bne.s     EEPROMFlashPageWrite_17
                    2665   EEPROMFlashPageWrite_19:
                    2666   ; IIC_CRSR = STOP | WRITE | IACK;
000016E6  13FC 0051 2667          move.b    #81,4227080
000016EA  0040 8008 
                    2668   ; pageFlag = 0;
000016EE  7E00      2669          moveq     #0,D7
                    2670   ; checkTIP();
000016F0  4E92      2671          jsr       (A2)
                    2672   ; checkAck();
000016F2  4E93      2673          jsr       (A3)
                    2674   ; wait5ms();
000016F4  4EB8 149A 2675          jsr       _wait5ms
000016F8  600C      2676          bra.s     EEPROMFlashPageWrite_18
                    2677   EEPROMFlashPageWrite_17:
                    2678   ; } else {
                    2679   ; IIC_CRSR = WRITE | IACK;
000016FA  13FC 0011 2680          move.b    #17,4227080
000016FE  0040 8008 
                    2681   ; checkTIP();
00001702  4E92      2682          jsr       (A2)
                    2683   ; checkAck();
00001704  4E93      2684          jsr       (A3)
                    2685   EEPROMFlashPageWrite_18:
                    2686   ; }
                    2687   ; // ("Current Address: %d, End Address: %d, Block Address: %d\n", currentAddress, endAddress, blockAddress);
                    2688   ; currIndex++;
00001706  524C      2689          addq.w    #1,A4
                    2690   ; currentAddress++;
00001708  5282      2691          addq.l    #1,D2
                    2692   ; blockAddress++;  // Increment blockAddress WITH currentAddress
0000170A  5283      2693          addq.l    #1,D3
0000170C  6000 FF78 2694          bra       EEPROMFlashPageWrite_10
                    2695   EEPROMFlashPageWrite_12:
00001710  6000 FEF8 2696          bra       EEPROMFlashPageWrite_3
                    2697   EEPROMFlashPageWrite_5:
00001714  4CDF 3CFC 2698          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
00001718  4E5E      2699          unlk      A6
0000171A  4E75      2700          rts
                    2701   ; }
                    2702   ; }
                    2703   ; }
                    2704   ; int EEPROMRandomRead(unsigned int deviceAddr, unsigned readAddr) {
                    2705   _EEPROMRandomRead:
0000171C  4E56 FFFC 2706          link      A6,#-4
00001720  48E7 3030 2707          movem.l   D2/D3/A2/A3,-(A7)
00001724  45F8 14AE 2708          lea       _checkTIP.L,A2
00001728  47F8 14BE 2709          lea       _checkAck.L,A3
0000172C  242E 0008 2710          move.l    8(A6),D2
00001730  262E 000C 2711          move.l    12(A6),D3
                    2712   ; unsigned int readData;
                    2713   ; if (readAddr < 0x10000) {
00001734  0C83 0001 2714          cmp.l     #65536,D3
00001738  0000      
0000173A  6404      2715          bhs.s     EEPROMRandomRead_1
                    2716   ; deviceAddr = EEPROM0;
0000173C  7450      2717          moveq     #80,D2
0000173E  6002      2718          bra.s     EEPROMRandomRead_2
                    2719   EEPROMRandomRead_1:
                    2720   ; } else {
                    2721   ; deviceAddr = EEPROM1;
00001740  7451      2722          moveq     #81,D2
                    2723   EEPROMRandomRead_2:
                    2724   ; }
                    2725   ; // Wait for bus to be idle
                    2726   ; // IICCoreEnable(); 
                    2727   ; checkTIP(); 
00001742  4E92      2728          jsr       (A2)
                    2729   ; // Print TXRX register
                    2730   ; // Send start condition for a write
                    2731   ; IIC_TXRX = ((deviceAddr << 1) & 0xFE);
00001744  2002      2732          move.l    D2,D0
00001746  E388      2733          lsl.l     #1,D0
00001748  C0BC 0000 2734          and.l     #254,D0
0000174C  00FE      
0000174E  13C0 0040 2735          move.b    D0,4227078
00001752  8006      
                    2736   ; IIC_CRSR = START | WRITE | IACK;
00001754  13FC 0091 2737          move.b    #145,4227080
00001758  0040 8008 
                    2738   ; checkTIP();
0000175C  4E92      2739          jsr       (A2)
                    2740   ; checkAck();
0000175E  4E93      2741          jsr       (A3)
                    2742   ; //printf("Sending Slave Address: %02x\n", (deviceAddr << 1) & 0xFE);
                    2743   ; // Send the high-order byte of the address
                    2744   ; IIC_TXRX = (readAddr >> 8) & 0xFF;
00001760  2003      2745          move.l    D3,D0
00001762  E088      2746          lsr.l     #8,D0
00001764  C0BC 0000 2747          and.l     #255,D0
00001768  00FF      
0000176A  13C0 0040 2748          move.b    D0,4227078
0000176E  8006      
                    2749   ; IIC_CRSR = WRITE | IACK;
00001770  13FC 0011 2750          move.b    #17,4227080
00001774  0040 8008 
                    2751   ; //printf("Sent Upper Memory Byte: %02x\n", readAddr >> 8);
                    2752   ; checkTIP();
00001778  4E92      2753          jsr       (A2)
                    2754   ; checkAck();
0000177A  4E93      2755          jsr       (A3)
                    2756   ; // Send the low-order byte of the address
                    2757   ; IIC_TXRX = (readAddr & 0xFF);
0000177C  2003      2758          move.l    D3,D0
0000177E  C0BC 0000 2759          and.l     #255,D0
00001782  00FF      
00001784  13C0 0040 2760          move.b    D0,4227078
00001788  8006      
                    2761   ; IIC_CRSR = WRITE | IACK;
0000178A  13FC 0011 2762          move.b    #17,4227080
0000178E  0040 8008 
                    2763   ; //printf("Sent Lower Memory Byte: %02x\n", readAddr & 0xFF);
                    2764   ; checkTIP();
00001792  4E92      2765          jsr       (A2)
                    2766   ; checkAck();
00001794  4E93      2767          jsr       (A3)
                    2768   ; // send START condition again followed by slave address with R/W set to 1
                    2769   ; IIC_TXRX = ((deviceAddr << 1) | 0x01);
00001796  2002      2770          move.l    D2,D0
00001798  E388      2771          lsl.l     #1,D0
0000179A  80BC 0000 2772          or.l      #1,D0
0000179E  0001      
000017A0  13C0 0040 2773          move.b    D0,4227078
000017A4  8006      
                    2774   ; IIC_CRSR = START | WRITE | IACK;
000017A6  13FC 0091 2775          move.b    #145,4227080
000017AA  0040 8008 
                    2776   ; checkTIP();
000017AE  4E92      2777          jsr       (A2)
                    2778   ; checkAck();
000017B0  4E93      2779          jsr       (A3)
                    2780   ; // IICStopCondition();
                    2781   ; IIC_CRSR = STOP | READ | IACK | NACK; // STOP + READ + IACK + NACK
000017B2  13FC 0069 2782          move.b    #105,4227080
000017B6  0040 8008 
                    2783   ; checkTIP();
000017BA  4E92      2784          jsr       (A2)
                    2785   ; // Check if IF flag is sent, and if so read the data
                    2786   ; while (!(IIC_CRSR & 0x1));
                    2787   EEPROMRandomRead_3:
000017BC  1039 0040 2788          move.b    4227080,D0
000017C0  8008      
000017C2  C03C 0001 2789          and.b     #1,D0
000017C6  6602      2790          bne.s     EEPROMRandomRead_5
000017C8  60F2      2791          bra       EEPROMRandomRead_3
                    2792   EEPROMRandomRead_5:
                    2793   ; IIC_CRSR = 0;
000017CA  4239 0040 2794          clr.b     4227080
000017CE  8008      
                    2795   ; readData = IIC_TXRX;
000017D0  1039 0040 2796          move.b    4227078,D0
000017D4  8006      
000017D6  C0BC 0000 2797          and.l     #255,D0
000017DA  00FF      
000017DC  2D40 FFFC 2798          move.l    D0,-4(A6)
                    2799   ; return readData;    
000017E0  202E FFFC 2800          move.l    -4(A6),D0
000017E4  4CDF 0C0C 2801          movem.l   (A7)+,D2/D3/A2/A3
000017E8  4E5E      2802          unlk      A6
000017EA  4E75      2803          rts
                    2804   ; }
                    2805   ; void EEPROMReadBlock0(unsigned int startAddr, int* readLen) {
                    2806   _EEPROMReadBlock0:
000017EC  4E56 FFFC 2807          link      A6,#-4
000017F0  48E7 3C30 2808          movem.l   D2/D3/D4/D5/A2/A3,-(A7)
000017F4  45F8 14AE 2809          lea       _checkTIP.L,A2
000017F8  47F8 14BE 2810          lea       _checkAck.L,A3
000017FC  262E 0008 2811          move.l    8(A6),D3
                    2812   ; unsigned int currAddr;
                    2813   ; unsigned int endAddr;
                    2814   ; unsigned int readData;
                    2815   ; int exitFlag = 0;
00001800  4285      2816          clr.l     D5
                    2817   ; startAddr = startAddr & 0xFFFF; // Mask to 16 bits
00001802  C6BC 0000 2818          and.l     #65535,D3
00001806  FFFF      
                    2819   ; currAddr = startAddr;
00001808  2403      2820          move.l    D3,D2
                    2821   ; endAddr = startAddr + *readLen;
0000180A  2003      2822          move.l    D3,D0
0000180C  206E 000C 2823          move.l    12(A6),A0
00001810  D090      2824          add.l     (A0),D0
00001812  2800      2825          move.l    D0,D4
                    2826   ; //printf("Start Addr: %d\n Curr Addr: %d, Read Len: %d\n", startAddr, currAddr, *readLen);
                    2827   ; checkTIP();
00001814  4E92      2828          jsr       (A2)
                    2829   ; IIC_TXRX = ((EEPROM0 << 1) & 0xFE); // Send EEPROM address with write bit
00001816  13FC 00A0 2830          move.b    #160,4227078
0000181A  0040 8006 
                    2831   ; IIC_CRSR = START | WRITE | IACK; // Start condition with write bit
0000181E  13FC 0091 2832          move.b    #145,4227080
00001822  0040 8008 
                    2833   ; checkTIP();
00001826  4E92      2834          jsr       (A2)
                    2835   ; checkAck(); 
00001828  4E93      2836          jsr       (A3)
                    2837   ; IIC_TXRX = (currAddr >> 8) & 0xFF; // Send high byte of address
0000182A  2002      2838          move.l    D2,D0
0000182C  E088      2839          lsr.l     #8,D0
0000182E  C0BC 0000 2840          and.l     #255,D0
00001832  00FF      
00001834  13C0 0040 2841          move.b    D0,4227078
00001838  8006      
                    2842   ; IIC_CRSR = WRITE | IACK; // Write command
0000183A  13FC 0011 2843          move.b    #17,4227080
0000183E  0040 8008 
                    2844   ; checkTIP();
00001842  4E92      2845          jsr       (A2)
                    2846   ; checkAck();
00001844  4E93      2847          jsr       (A3)
                    2848   ; IIC_TXRX = (currAddr & 0xFF); // Send low byte of address
00001846  2002      2849          move.l    D2,D0
00001848  C0BC 0000 2850          and.l     #255,D0
0000184C  00FF      
0000184E  13C0 0040 2851          move.b    D0,4227078
00001852  8006      
                    2852   ; IIC_CRSR = WRITE | IACK; // Write command
00001854  13FC 0011 2853          move.b    #17,4227080
00001858  0040 8008 
                    2854   ; checkTIP();
0000185C  4E92      2855          jsr       (A2)
                    2856   ; checkAck();
0000185E  4E93      2857          jsr       (A3)
                    2858   ; // Repeated start condition here:
                    2859   ; IIC_TXRX = ((EEPROM0 << 1) | 0x01); // (A3) Send EEPROM address with read bit
00001860  13FC 00A1 2860          move.b    #161,4227078
00001864  0040 8006 
                    2861   ; IIC_CRSR = START | WRITE | IACK; // Start condition with read bit
00001868  13FC 0091 2862          move.b    #145,4227080
0000186C  0040 8008 
                    2863   ; checkTIP();
00001870  4E92      2864          jsr       (A2)
                    2865   ; checkAck();
00001872  4E93      2866          jsr       (A3)
                    2867   ; // Evaluate data here
                    2868   ; for (currAddr = startAddr; currAddr < endAddr; currAddr++) {
00001874  2403      2869          move.l    D3,D2
                    2870   EEPROMReadBlock0_1:
00001876  B484      2871          cmp.l     D4,D2
00001878  6400 009A 2872          bhs       EEPROMReadBlock0_3
                    2873   ; if (currAddr == 0xFFFF || currAddr == endAddr - 1) {
0000187C  0C82 0000 2874          cmp.l     #65535,D2
00001880  FFFF      
00001882  6708      2875          beq.s     EEPROMReadBlock0_6
00001884  2004      2876          move.l    D4,D0
00001886  5380      2877          subq.l    #1,D0
00001888  B480      2878          cmp.l     D0,D2
0000188A  660C      2879          bne.s     EEPROMReadBlock0_4
                    2880   EEPROMReadBlock0_6:
                    2881   ; IIC_CRSR = STOP | READ | IACK | NACK; // Stop condition with read bit
0000188C  13FC 0069 2882          move.b    #105,4227080
00001890  0040 8008 
                    2883   ; exitFlag = 1;
00001894  7A01      2884          moveq     #1,D5
00001896  6008      2885          bra.s     EEPROMReadBlock0_5
                    2886   EEPROMReadBlock0_4:
                    2887   ; } else {
                    2888   ; IIC_CRSR = (READ | IACK) & (~NACK); // Read command
00001898  13FC 0021 2889          move.b    #33,4227080
0000189C  0040 8008 
                    2890   EEPROMReadBlock0_5:
                    2891   ; }
                    2892   ; (*readLen)--;
000018A0  206E 000C 2893          move.l    12(A6),A0
000018A4  5390      2894          subq.l    #1,(A0)
                    2895   ; checkTIP();
000018A6  4E92      2896          jsr       (A2)
                    2897   ; checkAck(); // Check for ACK
000018A8  4E93      2898          jsr       (A3)
                    2899   ; // Read data from EEPROM
                    2900   ; while (!(IIC_CRSR & 0x1)); // Wait for IF flag to be set
                    2901   EEPROMReadBlock0_7:
000018AA  1039 0040 2902          move.b    4227080,D0
000018AE  8008      
000018B0  C03C 0001 2903          and.b     #1,D0
000018B4  6602      2904          bne.s     EEPROMReadBlock0_9
000018B6  60F2      2905          bra       EEPROMReadBlock0_7
                    2906   EEPROMReadBlock0_9:
                    2907   ; IIC_CRSR = 0; // Clear IF flag
000018B8  4239 0040 2908          clr.b     4227080
000018BC  8008      
                    2909   ; readData = IIC_TXRX; // Read data from EEPROM
000018BE  1039 0040 2910          move.b    4227078,D0
000018C2  8006      
000018C4  C0BC 0000 2911          and.l     #255,D0
000018C8  00FF      
000018CA  2D40 FFFC 2912          move.l    D0,-4(A6)
                    2913   ; if ((currAddr % 1000) == 0) {
000018CE  2F02      2914          move.l    D2,-(A7)
000018D0  4878 03E8 2915          pea       1000
000018D4  4EB9 0000 2916          jsr       ULDIV
000018D8  3A5E      
000018DA  202F 0004 2917          move.l    4(A7),D0
000018DE  504F      2918          addq.w    #8,A7
000018E0  4A80      2919          tst.l     D0
000018E2  6616      2920          bne.s     EEPROMReadBlock0_10
                    2921   ; printf("\r\n Block 0 Address: 0x%04X: %d\n", currAddr, readData);
000018E4  2F2E FFFC 2922          move.l    -4(A6),-(A7)
000018E8  2F02      2923          move.l    D2,-(A7)
000018EA  4879 0000 2924          pea       @m68kde~1_30.L
000018EE  51A2      
000018F0  4EB9 0000 2925          jsr       _printf
000018F4  3A1C      
000018F6  DEFC 000C 2926          add.w     #12,A7
                    2927   EEPROMReadBlock0_10:
                    2928   ; }
                    2929   ; if (exitFlag) {
000018FA  4A85      2930          tst.l     D5
000018FC  6710      2931          beq.s     EEPROMReadBlock0_12
                    2932   ; printf("\r\n Exiting EEPROM Read Block 0\n");
000018FE  4879 0000 2933          pea       @m68kde~1_31.L
00001902  51C2      
00001904  4EB9 0000 2934          jsr       _printf
00001908  3A1C      
0000190A  584F      2935          addq.w    #4,A7
                    2936   ; break;
0000190C  6006      2937          bra.s     EEPROMReadBlock0_3
                    2938   EEPROMReadBlock0_12:
0000190E  5282      2939          addq.l    #1,D2
00001910  6000 FF64 2940          bra       EEPROMReadBlock0_1
                    2941   EEPROMReadBlock0_3:
00001914  4CDF 0C3C 2942          movem.l   (A7)+,D2/D3/D4/D5/A2/A3
00001918  4E5E      2943          unlk      A6
0000191A  4E75      2944          rts
                    2945   ; }
                    2946   ; }
                    2947   ; }
                    2948   ; // STILL NEED TO TEST BLOCK 1 MORE AND CROSSING THE BLOCK BOUNDARY
                    2949   ; void EEPROMReadBlock1(int startAddr, int* readLen) {
                    2950   _EEPROMReadBlock1:
0000191C  4E56 FFF8 2951          link      A6,#-8
00001920  48E7 3030 2952          movem.l   D2/D3/A2/A3,-(A7)
00001924  45F8 14AE 2953          lea       _checkTIP.L,A2
00001928  47F8 14BE 2954          lea       _checkAck.L,A3
                    2955   ; unsigned int currAddr = startAddr & 0xFFFF; // Mask to 16 bits
0000192C  202E 0008 2956          move.l    8(A6),D0
00001930  C0BC 0000 2957          and.l     #65535,D0
00001934  FFFF      
00001936  2400      2958          move.l    D0,D2
                    2959   ; unsigned int endAddr = currAddr + *readLen;
00001938  2002      2960          move.l    D2,D0
0000193A  206E 000C 2961          move.l    12(A6),A0
0000193E  D090      2962          add.l     (A0),D0
00001940  2D40 FFF8 2963          move.l    D0,-8(A6)
                    2964   ; unsigned int readData;
                    2965   ; int exitFlag = 0;
00001944  4283      2966          clr.l     D3
                    2967   ; checkTIP();
00001946  4E92      2968          jsr       (A2)
                    2969   ; IIC_TXRX = ((EEPROM1 << 1) & 0xFE); // Send EEPROM address with write bit
00001948  13FC 00A2 2970          move.b    #162,4227078
0000194C  0040 8006 
                    2971   ; IIC_CRSR = START | WRITE | IACK; // Start condition with write bit
00001950  13FC 0091 2972          move.b    #145,4227080
00001954  0040 8008 
                    2973   ; checkTIP();
00001958  4E92      2974          jsr       (A2)
                    2975   ; checkAck(); 
0000195A  4E93      2976          jsr       (A3)
                    2977   ; IIC_TXRX = (currAddr >> 8) & 0xFF; // Send high byte of address
0000195C  2002      2978          move.l    D2,D0
0000195E  E088      2979          lsr.l     #8,D0
00001960  C0BC 0000 2980          and.l     #255,D0
00001964  00FF      
00001966  13C0 0040 2981          move.b    D0,4227078
0000196A  8006      
                    2982   ; IIC_CRSR = WRITE | IACK; // Write command
0000196C  13FC 0011 2983          move.b    #17,4227080
00001970  0040 8008 
                    2984   ; checkTIP();
00001974  4E92      2985          jsr       (A2)
                    2986   ; checkAck();
00001976  4E93      2987          jsr       (A3)
                    2988   ; IIC_TXRX = (currAddr & 0xFF); // Send low byte of address
00001978  2002      2989          move.l    D2,D0
0000197A  C0BC 0000 2990          and.l     #255,D0
0000197E  00FF      
00001980  13C0 0040 2991          move.b    D0,4227078
00001984  8006      
                    2992   ; IIC_CRSR = WRITE | IACK; // Write command
00001986  13FC 0011 2993          move.b    #17,4227080
0000198A  0040 8008 
                    2994   ; checkTIP();
0000198E  4E92      2995          jsr       (A2)
                    2996   ; checkAck();
00001990  4E93      2997          jsr       (A3)
                    2998   ; // Repeated start condition here:
                    2999   ; IIC_TXRX = ((EEPROM1 << 1) | 0x01); // (A3) Send EEPROM address with read bit
00001992  13FC 00A3 3000          move.b    #163,4227078
00001996  0040 8006 
                    3001   ; IIC_CRSR = START | WRITE | IACK; // Start condition with read bit
0000199A  13FC 0091 3002          move.b    #145,4227080
0000199E  0040 8008 
                    3003   ; checkTIP();
000019A2  4E92      3004          jsr       (A2)
                    3005   ; checkAck();
000019A4  4E93      3006          jsr       (A3)
                    3007   ; // Evaluate data here
                    3008   ; for (currAddr = startAddr & 0xFFFF; currAddr < endAddr; currAddr++) {
000019A6  202E 0008 3009          move.l    8(A6),D0
000019AA  C0BC 0000 3010          and.l     #65535,D0
000019AE  FFFF      
000019B0  2400      3011          move.l    D0,D2
                    3012   EEPROMReadBlock1_1:
000019B2  B4AE FFF8 3013          cmp.l     -8(A6),D2
000019B6  6400 009A 3014          bhs       EEPROMReadBlock1_3
                    3015   ; if (currAddr == 0xFFFF) {
000019BA  0C82 0000 3016          cmp.l     #65535,D2
000019BE  FFFF      
000019C0  660C      3017          bne.s     EEPROMReadBlock1_4
                    3018   ; IIC_CRSR = STOP | READ | IACK | NACK; // Stop condition with read bit
000019C2  13FC 0069 3019          move.b    #105,4227080
000019C6  0040 8008 
                    3020   ; exitFlag = 1;
000019CA  7601      3021          moveq     #1,D3
000019CC  6008      3022          bra.s     EEPROMReadBlock1_5
                    3023   EEPROMReadBlock1_4:
                    3024   ; } else {
                    3025   ; IIC_CRSR = (READ | IACK) & (~NACK); // Read command
000019CE  13FC 0021 3026          move.b    #33,4227080
000019D2  0040 8008 
                    3027   EEPROMReadBlock1_5:
                    3028   ; }
                    3029   ; (*readLen)--;
000019D6  206E 000C 3030          move.l    12(A6),A0
000019DA  5390      3031          subq.l    #1,(A0)
                    3032   ; checkTIP();
000019DC  4E92      3033          jsr       (A2)
                    3034   ; checkAck(); // Check for ACK
000019DE  4E93      3035          jsr       (A3)
                    3036   ; // Read data from EEPROM
                    3037   ; while (!IIC_CRSR & 0x1); // Wait for IF flag to be set
                    3038   EEPROMReadBlock1_6:
000019E0  4A39 0040 3039          tst.b     4227080
000019E4  8008      
000019E6  6604      3040          bne.s     EEPROMReadBlock1_9
000019E8  7001      3041          moveq     #1,D0
000019EA  6002      3042          bra.s     EEPROMReadBlock1_10
                    3043   EEPROMReadBlock1_9:
000019EC  4280      3044          clr.l     D0
                    3045   EEPROMReadBlock1_10:
000019EE  C03C 0001 3046          and.b     #1,D0
000019F2  6702      3047          beq.s     EEPROMReadBlock1_8
000019F4  60EA      3048          bra       EEPROMReadBlock1_6
                    3049   EEPROMReadBlock1_8:
                    3050   ; IIC_CRSR = 0; // Clear IF flag
000019F6  4239 0040 3051          clr.b     4227080
000019FA  8008      
                    3052   ; readData = IIC_TXRX; // Read data from EEPROM
000019FC  1039 0040 3053          move.b    4227078,D0
00001A00  8006      
00001A02  C0BC 0000 3054          and.l     #255,D0
00001A06  00FF      
00001A08  2D40 FFFC 3055          move.l    D0,-4(A6)
                    3056   ; if ((currAddr % 1000) == 0) {
00001A0C  2F02      3057          move.l    D2,-(A7)
00001A0E  4878 03E8 3058          pea       1000
00001A12  4EB9 0000 3059          jsr       ULDIV
00001A16  3A5E      
00001A18  202F 0004 3060          move.l    4(A7),D0
00001A1C  504F      3061          addq.w    #8,A7
00001A1E  4A80      3062          tst.l     D0
00001A20  6616      3063          bne.s     EEPROMReadBlock1_11
                    3064   ; printf("\r\n Block 1 Address: 0x%04X: %d\n", currAddr, readData);
00001A22  2F2E FFFC 3065          move.l    -4(A6),-(A7)
00001A26  2F02      3066          move.l    D2,-(A7)
00001A28  4879 0000 3067          pea       @m68kde~1_32.L
00001A2C  51E2      
00001A2E  4EB9 0000 3068          jsr       _printf
00001A32  3A1C      
00001A34  DEFC 000C 3069          add.w     #12,A7
                    3070   EEPROMReadBlock1_11:
                    3071   ; }
                    3072   ; if (exitFlag) {
00001A38  4A83      3073          tst.l     D3
00001A3A  6710      3074          beq.s     EEPROMReadBlock1_13
                    3075   ; printf("\r\n Exiting EEPROM Read Block 1\n");
00001A3C  4879 0000 3076          pea       @m68kde~1_33.L
00001A40  5202      
00001A42  4EB9 0000 3077          jsr       _printf
00001A46  3A1C      
00001A48  584F      3078          addq.w    #4,A7
                    3079   ; break;
00001A4A  6006      3080          bra.s     EEPROMReadBlock1_3
                    3081   EEPROMReadBlock1_13:
00001A4C  5282      3082          addq.l    #1,D2
00001A4E  6000 FF62 3083          bra       EEPROMReadBlock1_1
                    3084   EEPROMReadBlock1_3:
00001A52  4CDF 0C0C 3085          movem.l   (A7)+,D2/D3/A2/A3
00001A56  4E5E      3086          unlk      A6
00001A58  4E75      3087          rts
                    3088   ; }
                    3089   ; }
                    3090   ; }
                    3091   ; int EEPROMSequentialRead(unsigned int startGlobalAddr, int readLen) {
                    3092   _EEPROMSequentialRead:
00001A5A  4E56 0000 3093          link      A6,#0
00001A5E  48E7 2020 3094          movem.l   D2/A2,-(A7)
00001A62  45EE 000C 3095          lea       12(A6),A2
00001A66  242E 0008 3096          move.l    8(A6),D2
                    3097   ; // REMOVE THIS: startGlobalAddr = startGlobalAddr & 0xFFFF;
                    3098   ; if (startGlobalAddr <= 0xFFFF) {
00001A6A  0C82 0000 3099          cmp.l     #65535,D2
00001A6E  FFFF      
00001A70  6220      3100          bhi.s     EEPROMSequentialRead_1
                    3101   ; EEPROMReadBlock0(startGlobalAddr, &readLen);
00001A72  2F0A      3102          move.l    A2,-(A7)
00001A74  2F02      3103          move.l    D2,-(A7)
00001A76  4EB8 17EC 3104          jsr       _EEPROMReadBlock0
00001A7A  504F      3105          addq.w    #8,A7
                    3106   ; if (readLen > 0) {
00001A7C  2012      3107          move.l    (A2),D0
00001A7E  0C80 0000 3108          cmp.l     #0,D0
00001A82  0000      
00001A84  6F0A      3109          ble.s     EEPROMSequentialRead_3
                    3110   ; EEPROMReadBlock1(0, &readLen);
00001A86  2F0A      3111          move.l    A2,-(A7)
00001A88  42A7      3112          clr.l     -(A7)
00001A8A  4EB8 191C 3113          jsr       _EEPROMReadBlock1
00001A8E  504F      3114          addq.w    #8,A7
                    3115   EEPROMSequentialRead_3:
00001A90  6012      3116          bra.s     EEPROMSequentialRead_2
                    3117   EEPROMSequentialRead_1:
                    3118   ; }
                    3119   ; } else {
                    3120   ; EEPROMReadBlock1(startGlobalAddr - 0x10000, &readLen);
00001A92  2F0A      3121          move.l    A2,-(A7)
00001A94  2202      3122          move.l    D2,D1
00001A96  0481 0001 3123          sub.l     #65536,D1
00001A9A  0000      
00001A9C  2F01      3124          move.l    D1,-(A7)
00001A9E  4EB8 191C 3125          jsr       _EEPROMReadBlock1
00001AA2  504F      3126          addq.w    #8,A7
                    3127   EEPROMSequentialRead_2:
00001AA4  4CDF 0404 3128          movem.l   (A7)+,D2/A2
00001AA8  4E5E      3129          unlk      A6
00001AAA  4E75      3130          rts
                    3131   ; }
                    3132   ; }
                    3133   ; // I2CTest() {
                    3134   ; //     unsigned int i, j;
                    3135   ; //     unsigned int readData;
                    3136   ; //     char c, text[150];
                    3137   ; //     unsigned char dataByte;
                    3138   ; //     unsigned int address, size, intBuffer;
                    3139   ; //     unsigned int testChoice = 0;
                    3140   ; //     unsigned char startAddress;
                    3141   ; //     unsigned int dataPattern = 0;
                    3142   ; //     printf("\r\n I2C Test\n");
                    3143   ; //     printf("\r\nInitializing I2C...\n");
                    3144   ; //     IIC_Init();
                    3145   ; //     scanflush();
                    3146   ; //     memset(text, 0, sizeof(text));  // fills with zeros
                    3147   ; //     printf("\r\nChoose option:\n");  // Fixed missing \n
                    3148   ; //     printf("1 Read Single Byte from EEPROM\n");
                    3149   ; //     printf("2 Write Single Byte to EEPROM\n");
                    3150   ; //     printf("3 Read Block of Data from EEPROM\n");
                    3151   ; //     printf("4 Write Block of Data to EEPROM\n");
                    3152   ; //     testChoice = _getch() - 48;    
                    3153   ; //     // Option 1: Read Single Byte
                    3154   ; //     if (testChoice == 1) {
                    3155   ; //         printf("\r\nRead Single Byte\n");
                    3156   ; //         printf("Enter address: 0x");
                    3157   ; //         address = Get8HexDigits(0);
                    3158   ; //         dataByte = EEPROMRandomRead(EEPROM0, address);
                    3159   ; //         printf("Read from address 0x%X: 0x%02X\n", address, dataByte);
                    3160   ; //     }
                    3161   ; //     // Option 2: Write Single Byte
                    3162   ; //     if (testChoice == 2) {
                    3163   ; //         printf("\r\nWrite Single Byte\n"); 
                    3164   ; //         printf("Enter address: 0x");
                    3165   ; //         address = Get8HexDigits(0);
                    3166   ; //         printf("\nEnter which data pattern you want to write into memory\n 0x00 = 0\n 0xB2 = 1\n 0xC3 = 2\n 0xD4 = 3\n");
                    3167   ; //         intBuffer = _getch() - 48;
                    3168   ; //         // scanf("%d", &intBuffer);
                    3169   ; //         switch (intBuffer) {
                    3170   ; //             case(0):
                    3171   ; //                 dataPattern = 0x00; break;
                    3172   ; //             case(1):
                    3173   ; //                 dataPattern = 0xB2; break;
                    3174   ; //             case(2):
                    3175   ; //                 dataPattern = 0xC3; break;
                    3176   ; //             case(3):
                    3177   ; //                 dataPattern = 0xD4; break;
                    3178   ; //         }
                    3179   ; //         dataPattern &= 0xFF;
                    3180   ; //         EEPROMByteWrite(dataPattern, EEPROM0, address);
                    3181   ; //         printf("Wrote 0x%02X to address 0x%X\n", dataPattern, address);
                    3182   ; //         readData = EEPROMRandomRead(EEPROM0, address);
                    3183   ; //         printf("Read back: 0x%02X\n", readData);
                    3184   ; //     }
                    3185   ; //     // Option 3: Read Block of Data
                    3186   ; //     if (testChoice == 3) {
                    3187   ; //         printf("\r\nRead Block of Data\n");
                    3188   ; //         printf("Enter start address (hex): 0x");
                    3189   ; //         startAddress = Get8HexDigits(0);
                    3190   ; //         switch (intBuffer) {
                    3191   ; //             case(0):
                    3192   ; //                 dataPattern = 0x00; break;
                    3193   ; //             case(1):
                    3194   ; //                 dataPattern = 0xB2; break;
                    3195   ; //             case(2):
                    3196   ; //                 dataPattern = 0xC3; break;
                    3197   ; //             case(3):
                    3198   ; //                 dataPattern = 0xD4; break;
                    3199   ; //         }
                    3200   ; //         printf("\nReading %d bytes starting from address 0x%X...\n", numBytes, startAddress);
                    3201   ; //         EEPROMSequentialRead(startAddress, numBytes);
                    3202   ; //     }
                    3203   ; //     // Option 4: Write Block of Data
                    3204   ; //     if (testChoice == 4) {
                    3205   ; //     }
                    3206   ; // Updated I2CTest function with improved EEPROM read and write functionality
                    3207   ; int I2CTest() {
                    3208   _I2CTest:
00001AAC  4E56 FF4C 3209          link      A6,#-180
00001AB0  48E7 3F3C 3210          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
00001AB4  45F9 0000 3211          lea       _printf.L,A2
00001AB8  3A1C      
00001ABA  47F8 0CFA 3212          lea       _Get8HexDigits.L,A3
00001ABE  49F8 1A5A 3213          lea       _EEPROMSequentialRead.L,A4
00001AC2  4BF8 0BBE 3214          lea       __getch.L,A5
                    3215   ; unsigned int i, j;
                    3216   ; unsigned int readData;
                    3217   ; char c, text[150];
                    3218   ; unsigned char dataByte;
                    3219   ; unsigned int address, size, intBuffer;
                    3220   ; unsigned int testChoice = 0;
00001AC6  4285      3221          clr.l     D5
                    3222   ; unsigned int startAddress;
                    3223   ; unsigned int dataPattern = 0;
00001AC8  4282      3224          clr.l     D2
                    3225   ; unsigned int numBytes = 0;
00001ACA  4283      3226          clr.l     D3
                    3227   ; unsigned int totalsize = 0;
00001ACC  42AE FFF8 3228          clr.l     -8(A6)
                    3229   ; int arr[1];
                    3230   ; printf("\r\n I2C Test\n");
00001AD0  4879 0000 3231          pea       @m68kde~1_34.L
00001AD4  5222      
00001AD6  4E92      3232          jsr       (A2)
00001AD8  584F      3233          addq.w    #4,A7
                    3234   ; printf("\r\nInitializing I2C...\n");
00001ADA  4879 0000 3235          pea       @m68kde~1_35.L
00001ADE  5230      
00001AE0  4E92      3236          jsr       (A2)
00001AE2  584F      3237          addq.w    #4,A7
                    3238   ; IIC_Init();
00001AE4  4EB8 147E 3239          jsr       _IIC_Init
                    3240   ; scanflush();
00001AE8  4EB9 0000 3241          jsr       _scanflush
00001AEC  3EEE      
                    3242   ; memset(text, 0, sizeof(text));  // fills with zeros
00001AEE  4878 0096 3243          pea       150
00001AF2  42A7      3244          clr.l     -(A7)
00001AF4  486E FF5C 3245          pea       -164(A6)
00001AF8  4EB9 0000 3246          jsr       _memset
00001AFC  3C08      
00001AFE  DEFC 000C 3247          add.w     #12,A7
                    3248   ; printf("\r\nChoose option:\n");
00001B02  4879 0000 3249          pea       @m68kde~1_36.L
00001B06  5248      
00001B08  4E92      3250          jsr       (A2)
00001B0A  584F      3251          addq.w    #4,A7
                    3252   ; printf("1 Read Single Byte from EEPROM\n");
00001B0C  4879 0000 3253          pea       @m68kde~1_37.L
00001B10  525A      
00001B12  4E92      3254          jsr       (A2)
00001B14  584F      3255          addq.w    #4,A7
                    3256   ; printf("2 Write Single Byte to EEPROM\n");
00001B16  4879 0000 3257          pea       @m68kde~1_38.L
00001B1A  527A      
00001B1C  4E92      3258          jsr       (A2)
00001B1E  584F      3259          addq.w    #4,A7
                    3260   ; printf("3 Read Block of Data from EEPROM\n");
00001B20  4879 0000 3261          pea       @m68kde~1_39.L
00001B24  529A      
00001B26  4E92      3262          jsr       (A2)
00001B28  584F      3263          addq.w    #4,A7
                    3264   ; printf("4 Write Block of Data to EEPROM\n");
00001B2A  4879 0000 3265          pea       @m68kde~1_40.L
00001B2E  52BC      
00001B30  4E92      3266          jsr       (A2)
00001B32  584F      3267          addq.w    #4,A7
                    3268   ; testChoice = _getch() - 48;    
00001B34  4E95      3269          jsr       (A5)
00001B36  0480 0000 3270          sub.l     #48,D0
00001B3A  0030      
00001B3C  2A00      3271          move.l    D0,D5
                    3272   ; // Option 1: Read Single Byte
                    3273   ; if (testChoice == 1) {
00001B3E  0C85 0000 3274          cmp.l     #1,D5
00001B42  0001      
00001B44  6600 004C 3275          bne       I2CTest_1
                    3276   ; printf("\r\nRead Single Byte\n");
00001B48  4879 0000 3277          pea       @m68kde~1_41.L
00001B4C  52DE      
00001B4E  4E92      3278          jsr       (A2)
00001B50  584F      3279          addq.w    #4,A7
                    3280   ; printf("Enter address (hex): 0x");
00001B52  4879 0000 3281          pea       @m68kde~1_42.L
00001B56  52F2      
00001B58  4E92      3282          jsr       (A2)
00001B5A  584F      3283          addq.w    #4,A7
                    3284   ; address = Get8HexDigits(0);
00001B5C  42A7      3285          clr.l     -(A7)
00001B5E  4E93      3286          jsr       (A3)
00001B60  584F      3287          addq.w    #4,A7
00001B62  2800      3288          move.l    D0,D4
                    3289   ; dataByte = EEPROMRandomRead(EEPROM0, address);
00001B64  2F04      3290          move.l    D4,-(A7)
00001B66  4878 0050 3291          pea       80
00001B6A  4EB8 171C 3292          jsr       _EEPROMRandomRead
00001B6E  504F      3293          addq.w    #8,A7
00001B70  1D40 FFF3 3294          move.b    D0,-13(A6)
                    3295   ; printf("\r\nRead from address 0x%X: 0x%02X\n", address, dataByte);
00001B74  122E FFF3 3296          move.b    -13(A6),D1
00001B78  C2BC 0000 3297          and.l     #255,D1
00001B7C  00FF      
00001B7E  2F01      3298          move.l    D1,-(A7)
00001B80  2F04      3299          move.l    D4,-(A7)
00001B82  4879 0000 3300          pea       @m68kde~1_43.L
00001B86  530A      
00001B88  4E92      3301          jsr       (A2)
00001B8A  DEFC 000C 3302          add.w     #12,A7
00001B8E  6000 0220 3303          bra       I2CTest_17
                    3304   I2CTest_1:
                    3305   ; }
                    3306   ; // Option 2: Write Single Byte
                    3307   ; else if (testChoice == 2) {
00001B92  0C85 0000 3308          cmp.l     #2,D5
00001B96  0002      
00001B98  6600 00DE 3309          bne       I2CTest_3
                    3310   ; printf("\r\nWrite Single Byte\n"); 
00001B9C  4879 0000 3311          pea       @m68kde~1_44.L
00001BA0  532C      
00001BA2  4E92      3312          jsr       (A2)
00001BA4  584F      3313          addq.w    #4,A7
                    3314   ; printf("\r\nEnter address (hex): 0x");
00001BA6  4879 0000 3315          pea       @m68kde~1_45.L
00001BAA  5342      
00001BAC  4E92      3316          jsr       (A2)
00001BAE  584F      3317          addq.w    #4,A7
                    3318   ; address = Get8HexDigits(0);
00001BB0  42A7      3319          clr.l     -(A7)
00001BB2  4E93      3320          jsr       (A3)
00001BB4  584F      3321          addq.w    #4,A7
00001BB6  2800      3322          move.l    D0,D4
                    3323   ; printf("\nEnter which data pattern you want to write into memory:\n");
00001BB8  4879 0000 3324          pea       @m68kde~1_46.L
00001BBC  535C      
00001BBE  4E92      3325          jsr       (A2)
00001BC0  584F      3326          addq.w    #4,A7
                    3327   ; printf(" 0: 0x00\n 1: 0xB2\n 2: 0xC3\n 3: 0xD4\n 4: Custom value\n");
00001BC2  4879 0000 3328          pea       @m68kde~1_47.L
00001BC6  5396      
00001BC8  4E92      3329          jsr       (A2)
00001BCA  584F      3330          addq.w    #4,A7
                    3331   ; intBuffer = _getch() - 48;
00001BCC  4E95      3332          jsr       (A5)
00001BCE  0480 0000 3333          sub.l     #48,D0
00001BD2  0030      
00001BD4  2E00      3334          move.l    D0,D7
                    3335   ; if (intBuffer == 4) {
00001BD6  0C87 0000 3336          cmp.l     #4,D7
00001BDA  0004      
00001BDC  6618      3337          bne.s     I2CTest_5
                    3338   ; printf("Select pattern");
00001BDE  4879 0000 3339          pea       @m68kde~1_48.L
00001BE2  53CC      
00001BE4  4E92      3340          jsr       (A2)
00001BE6  584F      3341          addq.w    #4,A7
                    3342   ; dataPattern = Get2HexDigits(0);
00001BE8  42A7      3343          clr.l     -(A7)
00001BEA  4EB8 0C5A 3344          jsr       _Get2HexDigits
00001BEE  584F      3345          addq.w    #4,A7
00001BF0  2400      3346          move.l    D0,D2
00001BF2  6000 003C 3347          bra       I2CTest_8
                    3348   I2CTest_5:
                    3349   ; } else {
                    3350   ; switch (intBuffer) {
00001BF6  2007      3351          move.l    D7,D0
00001BF8  0C80 0000 3352          cmp.l     #4,D0
00001BFC  0004      
00001BFE  642E      3353          bhs.s     I2CTest_7
00001C00  E380      3354          asl.l     #1,D0
00001C02  303B 0806 3355          move.w    I2CTest_9(PC,D0.L),D0
00001C06  4EFB 0002 3356          jmp       I2CTest_9(PC,D0.W)
                    3357   I2CTest_9:
00001C0A  0008      3358          dc.w      I2CTest_10-I2CTest_9
00001C0C  000C      3359          dc.w      I2CTest_11-I2CTest_9
00001C0E  0014      3360          dc.w      I2CTest_12-I2CTest_9
00001C10  001C      3361          dc.w      I2CTest_13-I2CTest_9
                    3362   I2CTest_10:
                    3363   ; case 0:
                    3364   ; dataPattern = 0x00; break;
00001C12  4282      3365          clr.l     D2
00001C14  601A      3366          bra.s     I2CTest_8
                    3367   I2CTest_11:
                    3368   ; case 1:
                    3369   ; dataPattern = 0xB2; break;
00001C16  243C 0000 3370          move.l    #178,D2
00001C1A  00B2      
00001C1C  6012      3371          bra.s     I2CTest_8
                    3372   I2CTest_12:
                    3373   ; case 2:
                    3374   ; dataPattern = 0xC3; break;
00001C1E  243C 0000 3375          move.l    #195,D2
00001C22  00C3      
00001C24  600A      3376          bra.s     I2CTest_8
                    3377   I2CTest_13:
                    3378   ; case 3:
                    3379   ; dataPattern = 0xD4; break;
00001C26  243C 0000 3380          move.l    #212,D2
00001C2A  00D4      
00001C2C  6002      3381          bra.s     I2CTest_8
                    3382   I2CTest_7:
                    3383   ; default:
                    3384   ; dataPattern = 0x00; break;
00001C2E  4282      3385          clr.l     D2
                    3386   I2CTest_8:
                    3387   ; }
                    3388   ; }
                    3389   ; dataPattern &= 0xFF;
00001C30  C4BC 0000 3390          and.l     #255,D2
00001C34  00FF      
                    3391   ; EEPROMByteWrite(dataPattern, EEPROM0, address);
00001C36  2F04      3392          move.l    D4,-(A7)
00001C38  4878 0050 3393          pea       80
00001C3C  2F02      3394          move.l    D2,-(A7)
00001C3E  4EB8 150C 3395          jsr       _EEPROMByteWrite
00001C42  DEFC 000C 3396          add.w     #12,A7
                    3397   ; printf("Wrote 0x%02X to address 0x%X\n", dataPattern, address);
00001C46  2F04      3398          move.l    D4,-(A7)
00001C48  2F02      3399          move.l    D2,-(A7)
00001C4A  4879 0000 3400          pea       @m68kde~1_49.L
00001C4E  53DC      
00001C50  4E92      3401          jsr       (A2)
00001C52  DEFC 000C 3402          add.w     #12,A7
                    3403   ; readData = EEPROMRandomRead(EEPROM0, address);
00001C56  2F04      3404          move.l    D4,-(A7)
00001C58  4878 0050 3405          pea       80
00001C5C  4EB8 171C 3406          jsr       _EEPROMRandomRead
00001C60  504F      3407          addq.w    #8,A7
00001C62  2D40 FF56 3408          move.l    D0,-170(A6)
                    3409   ; printf("Read back: 0x%02X\n", readData);
00001C66  2F2E FF56 3410          move.l    -170(A6),-(A7)
00001C6A  4879 0000 3411          pea       @m68kde~1_50.L
00001C6E  53FA      
00001C70  4E92      3412          jsr       (A2)
00001C72  504F      3413          addq.w    #8,A7
00001C74  6000 013A 3414          bra       I2CTest_17
                    3415   I2CTest_3:
                    3416   ; }
                    3417   ; // Option 3: Read Block of Data
                    3418   ; else if (testChoice == 3) {
00001C78  0C85 0000 3419          cmp.l     #3,D5
00001C7C  0003      
00001C7E  6600 004E 3420          bne       I2CTest_15
                    3421   ; printf("\r\nRead Block of Data\n");
00001C82  4879 0000 3422          pea       @m68kde~1_51.L
00001C86  540E      
00001C88  4E92      3423          jsr       (A2)
00001C8A  584F      3424          addq.w    #4,A7
                    3425   ; printf("Enter start address (hex): 0x");
00001C8C  4879 0000 3426          pea       @m68kde~1_52.L
00001C90  5424      
00001C92  4E92      3427          jsr       (A2)
00001C94  584F      3428          addq.w    #4,A7
                    3429   ; startAddress = Get8HexDigits(0);
00001C96  42A7      3430          clr.l     -(A7)
00001C98  4E93      3431          jsr       (A3)
00001C9A  584F      3432          addq.w    #4,A7
00001C9C  2C00      3433          move.l    D0,D6
                    3434   ; printf("\r\nEnter number of bytes to read (hex): 0x");
00001C9E  4879 0000 3435          pea       @m68kde~1_53.L
00001CA2  5442      
00001CA4  4E92      3436          jsr       (A2)
00001CA6  584F      3437          addq.w    #4,A7
                    3438   ; numBytes = Get8HexDigits(0);
00001CA8  42A7      3439          clr.l     -(A7)
00001CAA  4E93      3440          jsr       (A3)
00001CAC  584F      3441          addq.w    #4,A7
00001CAE  2600      3442          move.l    D0,D3
                    3443   ; printf("\r\nReading 0x%X (%d) bytes starting from address 0x%X...\n", numBytes, numBytes, startAddress);
00001CB0  2F06      3444          move.l    D6,-(A7)
00001CB2  2F03      3445          move.l    D3,-(A7)
00001CB4  2F03      3446          move.l    D3,-(A7)
00001CB6  4879 0000 3447          pea       @m68kde~1_54.L
00001CBA  546C      
00001CBC  4E92      3448          jsr       (A2)
00001CBE  DEFC 0010 3449          add.w     #16,A7
                    3450   ; EEPROMSequentialRead(startAddress, numBytes);
00001CC2  2F03      3451          move.l    D3,-(A7)
00001CC4  2F06      3452          move.l    D6,-(A7)
00001CC6  4E94      3453          jsr       (A4)
00001CC8  504F      3454          addq.w    #8,A7
00001CCA  6000 00E4 3455          bra       I2CTest_17
                    3456   I2CTest_15:
                    3457   ; }
                    3458   ; // Option 4: Write Block of Data
                    3459   ; else if (testChoice == 4) {
00001CCE  0C85 0000 3460          cmp.l     #4,D5
00001CD2  0004      
00001CD4  6600 00DA 3461          bne       I2CTest_17
                    3462   ; printf("\r\nWrite Block of Data\n");
00001CD8  4879 0000 3463          pea       @m68kde~1_55.L
00001CDC  54A6      
00001CDE  4E92      3464          jsr       (A2)
00001CE0  584F      3465          addq.w    #4,A7
                    3466   ; printf("Enter start address (hex): 0x");
00001CE2  4879 0000 3467          pea       @m68kde~1_52.L
00001CE6  5424      
00001CE8  4E92      3468          jsr       (A2)
00001CEA  584F      3469          addq.w    #4,A7
                    3470   ; startAddress = Get8HexDigits(0);
00001CEC  42A7      3471          clr.l     -(A7)
00001CEE  4E93      3472          jsr       (A3)
00001CF0  584F      3473          addq.w    #4,A7
00001CF2  2C00      3474          move.l    D0,D6
                    3475   ; printf("\r\nEnter number of bytes to write (hex): 0x");
00001CF4  4879 0000 3476          pea       @m68kde~1_56.L
00001CF8  54BE      
00001CFA  4E92      3477          jsr       (A2)
00001CFC  584F      3478          addq.w    #4,A7
                    3479   ; numBytes = Get8HexDigits(0);
00001CFE  42A7      3480          clr.l     -(A7)
00001D00  4E93      3481          jsr       (A3)
00001D02  584F      3482          addq.w    #4,A7
00001D04  2600      3483          move.l    D0,D3
                    3484   ; printf("\r\nEnter which data pattern you want to write into memory:\n");
00001D06  4879 0000 3485          pea       @m68kde~1_57.L
00001D0A  54EA      
00001D0C  4E92      3486          jsr       (A2)
00001D0E  584F      3487          addq.w    #4,A7
                    3488   ; printf(" 0: 0x00\n 1: 0xB2\n 2: 0xC3\n 3: 0xD4\n 4: Incrementing pattern\n");
00001D10  4879 0000 3489          pea       @m68kde~1_58.L
00001D14  5526      
00001D16  4E92      3490          jsr       (A2)
00001D18  584F      3491          addq.w    #4,A7
                    3492   ; intBuffer = _getch() - 48;
00001D1A  4E95      3493          jsr       (A5)
00001D1C  0480 0000 3494          sub.l     #48,D0
00001D20  0030      
00001D22  2E00      3495          move.l    D0,D7
                    3496   ; if (intBuffer == 4) {
00001D24  0C87 0000 3497          cmp.l     #4,D7
00001D28  0004      
00001D2A  6614      3498          bne.s     I2CTest_19
                    3499   ; printf("Selected incrementing pattern (address & 0xFF)\n");
00001D2C  4879 0000 3500          pea       @m68kde~1_59.L
00001D30  5564      
00001D32  4E92      3501          jsr       (A2)
00001D34  584F      3502          addq.w    #4,A7
                    3503   ; dataPattern = 0xFF;  // Special marker for incrementing pattern
00001D36  243C 0000 3504          move.l    #255,D2
00001D3A  00FF      
00001D3C  6000 0048 3505          bra       I2CTest_20
                    3506   I2CTest_19:
                    3507   ; } else {
                    3508   ; switch (intBuffer) {
00001D40  2007      3509          move.l    D7,D0
00001D42  0C80 0000 3510          cmp.l     #4,D0
00001D46  0004      
00001D48  642E      3511          bhs.s     I2CTest_21
00001D4A  E380      3512          asl.l     #1,D0
00001D4C  303B 0806 3513          move.w    I2CTest_23(PC,D0.L),D0
00001D50  4EFB 0002 3514          jmp       I2CTest_23(PC,D0.W)
                    3515   I2CTest_23:
00001D54  0008      3516          dc.w      I2CTest_24-I2CTest_23
00001D56  000C      3517          dc.w      I2CTest_25-I2CTest_23
00001D58  0014      3518          dc.w      I2CTest_26-I2CTest_23
00001D5A  001C      3519          dc.w      I2CTest_27-I2CTest_23
                    3520   I2CTest_24:
                    3521   ; case 0:
                    3522   ; dataPattern = 0x00; break;
00001D5C  4282      3523          clr.l     D2
00001D5E  601A      3524          bra.s     I2CTest_22
                    3525   I2CTest_25:
                    3526   ; case 1:
                    3527   ; dataPattern = 0xB2; break;
00001D60  243C 0000 3528          move.l    #178,D2
00001D64  00B2      
00001D66  6012      3529          bra.s     I2CTest_22
                    3530   I2CTest_26:
                    3531   ; case 2:
                    3532   ; dataPattern = 0xC3; break;
00001D68  243C 0000 3533          move.l    #195,D2
00001D6C  00C3      
00001D6E  600A      3534          bra.s     I2CTest_22
                    3535   I2CTest_27:
                    3536   ; case 3:
                    3537   ; dataPattern = 0xD4; break;
00001D70  243C 0000 3538          move.l    #212,D2
00001D74  00D4      
00001D76  6002      3539          bra.s     I2CTest_22
                    3540   I2CTest_21:
                    3541   ; default:
                    3542   ; dataPattern = 0x00; break;
00001D78  4282      3543          clr.l     D2
                    3544   I2CTest_22:
                    3545   ; }
                    3546   ; printf("Selected pattern: 0x%02X\n", dataPattern);
00001D7A  2F02      3547          move.l    D2,-(A7)
00001D7C  4879 0000 3548          pea       @m68kde~1_60.L
00001D80  5594      
00001D82  4E92      3549          jsr       (A2)
00001D84  504F      3550          addq.w    #8,A7
                    3551   I2CTest_20:
                    3552   ; }
                    3553   ; printf("\r\nPreparing to write 0x%X (%d) bytes of data starting at address 0x%X...\n", numBytes, numBytes, startAddress);
00001D86  2F06      3554          move.l    D6,-(A7)
00001D88  2F03      3555          move.l    D3,-(A7)
00001D8A  2F03      3556          move.l    D3,-(A7)
00001D8C  4879 0000 3557          pea       @m68kde~1_61.L
00001D90  55AE      
00001D92  4E92      3558          jsr       (A2)
00001D94  DEFC 0010 3559          add.w     #16,A7
                    3560   ; arr[0] = dataPattern; // Initialize the first byte of the array
00001D98  2D42 FFFC 3561          move.l    D2,-4+0(A6)
                    3562   ; EEPROMFlashPageWrite(arr, startAddress, numBytes, 1);
00001D9C  4878 0001 3563          pea       1
00001DA0  2F03      3564          move.l    D3,-(A7)
00001DA2  2F06      3565          move.l    D6,-(A7)
00001DA4  486E FFFC 3566          pea       -4(A6)
00001DA8  4EB8 15A8 3567          jsr       _EEPROMFlashPageWrite
00001DAC  DEFC 0010 3568          add.w     #16,A7
                    3569   I2CTest_17:
                    3570   ; }
                    3571   ; if (testChoice == 5) {
00001DB0  0C85 0000 3572          cmp.l     #5,D5
00001DB4  0005      
00001DB6  6600 003E 3573          bne       I2CTest_29
                    3574   ; printf("\r\Printing Entire EEPROM\n");
00001DBA  4879 0000 3575          pea       @m68kde~1_62.L
00001DBE  55F8      
00001DC0  4E92      3576          jsr       (A2)
00001DC2  584F      3577          addq.w    #4,A7
                    3578   ; EEPROMSequentialRead(0x0000, 32768);  // First 32KB
00001DC4  4878 8000 3579          pea       32768
00001DC8  42A7      3580          clr.l     -(A7)
00001DCA  4E94      3581          jsr       (A4)
00001DCC  504F      3582          addq.w    #8,A7
                    3583   ; EEPROMSequentialRead(0x8000, 32768);  // Second 32KB
00001DCE  4878 8000 3584          pea       32768
00001DD2  4878 8000 3585          pea       32768
00001DD6  4E94      3586          jsr       (A4)
00001DD8  504F      3587          addq.w    #8,A7
                    3588   ; EEPROMSequentialRead(0x10000, 32768); // Third 32KB
00001DDA  4878 8000 3589          pea       32768
00001DDE  4879 0001 3590          pea       65536
00001DE2  0000      
00001DE4  4E94      3591          jsr       (A4)
00001DE6  504F      3592          addq.w    #8,A7
                    3593   ; EEPROMSequentialRead(0x18000, 32768); // Fourth 32KB
00001DE8  4878 8000 3594          pea       32768
00001DEC  4879 0001 3595          pea       98304
00001DF0  8000      
00001DF2  4E94      3596          jsr       (A4)
00001DF4  504F      3597          addq.w    #8,A7
                    3598   I2CTest_29:
00001DF6  4CDF 3CFC 3599          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
00001DFA  4E5E      3600          unlk      A6
00001DFC  4E75      3601          rts
                    3602   ; }
                    3603   ; }
                    3604   ; // I2CTest() {
                    3605   ; //   unsigned int arraySize = 512;
                    3606   ; //   unsigned int IICData[512];
                    3607   ; //   unsigned int i;
                    3608   ; //   unsigned int writeData = 0xAB;
                    3609   ; //   unsigned int readData;
                    3610   ; //   unsigned int totalBytes = 0x20000;
                    3611   ; //   for (i = 0; i < arraySize; i++) {
                    3612   ; //     IICData[i] = (i % 50) + 1;
                    3613   ; //     IICData[i] = 0xAA;
                    3614   ; //   } 
                    3615   ; //   printf("\r\n I2C Test\n");
                    3616   ; //   IIC_Init();  
                    3617   ; //   printf("Page Write\n");
                    3618   ; //   EEPROMFlashPageWrite(IICData, 0x0, totalBytes); // Write data to EEPROM
                    3619   ; //   printf("Sequential Read\n");
                    3620   ; //   EEPROMSequentialRead(0x0000, 32768);  // First 32KB
                    3621   ; //   EEPROMSequentialRead(0x8000, 32768);  // Second 32KB
                    3622   ; //   EEPROMSequentialRead(0x10000, 32768); // Third 32KB
                    3623   ; //   EEPROMSequentialRead(0x18000, 32768); // Fourth 32KB
                    3624   ; //   printf("\r\n Starting EEPROM Write: Writing 0x%.2x to address 0x00\n", writeData); // Debug: Indicate the start of EEPROM write
                    3625   ; //   for (i = 0x0; i < 0x5; i++) {
                    3626   ; //     printf("\r\n Writing %d to address %d\n", i * 5, i);
                    3627   ; //     EEPROMByteWrite(i * 5, EEPROM1, i); // Write data to EEPROM
                    3628   ; //   }
                    3629   ; //   printf("\r\nFinished write, Starting EEPROM Read\n");
                    3630   ; //   for (i = 0; i < 5; i++) {
                    3631   ; //     readData = EEPROMRandomRead(EEPROM1, i); // Read data from EEPROM
                    3632   ; //     printf("\r\n Address: %d: %d\n", i, readData); // Debug: Indicate the address being read and the data read
                    3633   ; //   }
                    3634   ; //   // readData = EEPROMRandomRead(EEPROM0, 0x0);
                    3635   ; //   IICCoreDisable();
                    3636   ; // }
                    3637   ; // Initialize and enable I2C controller
                    3638   ; // No interrupts and set clock frequency to 100Khz
                    3639   ; // Connect controller to 25 or 45 Mhz CPU clock
                    3640   ; // Check if device is ready before writing anything over I2C bus ie) TX register has written previous command.
                    3641   ; // Check the status register TIP bit to see when transmission has finished
                    3642   ; // Wait for ACK from slave after each write
                    3643   ; // Transmit a byte to the I2C bus
                    3644   ; // write the data to be transmitted into TX register and then write something to the command register that indiciates that you want to write
                    3645   ; // If you want to generate a start or stop condition, set the STA or STO bits in command register when you write to it,
                    3646   ; // Clear the ACK bit if you want to generate an ACK when reading data back from the slave
                    3647   ; // DAC Functions
                    3648   ; // DAC/ADC Address: 1001001 + R/W
                    3649   ; // Control Byte: Set bit6 on to activate unity gain buffer. lower nibble selects the input channel (For DAC ignored once you enter DAC mode)
                    3650   ; // Calculate sine wave values between 0 and 255 
                    3651   ; // Pseudo code process
                    3652   ; // Init I2C 
                    3653   ; // Control byte sent after the slave address. COnfigure this properly
                    3654   ; // Remaining bits can select input channel mode
                    3655   ; // Generate sine wave
                    3656   ; void ADCRead() {
                    3657   _ADCRead:
00001DFE  4E56 FFFC 3658          link      A6,#-4
00001E02  48E7 0030 3659          movem.l   A2/A3,-(A7)
00001E06  45F9 0B00 3660          lea       _i.L,A2
00001E0A  00C4      
00001E0C  47F8 14AE 3661          lea       _checkTIP.L,A3
                    3662   ; unsigned int readData;
                    3663   ; IIC_Init();
00001E10  4EB8 147E 3664          jsr       _IIC_Init
                    3665   ; checkTIP();
00001E14  4E93      3666          jsr       (A3)
                    3667   ; IIC_TXRX = ((PCF8591 << 1) | 0x1); // Send EEPROM address with read bit
00001E16  13FC 0093 3668          move.b    #147,4227078
00001E1A  0040 8006 
                    3669   ; IIC_CRSR = START | WRITE | IACK; // Start condition with write bit
00001E1E  13FC 0091 3670          move.b    #145,4227080
00001E22  0040 8008 
                    3671   ; checkTIP();
00001E26  4E93      3672          jsr       (A3)
                    3673   ; checkAck();
00001E28  4EB8 14BE 3674          jsr       _checkAck
                    3675   ; // Read data from ADC continously 
                    3676   ; while(1) {  // Loop continuously
                    3677   ADCRead_1:
                    3678   ; for (i = 0; i < NUM_SAMPLES; i++) {
00001E2C  4292      3679          clr.l     (A2)
                    3680   ADCRead_4:
00001E2E  2012      3681          move.l    (A2),D0
00001E30  0C80 0000 3682          cmp.l     #512,D0
00001E34  0200      
00001E36  6400 0056 3683          bhs       ADCRead_6
                    3684   ; // Load the triangle wave sample into the I2C transmit register
                    3685   ; IIC_CRSR = (READ | IACK) & (~NACK);  // Initiate I2C write for the data byte
00001E3A  13FC 0021 3686          move.b    #33,4227080
00001E3E  0040 8008 
                    3687   ; checkTIP();  // Wait until the transmission is complete
00001E42  4E93      3688          jsr       (A3)
                    3689   ; while (!IIC_CRSR & 0x1); // Wait for IF flag to be set
                    3690   ADCRead_7:
00001E44  4A39 0040 3691          tst.b     4227080
00001E48  8008      
00001E4A  6604      3692          bne.s     ADCRead_10
00001E4C  7001      3693          moveq     #1,D0
00001E4E  6002      3694          bra.s     ADCRead_11
                    3695   ADCRead_10:
00001E50  4280      3696          clr.l     D0
                    3697   ADCRead_11:
00001E52  C03C 0001 3698          and.b     #1,D0
00001E56  6702      3699          beq.s     ADCRead_9
00001E58  60EA      3700          bra       ADCRead_7
                    3701   ADCRead_9:
                    3702   ; IIC_CRSR = 0; // Clear IF flag
00001E5A  4239 0040 3703          clr.b     4227080
00001E5E  8008      
                    3704   ; readData = IIC_TXRX; // Read data from EEPROM
00001E60  1039 0040 3705          move.b    4227078,D0
00001E64  8006      
00001E66  C0BC 0000 3706          and.l     #255,D0
00001E6A  00FF      
00001E6C  2D40 FFFC 3707          move.l    D0,-4(A6)
                    3708   ; printf("\r\n ADC Read: %d\n", readData); // Debug: Indicate the address being read and the data read
00001E70  2F2E FFFC 3709          move.l    -4(A6),-(A7)
00001E74  4879 0000 3710          pea       @m68kde~1_63.L
00001E78  5612      
00001E7A  4EB9 0000 3711          jsr       _printf
00001E7E  3A1C      
00001E80  504F      3712          addq.w    #8,A7
                    3713   ; wait5ms(); Wait3ms();
00001E82  4EB8 149A 3714          jsr       _wait5ms
00001E86  4EB8 099C 3715          jsr       _Wait3ms
00001E8A  5292      3716          addq.l    #1,(A2)
00001E8C  60A0      3717          bra       ADCRead_4
                    3718   ADCRead_6:
00001E8E  609C      3719          bra       ADCRead_1
                    3720   ; }
                    3721   ; }
                    3722   ; }
                    3723   ; void DACWave() {
                    3724   _DACWave:
00001E90  4E56 F800 3725          link      A6,#-2048
00001E94  48E7 2038 3726          movem.l   D2/A2/A3/A4,-(A7)
00001E98  45F8 14AE 3727          lea       _checkTIP.L,A2
00001E9C  47F8 14BE 3728          lea       _checkAck.L,A3
00001EA0  49EE F800 3729          lea       -2048(A6),A4
                    3730   ; int triangle_table[NUM_SAMPLES];
                    3731   ; int i;
                    3732   ; // Generate triangle wave samples
                    3733   ; // Ascending part: from 0 to 255
                    3734   ; for(i = 0; i < HALF_SAMPLES; i++) {
00001EA4  4282      3735          clr.l     D2
                    3736   DACWave_1:
00001EA6  0C82 0000 3737          cmp.l     #256,D2
00001EAA  0100      
00001EAC  6C0C      3738          bge.s     DACWave_3
                    3739   ; triangle_table[i] = i;  // 0 to 255
00001EAE  2002      3740          move.l    D2,D0
00001EB0  E588      3741          lsl.l     #2,D0
00001EB2  2982 0800 3742          move.l    D2,0(A4,D0.L)
00001EB6  5282      3743          addq.l    #1,D2
00001EB8  60EC      3744          bra       DACWave_1
                    3745   DACWave_3:
                    3746   ; }
                    3747   ; // Descending part: from 255 back to 0
                    3748   ; for(i = HALF_SAMPLES; i < NUM_SAMPLES; i++) {
00001EBA  243C 0000 3749          move.l    #256,D2
00001EBE  0100      
                    3750   DACWave_4:
00001EC0  0C82 0000 3751          cmp.l     #512,D2
00001EC4  0200      
00001EC6  6C1C      3752          bge.s     DACWave_6
                    3753   ; triangle_table[i] = 255 - (i - HALF_SAMPLES);
00001EC8  303C 00FF 3754          move.w    #255,D0
00001ECC  48C0      3755          ext.l     D0
00001ECE  2202      3756          move.l    D2,D1
00001ED0  0481 0000 3757          sub.l     #256,D1
00001ED4  0100      
00001ED6  9081      3758          sub.l     D1,D0
00001ED8  2202      3759          move.l    D2,D1
00001EDA  E589      3760          lsl.l     #2,D1
00001EDC  2980 1800 3761          move.l    D0,0(A4,D1.L)
00001EE0  5282      3762          addq.l    #1,D2
00001EE2  60DC      3763          bra       DACWave_4
                    3764   DACWave_6:
                    3765   ; }
                    3766   ; IIC_Init();
00001EE4  4EB8 147E 3767          jsr       _IIC_Init
                    3768   ; checkTIP();
00001EE8  4E92      3769          jsr       (A2)
                    3770   ; // START condition with slave address
                    3771   ; IIC_TXRX = ((PCF8591 << 1) & 0xFE); // Send EEPROM address with write bit
00001EEA  13FC 0092 3772          move.b    #146,4227078
00001EEE  0040 8006 
                    3773   ; IIC_CRSR = START | WRITE | IACK; // Start condition with write bit
00001EF2  13FC 0091 3774          move.b    #145,4227080
00001EF6  0040 8008 
                    3775   ; checkTIP();
00001EFA  4E92      3776          jsr       (A2)
                    3777   ; checkAck();
00001EFC  4E93      3778          jsr       (A3)
                    3779   ; // DAC Control Byte: Send 01XX0XXX
                    3780   ; IIC_TXRX = 0x40; // Send EEPROM address with write bit
00001EFE  13FC 0040 3781          move.b    #64,4227078
00001F02  0040 8006 
                    3782   ; IIC_CRSR = WRITE | IACK; // Start condition with write bit
00001F06  13FC 0011 3783          move.b    #17,4227080
00001F0A  0040 8008 
                    3784   ; checkTIP();
00001F0E  4E92      3785          jsr       (A2)
                    3786   ; checkAck();
00001F10  4E93      3787          jsr       (A3)
                    3788   ; // Go up and down from 0 to 255 to create effects
                    3789   ; while(1) {  // Loop continuously
                    3790   DACWave_7:
                    3791   ; for (i = 0; i < NUM_SAMPLES; i++) {
00001F12  4282      3792          clr.l     D2
                    3793   DACWave_10:
00001F14  0C82 0000 3794          cmp.l     #512,D2
00001F18  0200      
00001F1A  6C22      3795          bge.s     DACWave_12
                    3796   ; // Load the triangle wave sample into the I2C transmit register
                    3797   ; IIC_TXRX = triangle_table[i];
00001F1C  2002      3798          move.l    D2,D0
00001F1E  E588      3799          lsl.l     #2,D0
00001F20  2034 0800 3800          move.l    0(A4,D0.L),D0
00001F24  13C0 0040 3801          move.b    D0,4227078
00001F28  8006      
                    3802   ; IIC_CRSR = WRITE | IACK;  // Initiate I2C write for the data byte
00001F2A  13FC 0011 3803          move.b    #17,4227080
00001F2E  0040 8008 
                    3804   ; checkTIP();  // Wait until the transmission is complete
00001F32  4E92      3805          jsr       (A2)
                    3806   ; checkAck();  // Check for acknowledgment from the DAC
00001F34  4E93      3807          jsr       (A3)
                    3808   ; Wait1ms();
00001F36  4EB8 0988 3809          jsr       _Wait1ms
00001F3A  5282      3810          addq.l    #1,D2
00001F3C  60D6      3811          bra       DACWave_10
                    3812   DACWave_12:
00001F3E  60D2      3813          bra       DACWave_7
                    3814   ; }
                    3815   ; }
                    3816   ; }
                    3817   ; //////////////////////////////////////////////////////////////////////////////////////////////////
                    3818   ; // IMPORTANT
                    3819   ; // TG68 does not support the Native Trace mode of the original 68000 so tracing
                    3820   ; // has to be done with an interrupt (IRQ Level 6)
                    3821   ; //
                    3822   ; // To allow the 68000 to execute one more instruction after each pseudo trace (IRQ6)
                    3823   ; // the IRQ is removed in hardware once the TG68 reads the IRQ autovector (i.e. acknowledges the IRQ)
                    3824   ; //
                    3825   ; // on return from the IRQ service handler, the first access to the user memory program space
                    3826   ; // generates a fresh IRQ (in hardware) to generate a new trace, this allows the tg68 to
                    3827   ; // execute one more new instruction (without it the TG68 would trace on the same instruction
                    3828   ; // each time and not after the next one). It also means it doesn't simgle step outside the user
                    3829   ; // program area
                    3830   ; //
                    3831   ; // The bottom line is the Trace handler, which includes the Dump registers below
                    3832   ; // cannot access the user memory to display for example the Instruction Opcode or to disassemble etc
                    3833   ; // as this would lead to a new IRQ being reset and the TG68 would trace on same instruction
                    3834   ; // NOT SURE THIS IS TRUE NOW THAT TRACE HANDLER HAS BEEN MODIVIED TO NOT AUTOMATICALLY GENERATE A TRACE EXCEPTION
                    3835   ; // INSTEAD IT IS DONE IN THE 'N' COMMAND FOR NEXT
                    3836   ; /////////////////////////////////////////////////////////////////////////////////////////////////////
                    3837   ; void DumpRegisters()
                    3838   ; {
                    3839   _DumpRegisters:
00001F40  48E7 3F3C 3840          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
00001F44  45F9 0000 3841          lea       _putch.L,A2
00001F48  3B3C      
00001F4A  47F9 0000 3842          lea       _printf.L,A3
00001F4E  3A1C      
00001F50  49F9 0B00 3843          lea       _SR.L,A4
00001F54  012C      
00001F56  4BF9 0B00 3844          lea       _WatchPointString.L,A5
00001F5A  01C2      
                    3845   ; short i, x, j, k ;
                    3846   ; unsigned char c, *BytePointer;
                    3847   ; // buld up strings for displaying watchpoints
                    3848   ; for(x = 0; x < (short)(8); x++)
00001F5C  4242      3849          clr.w     D2
                    3850   DumpRegisters_1:
00001F5E  0C42 0008 3851          cmp.w     #8,D2
00001F62  6C00 01C6 3852          bge       DumpRegisters_3
                    3853   ; {
                    3854   ; if(WatchPointSetOrCleared[x] == 1)
00001F66  48C2      3855          ext.l     D2
00001F68  2002      3856          move.l    D2,D0
00001F6A  E588      3857          lsl.l     #2,D0
00001F6C  41F9 0B00 3858          lea       _WatchPointSetOrCleared.L,A0
00001F70  01A2      
00001F72  2030 0800 3859          move.l    0(A0,D0.L),D0
00001F76  0C80 0000 3860          cmp.l     #1,D0
00001F7A  0001      
00001F7C  6600 0186 3861          bne       DumpRegisters_4
                    3862   ; {
                    3863   ; sprintf(WatchPointString[x], "$%08X  ", WatchPointAddress[x]) ;
00001F80  48C2      3864          ext.l     D2
00001F82  2202      3865          move.l    D2,D1
00001F84  E589      3866          lsl.l     #2,D1
00001F86  41F9 0B00 3867          lea       _WatchPointAddress.L,A0
00001F8A  0182      
00001F8C  2F30 1800 3868          move.l    0(A0,D1.L),-(A7)
00001F90  4879 0000 3869          pea       @m68kde~1_64.L
00001F94  5624      
00001F96  220D      3870          move.l    A5,D1
00001F98  48C2      3871          ext.l     D2
00001F9A  2F00      3872          move.l    D0,-(A7)
00001F9C  2002      3873          move.l    D2,D0
00001F9E  C1FC 0064 3874          muls      #100,D0
00001FA2  D280      3875          add.l     D0,D1
00001FA4  201F      3876          move.l    (A7)+,D0
00001FA6  2F01      3877          move.l    D1,-(A7)
00001FA8  4EB9 0000 3878          jsr       _sprintf
00001FAC  3BD4      
00001FAE  DEFC 000C 3879          add.w     #12,A7
                    3880   ; BytePointer = (char *)(WatchPointAddress[x]) ;
00001FB2  48C2      3881          ext.l     D2
00001FB4  2002      3882          move.l    D2,D0
00001FB6  E588      3883          lsl.l     #2,D0
00001FB8  41F9 0B00 3884          lea       _WatchPointAddress.L,A0
00001FBC  0182      
00001FBE  2A30 0800 3885          move.l    0(A0,D0.L),D5
                    3886   ; for(j = 0; j < (short)(16); j+=2)
00001FC2  4243      3887          clr.w     D3
                    3888   DumpRegisters_6:
00001FC4  0C43 0010 3889          cmp.w     #16,D3
00001FC8  6C00 0082 3890          bge       DumpRegisters_8
                    3891   ; {
                    3892   ; for(k = 0; k < (short)(2); k++)
00001FCC  4246      3893          clr.w     D6
                    3894   DumpRegisters_9:
00001FCE  0C46 0002 3895          cmp.w     #2,D6
00001FD2  6C00 0052 3896          bge       DumpRegisters_11
                    3897   ; {
                    3898   ; sprintf(TempString, "%02X", BytePointer[j+k]) ;
00001FD6  2045      3899          move.l    D5,A0
00001FD8  48C3      3900          ext.l     D3
00001FDA  2203      3901          move.l    D3,D1
00001FDC  48C6      3902          ext.l     D6
00001FDE  D286      3903          add.l     D6,D1
00001FE0  1230 1800 3904          move.b    0(A0,D1.L),D1
00001FE4  C2BC 0000 3905          and.l     #255,D1
00001FE8  00FF      
00001FEA  2F01      3906          move.l    D1,-(A7)
00001FEC  4879 0000 3907          pea       @m68kde~1_8.L
00001FF0  4F34      
00001FF2  4879 0B00 3908          pea       _TempString.L
00001FF6  04E2      
00001FF8  4EB9 0000 3909          jsr       _sprintf
00001FFC  3BD4      
00001FFE  DEFC 000C 3910          add.w     #12,A7
                    3911   ; strcat(WatchPointString[x], TempString) ;
00002002  4879 0B00 3912          pea       _TempString.L
00002006  04E2      
00002008  220D      3913          move.l    A5,D1
0000200A  48C2      3914          ext.l     D2
0000200C  2F00      3915          move.l    D0,-(A7)
0000200E  2002      3916          move.l    D2,D0
00002010  C1FC 0064 3917          muls      #100,D0
00002014  D280      3918          add.l     D0,D1
00002016  201F      3919          move.l    (A7)+,D0
00002018  2F01      3920          move.l    D1,-(A7)
0000201A  4EB9 0000 3921          jsr       _strcat
0000201E  3C20      
00002020  504F      3922          addq.w    #8,A7
00002022  5246      3923          addq.w    #1,D6
00002024  60A8      3924          bra       DumpRegisters_9
                    3925   DumpRegisters_11:
                    3926   ; }
                    3927   ; strcat(WatchPointString[x]," ") ;
00002026  4879 0000 3928          pea       @m68kde~1_65.L
0000202A  562C      
0000202C  220D      3929          move.l    A5,D1
0000202E  48C2      3930          ext.l     D2
00002030  2F00      3931          move.l    D0,-(A7)
00002032  2002      3932          move.l    D2,D0
00002034  C1FC 0064 3933          muls      #100,D0
00002038  D280      3934          add.l     D0,D1
0000203A  201F      3935          move.l    (A7)+,D0
0000203C  2F01      3936          move.l    D1,-(A7)
0000203E  4EB9 0000 3937          jsr       _strcat
00002042  3C20      
00002044  504F      3938          addq.w    #8,A7
00002046  5443      3939          addq.w    #2,D3
00002048  6000 FF7A 3940          bra       DumpRegisters_6
                    3941   DumpRegisters_8:
                    3942   ; }
                    3943   ; strcat(WatchPointString[x], "  ") ;
0000204C  4879 0000 3944          pea       @m68kde~1_9.L
00002050  4F3A      
00002052  220D      3945          move.l    A5,D1
00002054  48C2      3946          ext.l     D2
00002056  2F00      3947          move.l    D0,-(A7)
00002058  2002      3948          move.l    D2,D0
0000205A  C1FC 0064 3949          muls      #100,D0
0000205E  D280      3950          add.l     D0,D1
00002060  201F      3951          move.l    (A7)+,D0
00002062  2F01      3952          move.l    D1,-(A7)
00002064  4EB9 0000 3953          jsr       _strcat
00002068  3C20      
0000206A  504F      3954          addq.w    #8,A7
                    3955   ; BytePointer = (char *)(WatchPointAddress[x]) ;
0000206C  48C2      3956          ext.l     D2
0000206E  2002      3957          move.l    D2,D0
00002070  E588      3958          lsl.l     #2,D0
00002072  41F9 0B00 3959          lea       _WatchPointAddress.L,A0
00002076  0182      
00002078  2A30 0800 3960          move.l    0(A0,D0.L),D5
                    3961   ; for(j = 0; j < (short)(16); j++)
0000207C  4243      3962          clr.w     D3
                    3963   DumpRegisters_12:
0000207E  0C43 0010 3964          cmp.w     #16,D3
00002082  6C00 007E 3965          bge       DumpRegisters_14
                    3966   ; {
                    3967   ; c = ((char)(BytePointer[j]) & 0x7f) ;
00002086  2045      3968          move.l    D5,A0
00002088  48C3      3969          ext.l     D3
0000208A  1030 3800 3970          move.b    0(A0,D3.L),D0
0000208E  C03C 007F 3971          and.b     #127,D0
00002092  1E00      3972          move.b    D0,D7
                    3973   ; if((c > (char)(0x7f)) || (c < (char)(' ')))
00002094  0C07 007F 3974          cmp.b     #127,D7
00002098  6206      3975          bhi.s     DumpRegisters_17
0000209A  0C07 0020 3976          cmp.b     #32,D7
0000209E  6416      3977          bhs.s     DumpRegisters_15
                    3978   DumpRegisters_17:
                    3979   ; sprintf(TempString, ".") ;
000020A0  4879 0000 3980          pea       @m68kde~1_66.L
000020A4  562E      
000020A6  4879 0B00 3981          pea       _TempString.L
000020AA  04E2      
000020AC  4EB9 0000 3982          jsr       _sprintf
000020B0  3BD4      
000020B2  504F      3983          addq.w    #8,A7
000020B4  6026      3984          bra.s     DumpRegisters_16
                    3985   DumpRegisters_15:
                    3986   ; else
                    3987   ; sprintf(TempString, "%c", BytePointer[j]) ;
000020B6  2045      3988          move.l    D5,A0
000020B8  48C3      3989          ext.l     D3
000020BA  1230 3800 3990          move.b    0(A0,D3.L),D1
000020BE  C2BC 0000 3991          and.l     #255,D1
000020C2  00FF      
000020C4  2F01      3992          move.l    D1,-(A7)
000020C6  4879 0000 3993          pea       @m68kde~1_67.L
000020CA  5630      
000020CC  4879 0B00 3994          pea       _TempString.L
000020D0  04E2      
000020D2  4EB9 0000 3995          jsr       _sprintf
000020D6  3BD4      
000020D8  DEFC 000C 3996          add.w     #12,A7
                    3997   DumpRegisters_16:
                    3998   ; strcat(WatchPointString[x], TempString) ;
000020DC  4879 0B00 3999          pea       _TempString.L
000020E0  04E2      
000020E2  220D      4000          move.l    A5,D1
000020E4  48C2      4001          ext.l     D2
000020E6  2F00      4002          move.l    D0,-(A7)
000020E8  2002      4003          move.l    D2,D0
000020EA  C1FC 0064 4004          muls      #100,D0
000020EE  D280      4005          add.l     D0,D1
000020F0  201F      4006          move.l    (A7)+,D0
000020F2  2F01      4007          move.l    D1,-(A7)
000020F4  4EB9 0000 4008          jsr       _strcat
000020F8  3C20      
000020FA  504F      4009          addq.w    #8,A7
000020FC  5243      4010          addq.w    #1,D3
000020FE  6000 FF7E 4011          bra       DumpRegisters_12
                    4012   DumpRegisters_14:
00002102  6020      4013          bra.s     DumpRegisters_5
                    4014   DumpRegisters_4:
                    4015   ; }
                    4016   ; }
                    4017   ; else
                    4018   ; strcpy(WatchPointString[x], "") ;
00002104  4879 0000 4019          pea       @m68kde~1_68.L
00002108  5634      
0000210A  220D      4020          move.l    A5,D1
0000210C  48C2      4021          ext.l     D2
0000210E  2F00      4022          move.l    D0,-(A7)
00002110  2002      4023          move.l    D2,D0
00002112  C1FC 0064 4024          muls      #100,D0
00002116  D280      4025          add.l     D0,D1
00002118  201F      4026          move.l    (A7)+,D0
0000211A  2F01      4027          move.l    D1,-(A7)
0000211C  4EB9 0000 4028          jsr       _strcpy
00002120  3A4E      
00002122  504F      4029          addq.w    #8,A7
                    4030   DumpRegisters_5:
00002124  5242      4031          addq.w    #1,D2
00002126  6000 FE36 4032          bra       DumpRegisters_1
                    4033   DumpRegisters_3:
                    4034   ; }
                    4035   ; printf("\r\n\r\n D0 = $%08X  A0 = $%08X",d0,a0) ;
0000212A  2F39 0B00 4036          move.l    _a0.L,-(A7)
0000212E  0104      
00002130  2F39 0B00 4037          move.l    _d0.L,-(A7)
00002134  00E4      
00002136  4879 0000 4038          pea       @m68kde~1_69.L
0000213A  5636      
0000213C  4E93      4039          jsr       (A3)
0000213E  DEFC 000C 4040          add.w     #12,A7
                    4041   ; printf("\r\n D1 = $%08X  A1 = $%08X",d1,a1) ;
00002142  2F39 0B00 4042          move.l    _a1.L,-(A7)
00002146  0108      
00002148  2F39 0B00 4043          move.l    _d1.L,-(A7)
0000214C  00E8      
0000214E  4879 0000 4044          pea       @m68kde~1_70.L
00002152  5652      
00002154  4E93      4045          jsr       (A3)
00002156  DEFC 000C 4046          add.w     #12,A7
                    4047   ; printf("\r\n D2 = $%08X  A2 = $%08X",d2,a2) ;
0000215A  2F39 0B00 4048          move.l    _a2.L,-(A7)
0000215E  010C      
00002160  2F39 0B00 4049          move.l    _d2.L,-(A7)
00002164  00EC      
00002166  4879 0000 4050          pea       @m68kde~1_71.L
0000216A  566C      
0000216C  4E93      4051          jsr       (A3)
0000216E  DEFC 000C 4052          add.w     #12,A7
                    4053   ; printf("\r\n D3 = $%08X  A3 = $%08X",d3,a3) ;
00002172  2F39 0B00 4054          move.l    _a3.L,-(A7)
00002176  0110      
00002178  2F39 0B00 4055          move.l    _d3.L,-(A7)
0000217C  00F0      
0000217E  4879 0000 4056          pea       @m68kde~1_72.L
00002182  5686      
00002184  4E93      4057          jsr       (A3)
00002186  DEFC 000C 4058          add.w     #12,A7
                    4059   ; printf("\r\n D4 = $%08X  A4 = $%08X",d4,a4) ;
0000218A  2F39 0B00 4060          move.l    _a4.L,-(A7)
0000218E  0114      
00002190  2F39 0B00 4061          move.l    _d4.L,-(A7)
00002194  00F4      
00002196  4879 0000 4062          pea       @m68kde~1_73.L
0000219A  56A0      
0000219C  4E93      4063          jsr       (A3)
0000219E  DEFC 000C 4064          add.w     #12,A7
                    4065   ; printf("\r\n D5 = $%08X  A5 = $%08X",d5,a5) ;
000021A2  2F39 0B00 4066          move.l    _a5.L,-(A7)
000021A6  0118      
000021A8  2F39 0B00 4067          move.l    _d5.L,-(A7)
000021AC  00F8      
000021AE  4879 0000 4068          pea       @m68kde~1_74.L
000021B2  56BA      
000021B4  4E93      4069          jsr       (A3)
000021B6  DEFC 000C 4070          add.w     #12,A7
                    4071   ; printf("\r\n D6 = $%08X  A6 = $%08X",d6,a6) ;
000021BA  2F39 0B00 4072          move.l    _a6.L,-(A7)
000021BE  011C      
000021C0  2F39 0B00 4073          move.l    _d6.L,-(A7)
000021C4  00FC      
000021C6  4879 0000 4074          pea       @m68kde~1_75.L
000021CA  56D4      
000021CC  4E93      4075          jsr       (A3)
000021CE  DEFC 000C 4076          add.w     #12,A7
                    4077   ; printf("\r\n D7 = $%08X  A7 = $%08X",d7,((SR & (unsigned short int)(0x2000)) == ((unsigned short int)(0x2000))) ? SSP : USP) ;
000021D2  3214      4078          move.w    (A4),D1
000021D4  C27C 2000 4079          and.w     #8192,D1
000021D8  0C41 2000 4080          cmp.w     #8192,D1
000021DC  6608      4081          bne.s     DumpRegisters_18
000021DE  2239 0B00 4082          move.l    _SSP.L,D1
000021E2  0124      
000021E4  6006      4083          bra.s     DumpRegisters_19
                    4084   DumpRegisters_18:
000021E6  2239 0B00 4085          move.l    _USP.L,D1
000021EA  0128      
                    4086   DumpRegisters_19:
000021EC  2F01      4087          move.l    D1,-(A7)
000021EE  2F39 0B00 4088          move.l    _d7.L,-(A7)
000021F2  0100      
000021F4  4879 0000 4089          pea       @m68kde~1_76.L
000021F8  56EE      
000021FA  4E93      4090          jsr       (A3)
000021FC  DEFC 000C 4091          add.w     #12,A7
                    4092   ; printf("\r\n\r\nUSP = $%08X  (A7) User SP", USP ) ;
00002200  2F39 0B00 4093          move.l    _USP.L,-(A7)
00002204  0128      
00002206  4879 0000 4094          pea       @m68kde~1_77.L
0000220A  5708      
0000220C  4E93      4095          jsr       (A3)
0000220E  504F      4096          addq.w    #8,A7
                    4097   ; printf("\r\nSSP = $%08X  (A7) Supervisor SP", SSP) ;
00002210  2F39 0B00 4098          move.l    _SSP.L,-(A7)
00002214  0124      
00002216  4879 0000 4099          pea       @m68kde~1_78.L
0000221A  5726      
0000221C  4E93      4100          jsr       (A3)
0000221E  504F      4101          addq.w    #8,A7
                    4102   ; printf("\r\n SR = $%04X   ",SR) ;
00002220  3214      4103          move.w    (A4),D1
00002222  C2BC 0000 4104          and.l     #65535,D1
00002226  FFFF      
00002228  2F01      4105          move.l    D1,-(A7)
0000222A  4879 0000 4106          pea       @m68kde~1_79.L
0000222E  5748      
00002230  4E93      4107          jsr       (A3)
00002232  504F      4108          addq.w    #8,A7
                    4109   ; // display the status word in characters etc.
                    4110   ; printf("   [") ;
00002234  4879 0000 4111          pea       @m68kde~1_80.L
00002238  575A      
0000223A  4E93      4112          jsr       (A3)
0000223C  584F      4113          addq.w    #4,A7
                    4114   ; if((SR & (unsigned short int)(0x8000)) == (unsigned short int)(0x8000)) putchar('T') ; else putchar('-') ;      // Trace bit(bit 15)
0000223E  3014      4115          move.w    (A4),D0
00002240  C07C 8000 4116          and.w     #32768,D0
00002244  0C40 8000 4117          cmp.w     #32768,D0
00002248  660A      4118          bne.s     DumpRegisters_20
0000224A  4878 0054 4119          pea       84
0000224E  4E92      4120          jsr       (A2)
00002250  584F      4121          addq.w    #4,A7
00002252  6008      4122          bra.s     DumpRegisters_21
                    4123   DumpRegisters_20:
00002254  4878 002D 4124          pea       45
00002258  4E92      4125          jsr       (A2)
0000225A  584F      4126          addq.w    #4,A7
                    4127   DumpRegisters_21:
                    4128   ; if((SR & (unsigned short int)(0x2000)) == (unsigned short int)(0x2000)) putchar('S') ; else putchar('U') ;      // supervisor bit  (bit 13)
0000225C  3014      4129          move.w    (A4),D0
0000225E  C07C 2000 4130          and.w     #8192,D0
00002262  0C40 2000 4131          cmp.w     #8192,D0
00002266  660A      4132          bne.s     DumpRegisters_22
00002268  4878 0053 4133          pea       83
0000226C  4E92      4134          jsr       (A2)
0000226E  584F      4135          addq.w    #4,A7
00002270  6008      4136          bra.s     DumpRegisters_23
                    4137   DumpRegisters_22:
00002272  4878 0055 4138          pea       85
00002276  4E92      4139          jsr       (A2)
00002278  584F      4140          addq.w    #4,A7
                    4141   DumpRegisters_23:
                    4142   ; if((SR & (unsigned short int)(0x0400)) == (unsigned short int)(0x0400)) putchar('1') ; else putchar('0') ;      // IRQ2 Bit (bit 10)
0000227A  3014      4143          move.w    (A4),D0
0000227C  C07C 0400 4144          and.w     #1024,D0
00002280  0C40 0400 4145          cmp.w     #1024,D0
00002284  660A      4146          bne.s     DumpRegisters_24
00002286  4878 0031 4147          pea       49
0000228A  4E92      4148          jsr       (A2)
0000228C  584F      4149          addq.w    #4,A7
0000228E  6008      4150          bra.s     DumpRegisters_25
                    4151   DumpRegisters_24:
00002290  4878 0030 4152          pea       48
00002294  4E92      4153          jsr       (A2)
00002296  584F      4154          addq.w    #4,A7
                    4155   DumpRegisters_25:
                    4156   ; if((SR & (unsigned short int)(0x0200)) == (unsigned short int)(0x0200)) putchar('1') ; else putchar('0') ;      // IRQ1 Bit (bit 9)
00002298  3014      4157          move.w    (A4),D0
0000229A  C07C 0200 4158          and.w     #512,D0
0000229E  0C40 0200 4159          cmp.w     #512,D0
000022A2  660A      4160          bne.s     DumpRegisters_26
000022A4  4878 0031 4161          pea       49
000022A8  4E92      4162          jsr       (A2)
000022AA  584F      4163          addq.w    #4,A7
000022AC  6008      4164          bra.s     DumpRegisters_27
                    4165   DumpRegisters_26:
000022AE  4878 0030 4166          pea       48
000022B2  4E92      4167          jsr       (A2)
000022B4  584F      4168          addq.w    #4,A7
                    4169   DumpRegisters_27:
                    4170   ; if((SR & (unsigned short int)(0x0100)) == (unsigned short int)(0x0100)) putchar('1') ; else putchar('0') ;      // IRQ0 Bit (bit 8)
000022B6  3014      4171          move.w    (A4),D0
000022B8  C07C 0100 4172          and.w     #256,D0
000022BC  0C40 0100 4173          cmp.w     #256,D0
000022C0  660A      4174          bne.s     DumpRegisters_28
000022C2  4878 0031 4175          pea       49
000022C6  4E92      4176          jsr       (A2)
000022C8  584F      4177          addq.w    #4,A7
000022CA  6008      4178          bra.s     DumpRegisters_29
                    4179   DumpRegisters_28:
000022CC  4878 0030 4180          pea       48
000022D0  4E92      4181          jsr       (A2)
000022D2  584F      4182          addq.w    #4,A7
                    4183   DumpRegisters_29:
                    4184   ; if((SR & (unsigned short int)(0x0010)) == (unsigned short int)(0x0010)) putchar('X') ; else putchar('-') ;      // X Bit (bit 4)
000022D4  3014      4185          move.w    (A4),D0
000022D6  C07C 0010 4186          and.w     #16,D0
000022DA  0C40 0010 4187          cmp.w     #16,D0
000022DE  660A      4188          bne.s     DumpRegisters_30
000022E0  4878 0058 4189          pea       88
000022E4  4E92      4190          jsr       (A2)
000022E6  584F      4191          addq.w    #4,A7
000022E8  6008      4192          bra.s     DumpRegisters_31
                    4193   DumpRegisters_30:
000022EA  4878 002D 4194          pea       45
000022EE  4E92      4195          jsr       (A2)
000022F0  584F      4196          addq.w    #4,A7
                    4197   DumpRegisters_31:
                    4198   ; if((SR & (unsigned short int)(0x0008)) == (unsigned short int)(0x0008)) putchar('N') ; else putchar('-') ;      // N Bit (bit 3)
000022F2  3014      4199          move.w    (A4),D0
000022F4  C07C 0008 4200          and.w     #8,D0
000022F8  0C40 0008 4201          cmp.w     #8,D0
000022FC  660A      4202          bne.s     DumpRegisters_32
000022FE  4878 004E 4203          pea       78
00002302  4E92      4204          jsr       (A2)
00002304  584F      4205          addq.w    #4,A7
00002306  6008      4206          bra.s     DumpRegisters_33
                    4207   DumpRegisters_32:
00002308  4878 002D 4208          pea       45
0000230C  4E92      4209          jsr       (A2)
0000230E  584F      4210          addq.w    #4,A7
                    4211   DumpRegisters_33:
                    4212   ; if((SR & (unsigned short int)(0x0004)) == (unsigned short int)(0x0004)) putchar('Z') ; else putchar('-') ;      // Z Bit (bit 2)
00002310  3014      4213          move.w    (A4),D0
00002312  C07C 0004 4214          and.w     #4,D0
00002316  0C40 0004 4215          cmp.w     #4,D0
0000231A  660A      4216          bne.s     DumpRegisters_34
0000231C  4878 005A 4217          pea       90
00002320  4E92      4218          jsr       (A2)
00002322  584F      4219          addq.w    #4,A7
00002324  6008      4220          bra.s     DumpRegisters_35
                    4221   DumpRegisters_34:
00002326  4878 002D 4222          pea       45
0000232A  4E92      4223          jsr       (A2)
0000232C  584F      4224          addq.w    #4,A7
                    4225   DumpRegisters_35:
                    4226   ; if((SR & (unsigned short int)(0x0002)) == (unsigned short int)(0x0002)) putchar('V') ; else putchar('-') ;      // V Bit (bit 1)
0000232E  3014      4227          move.w    (A4),D0
00002330  C07C 0002 4228          and.w     #2,D0
00002334  0C40 0002 4229          cmp.w     #2,D0
00002338  660A      4230          bne.s     DumpRegisters_36
0000233A  4878 0056 4231          pea       86
0000233E  4E92      4232          jsr       (A2)
00002340  584F      4233          addq.w    #4,A7
00002342  6008      4234          bra.s     DumpRegisters_37
                    4235   DumpRegisters_36:
00002344  4878 002D 4236          pea       45
00002348  4E92      4237          jsr       (A2)
0000234A  584F      4238          addq.w    #4,A7
                    4239   DumpRegisters_37:
                    4240   ; if((SR & (unsigned short int)(0x0001)) == (unsigned short int)(0x0001)) putchar('C') ; else putchar('-') ;      // C Bit (bit 0)
0000234C  3014      4241          move.w    (A4),D0
0000234E  C07C 0001 4242          and.w     #1,D0
00002352  0C40 0001 4243          cmp.w     #1,D0
00002356  660A      4244          bne.s     DumpRegisters_38
00002358  4878 0043 4245          pea       67
0000235C  4E92      4246          jsr       (A2)
0000235E  584F      4247          addq.w    #4,A7
00002360  6008      4248          bra.s     DumpRegisters_39
                    4249   DumpRegisters_38:
00002362  4878 002D 4250          pea       45
00002366  4E92      4251          jsr       (A2)
00002368  584F      4252          addq.w    #4,A7
                    4253   DumpRegisters_39:
                    4254   ; putchar(']') ;
0000236A  4878 005D 4255          pea       93
0000236E  4E92      4256          jsr       (A2)
00002370  584F      4257          addq.w    #4,A7
                    4258   ; printf("\r\n PC = $%08X  ", PC) ;
00002372  2F39 0B00 4259          move.l    _PC.L,-(A7)
00002376  0120      
00002378  4879 0000 4260          pea       @m68kde~1_81.L
0000237C  5760      
0000237E  4E93      4261          jsr       (A3)
00002380  504F      4262          addq.w    #8,A7
                    4263   ; if(*(unsigned short int *)(PC) == 0x4e4e)
00002382  2039 0B00 4264          move.l    _PC.L,D0
00002386  0120      
00002388  2040      4265          move.l    D0,A0
0000238A  3010      4266          move.w    (A0),D0
0000238C  0C40 4E4E 4267          cmp.w     #20046,D0
00002390  660A      4268          bne.s     DumpRegisters_40
                    4269   ; printf("[@ BREAKPOINT]") ;
00002392  4879 0000 4270          pea       @m68kde~1_82.L
00002396  5770      
00002398  4E93      4271          jsr       (A3)
0000239A  584F      4272          addq.w    #4,A7
                    4273   DumpRegisters_40:
                    4274   ; printf("\r\n") ;
0000239C  4879 0000 4275          pea       @m68kde~1_1.L
000023A0  4EBC      
000023A2  4E93      4276          jsr       (A3)
000023A4  584F      4277          addq.w    #4,A7
                    4278   ; for(i=0; i < 8; i++)    {
000023A6  4244      4279          clr.w     D4
                    4280   DumpRegisters_42:
000023A8  0C44 0008 4281          cmp.w     #8,D4
000023AC  6C00 0040 4282          bge       DumpRegisters_44
                    4283   ; if(WatchPointSetOrCleared[i] == 1)
000023B0  48C4      4284          ext.l     D4
000023B2  2004      4285          move.l    D4,D0
000023B4  E588      4286          lsl.l     #2,D0
000023B6  41F9 0B00 4287          lea       _WatchPointSetOrCleared.L,A0
000023BA  01A2      
000023BC  2030 0800 4288          move.l    0(A0,D0.L),D0
000023C0  0C80 0000 4289          cmp.l     #1,D0
000023C4  0001      
000023C6  6622      4290          bne.s     DumpRegisters_45
                    4291   ; printf("\r\nWP%d = %s", i, WatchPointString[i]) ;
000023C8  220D      4292          move.l    A5,D1
000023CA  48C4      4293          ext.l     D4
000023CC  2F00      4294          move.l    D0,-(A7)
000023CE  2004      4295          move.l    D4,D0
000023D0  C1FC 0064 4296          muls      #100,D0
000023D4  D280      4297          add.l     D0,D1
000023D6  201F      4298          move.l    (A7)+,D0
000023D8  2F01      4299          move.l    D1,-(A7)
000023DA  48C4      4300          ext.l     D4
000023DC  2F04      4301          move.l    D4,-(A7)
000023DE  4879 0000 4302          pea       @m68kde~1_83.L
000023E2  5780      
000023E4  4E93      4303          jsr       (A3)
000023E6  DEFC 000C 4304          add.w     #12,A7
                    4305   DumpRegisters_45:
000023EA  5244      4306          addq.w    #1,D4
000023EC  60BA      4307          bra       DumpRegisters_42
                    4308   DumpRegisters_44:
000023EE  4CDF 3CFC 4309          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
000023F2  4E75      4310          rts
                    4311   ; }
                    4312   ; }
                    4313   ; // Trace Exception Handler
                    4314   ; void DumpRegistersandPause(void)
                    4315   ; {
                    4316   _DumpRegistersandPause:
000023F4  2F0A      4317          move.l    A2,-(A7)
000023F6  45F9 0000 4318          lea       _printf.L,A2
000023FA  3A1C      
                    4319   ; printf("\r\n\r\n\r\n\r\n\r\n\r\nSingle Step  :[ON]") ;
000023FC  4879 0000 4320          pea       @m68kde~1_84.L
00002400  578C      
00002402  4E92      4321          jsr       (A2)
00002404  584F      4322          addq.w    #4,A7
                    4323   ; printf("\r\nBreak Points :[Disabled]") ;
00002406  4879 0000 4324          pea       @m68kde~1_85.L
0000240A  57AC      
0000240C  4E92      4325          jsr       (A2)
0000240E  584F      4326          addq.w    #4,A7
                    4327   ; DumpRegisters() ;
00002410  4EB8 1F40 4328          jsr       _DumpRegisters
                    4329   ; printf("\r\nPress <SPACE> to Execute Next Instruction");
00002414  4879 0000 4330          pea       @m68kde~1_86.L
00002418  57C8      
0000241A  4E92      4331          jsr       (A2)
0000241C  584F      4332          addq.w    #4,A7
                    4333   ; printf("\r\nPress <ESC> to Resume Program") ;
0000241E  4879 0000 4334          pea       @m68kde~1_87.L
00002422  57F4      
00002424  4E92      4335          jsr       (A2)
00002426  584F      4336          addq.w    #4,A7
                    4337   ; menu() ;
00002428  4EB9 0000 4338          jsr       _menu
0000242C  2FD8      
0000242E  245F      4339          move.l    (A7)+,A2
00002430  4E75      4340          rts
                    4341   ; }
                    4342   ; void ChangeRegisters(void)
                    4343   ; {
                    4344   _ChangeRegisters:
00002432  4E56 FFFC 4345          link      A6,#-4
00002436  48E7 303C 4346          movem.l   D2/D3/A2/A3/A4/A5,-(A7)
0000243A  45F9 0000 4347          lea       _printf.L,A2
0000243E  3A1C      
00002440  47EE FFFC 4348          lea       -4(A6),A3
00002444  49F8 0CFA 4349          lea       _Get8HexDigits.L,A4
00002448  4BF8 0BBE 4350          lea       __getch.L,A5
                    4351   ; // get register name d0-d7, a0-a7, up, sp, sr, pc
                    4352   ; int reg_val ;
                    4353   ; char c, reg[3] ;
                    4354   ; reg[0] = tolower(_getch()) ;
0000244C  2F00      4355          move.l    D0,-(A7)
0000244E  4E95      4356          jsr       (A5)
00002450  2200      4357          move.l    D0,D1
00002452  201F      4358          move.l    (A7)+,D0
00002454  2F01      4359          move.l    D1,-(A7)
00002456  4EB9 0000 4360          jsr       _tolower
0000245A  3BA8      
0000245C  584F      4361          addq.w    #4,A7
0000245E  1680      4362          move.b    D0,(A3)
                    4363   ; reg[1] = c = tolower(_getch()) ;
00002460  2F00      4364          move.l    D0,-(A7)
00002462  4E95      4365          jsr       (A5)
00002464  2200      4366          move.l    D0,D1
00002466  201F      4367          move.l    (A7)+,D0
00002468  2F01      4368          move.l    D1,-(A7)
0000246A  4EB9 0000 4369          jsr       _tolower
0000246E  3BA8      
00002470  584F      4370          addq.w    #4,A7
00002472  1400      4371          move.b    D0,D2
00002474  1740 0001 4372          move.b    D0,1(A3)
                    4373   ; if(reg[0] == (char)('d'))  {    // change data register
00002478  1013      4374          move.b    (A3),D0
0000247A  0C00 0064 4375          cmp.b     #100,D0
0000247E  6600 00AE 4376          bne       ChangeRegisters_1
                    4377   ; if((reg[1] > (char)('7')) || (reg[1] < (char)('0'))) {
00002482  102B 0001 4378          move.b    1(A3),D0
00002486  0C00 0037 4379          cmp.b     #55,D0
0000248A  6E0A      4380          bgt.s     ChangeRegisters_5
0000248C  102B 0001 4381          move.b    1(A3),D0
00002490  0C00 0030 4382          cmp.b     #48,D0
00002494  6C0E      4383          bge.s     ChangeRegisters_3
                    4384   ChangeRegisters_5:
                    4385   ; printf("\r\nIllegal Data Register : Use D0-D7.....\r\n") ;
00002496  4879 0000 4386          pea       @m68kde~1_88.L
0000249A  5814      
0000249C  4E92      4387          jsr       (A2)
0000249E  584F      4388          addq.w    #4,A7
                    4389   ; return ;
000024A0  6000 0244 4390          bra       ChangeRegisters_6
                    4391   ChangeRegisters_3:
                    4392   ; }
                    4393   ; else {
                    4394   ; printf("\r\nD%c = ", c) ;
000024A4  4882      4395          ext.w     D2
000024A6  48C2      4396          ext.l     D2
000024A8  2F02      4397          move.l    D2,-(A7)
000024AA  4879 0000 4398          pea       @m68kde~1_89.L
000024AE  5840      
000024B0  4E92      4399          jsr       (A2)
000024B2  504F      4400          addq.w    #8,A7
                    4401   ; reg_val = Get8HexDigits(0) ;    // read 32 bit value from user keyboard
000024B4  42A7      4402          clr.l     -(A7)
000024B6  4E94      4403          jsr       (A4)
000024B8  584F      4404          addq.w    #4,A7
000024BA  2600      4405          move.l    D0,D3
                    4406   ; }
                    4407   ; // bit cludgy but d0-d7 not stored as an array for good reason
                    4408   ; if(c == (char)('0'))
000024BC  0C02 0030 4409          cmp.b     #48,D2
000024C0  660A      4410          bne.s     ChangeRegisters_7
                    4411   ; d0 = reg_val ;
000024C2  23C3 0B00 4412          move.l    D3,_d0.L
000024C6  00E4      
000024C8  6000 0060 4413          bra       ChangeRegisters_20
                    4414   ChangeRegisters_7:
                    4415   ; else if(c == (char)('1'))
000024CC  0C02 0031 4416          cmp.b     #49,D2
000024D0  660A      4417          bne.s     ChangeRegisters_9
                    4418   ; d1 = reg_val ;
000024D2  23C3 0B00 4419          move.l    D3,_d1.L
000024D6  00E8      
000024D8  6000 0050 4420          bra       ChangeRegisters_20
                    4421   ChangeRegisters_9:
                    4422   ; else if(c == (char)('2'))
000024DC  0C02 0032 4423          cmp.b     #50,D2
000024E0  660A      4424          bne.s     ChangeRegisters_11
                    4425   ; d2 = reg_val ;
000024E2  23C3 0B00 4426          move.l    D3,_d2.L
000024E6  00EC      
000024E8  6000 0040 4427          bra       ChangeRegisters_20
                    4428   ChangeRegisters_11:
                    4429   ; else if(c == (char)('3'))
000024EC  0C02 0033 4430          cmp.b     #51,D2
000024F0  6608      4431          bne.s     ChangeRegisters_13
                    4432   ; d3 = reg_val ;
000024F2  23C3 0B00 4433          move.l    D3,_d3.L
000024F6  00F0      
000024F8  6030      4434          bra.s     ChangeRegisters_20
                    4435   ChangeRegisters_13:
                    4436   ; else if(c == (char)('4'))
000024FA  0C02 0034 4437          cmp.b     #52,D2
000024FE  6608      4438          bne.s     ChangeRegisters_15
                    4439   ; d4 = reg_val ;
00002500  23C3 0B00 4440          move.l    D3,_d4.L
00002504  00F4      
00002506  6022      4441          bra.s     ChangeRegisters_20
                    4442   ChangeRegisters_15:
                    4443   ; else if(c == (char)('5'))
00002508  0C02 0035 4444          cmp.b     #53,D2
0000250C  6608      4445          bne.s     ChangeRegisters_17
                    4446   ; d5 = reg_val ;
0000250E  23C3 0B00 4447          move.l    D3,_d5.L
00002512  00F8      
00002514  6014      4448          bra.s     ChangeRegisters_20
                    4449   ChangeRegisters_17:
                    4450   ; else if(c == (char)('6'))
00002516  0C02 0036 4451          cmp.b     #54,D2
0000251A  6608      4452          bne.s     ChangeRegisters_19
                    4453   ; d6 = reg_val ;
0000251C  23C3 0B00 4454          move.l    D3,_d6.L
00002520  00FC      
00002522  6006      4455          bra.s     ChangeRegisters_20
                    4456   ChangeRegisters_19:
                    4457   ; else
                    4458   ; d7 = reg_val ;
00002524  23C3 0B00 4459          move.l    D3,_d7.L
00002528  0100      
                    4460   ChangeRegisters_20:
0000252A  6000 01B6 4461          bra       ChangeRegisters_51
                    4462   ChangeRegisters_1:
                    4463   ; }
                    4464   ; else if(reg[0] == (char)('a'))  {    // change address register, a7 is the user stack pointer, sp is the system stack pointer
0000252E  1013      4465          move.b    (A3),D0
00002530  0C00 0061 4466          cmp.b     #97,D0
00002534  6600 00A6 4467          bne       ChangeRegisters_21
                    4468   ; if((c > (char)('7')) || (c < (char)('0'))) {
00002538  0C02 0037 4469          cmp.b     #55,D2
0000253C  6E06      4470          bgt.s     ChangeRegisters_25
0000253E  0C02 0030 4471          cmp.b     #48,D2
00002542  6C0E      4472          bge.s     ChangeRegisters_23
                    4473   ChangeRegisters_25:
                    4474   ; printf("\r\nIllegal Address Register : Use A0-A7.....\r\n") ;
00002544  4879 0000 4475          pea       @m68kde~1_90.L
00002548  584A      
0000254A  4E92      4476          jsr       (A2)
0000254C  584F      4477          addq.w    #4,A7
                    4478   ; return ;
0000254E  6000 0196 4479          bra       ChangeRegisters_6
                    4480   ChangeRegisters_23:
                    4481   ; }
                    4482   ; else {
                    4483   ; printf("\r\nA%c = ", c) ;
00002552  4882      4484          ext.w     D2
00002554  48C2      4485          ext.l     D2
00002556  2F02      4486          move.l    D2,-(A7)
00002558  4879 0000 4487          pea       @m68kde~1_91.L
0000255C  5878      
0000255E  4E92      4488          jsr       (A2)
00002560  504F      4489          addq.w    #8,A7
                    4490   ; reg_val = Get8HexDigits(0) ;    // read 32 bit value from user keyboard
00002562  42A7      4491          clr.l     -(A7)
00002564  4E94      4492          jsr       (A4)
00002566  584F      4493          addq.w    #4,A7
00002568  2600      4494          move.l    D0,D3
                    4495   ; }
                    4496   ; // bit cludgy but a0-a7 not stored as an array for good reason
                    4497   ; if(c == (char)('0'))
0000256A  0C02 0030 4498          cmp.b     #48,D2
0000256E  660A      4499          bne.s     ChangeRegisters_26
                    4500   ; a0 = reg_val ;
00002570  23C3 0B00 4501          move.l    D3,_a0.L
00002574  0104      
00002576  6000 0060 4502          bra       ChangeRegisters_39
                    4503   ChangeRegisters_26:
                    4504   ; else if(c == (char)('1'))
0000257A  0C02 0031 4505          cmp.b     #49,D2
0000257E  660A      4506          bne.s     ChangeRegisters_28
                    4507   ; a1 = reg_val ;
00002580  23C3 0B00 4508          move.l    D3,_a1.L
00002584  0108      
00002586  6000 0050 4509          bra       ChangeRegisters_39
                    4510   ChangeRegisters_28:
                    4511   ; else if(c == (char)('2'))
0000258A  0C02 0032 4512          cmp.b     #50,D2
0000258E  660A      4513          bne.s     ChangeRegisters_30
                    4514   ; a2 = reg_val ;
00002590  23C3 0B00 4515          move.l    D3,_a2.L
00002594  010C      
00002596  6000 0040 4516          bra       ChangeRegisters_39
                    4517   ChangeRegisters_30:
                    4518   ; else if(c == (char)('3'))
0000259A  0C02 0033 4519          cmp.b     #51,D2
0000259E  6608      4520          bne.s     ChangeRegisters_32
                    4521   ; a3 = reg_val ;
000025A0  23C3 0B00 4522          move.l    D3,_a3.L
000025A4  0110      
000025A6  6030      4523          bra.s     ChangeRegisters_39
                    4524   ChangeRegisters_32:
                    4525   ; else if(c == (char)('4'))
000025A8  0C02 0034 4526          cmp.b     #52,D2
000025AC  6608      4527          bne.s     ChangeRegisters_34
                    4528   ; a4 = reg_val ;
000025AE  23C3 0B00 4529          move.l    D3,_a4.L
000025B2  0114      
000025B4  6022      4530          bra.s     ChangeRegisters_39
                    4531   ChangeRegisters_34:
                    4532   ; else if(c == (char)('5'))
000025B6  0C02 0035 4533          cmp.b     #53,D2
000025BA  6608      4534          bne.s     ChangeRegisters_36
                    4535   ; a5 = reg_val ;
000025BC  23C3 0B00 4536          move.l    D3,_a5.L
000025C0  0118      
000025C2  6014      4537          bra.s     ChangeRegisters_39
                    4538   ChangeRegisters_36:
                    4539   ; else if(c == (char)('6'))
000025C4  0C02 0036 4540          cmp.b     #54,D2
000025C8  6608      4541          bne.s     ChangeRegisters_38
                    4542   ; a6 = reg_val ;
000025CA  23C3 0B00 4543          move.l    D3,_a6.L
000025CE  011C      
000025D0  6006      4544          bra.s     ChangeRegisters_39
                    4545   ChangeRegisters_38:
                    4546   ; else
                    4547   ; USP = reg_val ;
000025D2  23C3 0B00 4548          move.l    D3,_USP.L
000025D6  0128      
                    4549   ChangeRegisters_39:
000025D8  6000 0108 4550          bra       ChangeRegisters_51
                    4551   ChangeRegisters_21:
                    4552   ; }
                    4553   ; else if((reg[0] == (char)('u')) && (c == (char)('s')))  {
000025DC  1013      4554          move.b    (A3),D0
000025DE  0C00 0075 4555          cmp.b     #117,D0
000025E2  6600 004E 4556          bne       ChangeRegisters_40
000025E6  0C02 0073 4557          cmp.b     #115,D2
000025EA  6600 0046 4558          bne       ChangeRegisters_40
                    4559   ; if(tolower(_getch()) == 'p')  {    // change user stack pointer
000025EE  2F00      4560          move.l    D0,-(A7)
000025F0  4E95      4561          jsr       (A5)
000025F2  2200      4562          move.l    D0,D1
000025F4  201F      4563          move.l    (A7)+,D0
000025F6  2F01      4564          move.l    D1,-(A7)
000025F8  4EB9 0000 4565          jsr       _tolower
000025FC  3BA8      
000025FE  584F      4566          addq.w    #4,A7
00002600  0C80 0000 4567          cmp.l     #112,D0
00002604  0070      
00002606  6618      4568          bne.s     ChangeRegisters_42
                    4569   ; printf("\r\nUser SP = ") ;
00002608  4879 0000 4570          pea       @m68kde~1_92.L
0000260C  5882      
0000260E  4E92      4571          jsr       (A2)
00002610  584F      4572          addq.w    #4,A7
                    4573   ; USP = Get8HexDigits(0) ;    // read 32 bit value from user keyboard
00002612  42A7      4574          clr.l     -(A7)
00002614  4E94      4575          jsr       (A4)
00002616  584F      4576          addq.w    #4,A7
00002618  23C0 0B00 4577          move.l    D0,_USP.L
0000261C  0128      
0000261E  600E      4578          bra.s     ChangeRegisters_43
                    4579   ChangeRegisters_42:
                    4580   ; }
                    4581   ; else {
                    4582   ; printf("\r\nIllegal Register....") ;
00002620  4879 0000 4583          pea       @m68kde~1_93.L
00002624  5890      
00002626  4E92      4584          jsr       (A2)
00002628  584F      4585          addq.w    #4,A7
                    4586   ; return ;
0000262A  6000 00BA 4587          bra       ChangeRegisters_6
                    4588   ChangeRegisters_43:
0000262E  6000 00B2 4589          bra       ChangeRegisters_51
                    4590   ChangeRegisters_40:
                    4591   ; }
                    4592   ; }
                    4593   ; else if((reg[0] == (char)('s')) && (c == (char)('s')))  {
00002632  1013      4594          move.b    (A3),D0
00002634  0C00 0073 4595          cmp.b     #115,D0
00002638  6600 004E 4596          bne       ChangeRegisters_44
0000263C  0C02 0073 4597          cmp.b     #115,D2
00002640  6600 0046 4598          bne       ChangeRegisters_44
                    4599   ; if(tolower(_getch()) == 'p')  {    // change system stack pointer
00002644  2F00      4600          move.l    D0,-(A7)
00002646  4E95      4601          jsr       (A5)
00002648  2200      4602          move.l    D0,D1
0000264A  201F      4603          move.l    (A7)+,D0
0000264C  2F01      4604          move.l    D1,-(A7)
0000264E  4EB9 0000 4605          jsr       _tolower
00002652  3BA8      
00002654  584F      4606          addq.w    #4,A7
00002656  0C80 0000 4607          cmp.l     #112,D0
0000265A  0070      
0000265C  6618      4608          bne.s     ChangeRegisters_46
                    4609   ; printf("\r\nSystem SP = ") ;
0000265E  4879 0000 4610          pea       @m68kde~1_94.L
00002662  58A8      
00002664  4E92      4611          jsr       (A2)
00002666  584F      4612          addq.w    #4,A7
                    4613   ; SSP = Get8HexDigits(0) ;    // read 32 bit value from user keyboard
00002668  42A7      4614          clr.l     -(A7)
0000266A  4E94      4615          jsr       (A4)
0000266C  584F      4616          addq.w    #4,A7
0000266E  23C0 0B00 4617          move.l    D0,_SSP.L
00002672  0124      
00002674  600E      4618          bra.s     ChangeRegisters_47
                    4619   ChangeRegisters_46:
                    4620   ; }
                    4621   ; else {
                    4622   ; printf("\r\nIllegal Register....") ;
00002676  4879 0000 4623          pea       @m68kde~1_93.L
0000267A  5890      
0000267C  4E92      4624          jsr       (A2)
0000267E  584F      4625          addq.w    #4,A7
                    4626   ; return ;
00002680  6000 0064 4627          bra       ChangeRegisters_6
                    4628   ChangeRegisters_47:
00002684  6000 005C 4629          bra       ChangeRegisters_51
                    4630   ChangeRegisters_44:
                    4631   ; }
                    4632   ; }
                    4633   ; else if((reg[0] == (char)('p')) && (c == (char)('c')))  {    // change program counter
00002688  1013      4634          move.b    (A3),D0
0000268A  0C00 0070 4635          cmp.b     #112,D0
0000268E  6620      4636          bne.s     ChangeRegisters_48
00002690  0C02 0063 4637          cmp.b     #99,D2
00002694  661A      4638          bne.s     ChangeRegisters_48
                    4639   ; printf("\r\nPC = ") ;
00002696  4879 0000 4640          pea       @m68kde~1_95.L
0000269A  58B8      
0000269C  4E92      4641          jsr       (A2)
0000269E  584F      4642          addq.w    #4,A7
                    4643   ; PC = Get8HexDigits(0) ;    // read 32 bit value from user keyboard
000026A0  42A7      4644          clr.l     -(A7)
000026A2  4E94      4645          jsr       (A4)
000026A4  584F      4646          addq.w    #4,A7
000026A6  23C0 0B00 4647          move.l    D0,_PC.L
000026AA  0120      
000026AC  6000 0034 4648          bra       ChangeRegisters_51
                    4649   ChangeRegisters_48:
                    4650   ; }
                    4651   ; else if((reg[0] == (char)('s')) && (c == (char)('r')))  {    // change status register
000026B0  1013      4652          move.b    (A3),D0
000026B2  0C00 0073 4653          cmp.b     #115,D0
000026B6  6620      4654          bne.s     ChangeRegisters_50
000026B8  0C02 0072 4655          cmp.b     #114,D2
000026BC  661A      4656          bne.s     ChangeRegisters_50
                    4657   ; printf("\r\nSR = ") ;
000026BE  4879 0000 4658          pea       @m68kde~1_96.L
000026C2  58C0      
000026C4  4E92      4659          jsr       (A2)
000026C6  584F      4660          addq.w    #4,A7
                    4661   ; SR = Get4HexDigits(0) ;    // read 16 bit value from user keyboard
000026C8  42A7      4662          clr.l     -(A7)
000026CA  4EB8 0CAE 4663          jsr       _Get4HexDigits
000026CE  584F      4664          addq.w    #4,A7
000026D0  33C0 0B00 4665          move.w    D0,_SR.L
000026D4  012C      
000026D6  600A      4666          bra.s     ChangeRegisters_51
                    4667   ChangeRegisters_50:
                    4668   ; }
                    4669   ; else
                    4670   ; printf("\r\nIllegal Register: Use A0-A7, D0-D7, SSP, USP, PC or SR\r\n") ;
000026D8  4879 0000 4671          pea       @m68kde~1_97.L
000026DC  58C8      
000026DE  4E92      4672          jsr       (A2)
000026E0  584F      4673          addq.w    #4,A7
                    4674   ChangeRegisters_51:
                    4675   ; DumpRegisters() ;
000026E2  4EB8 1F40 4676          jsr       _DumpRegisters
                    4677   ChangeRegisters_6:
000026E6  4CDF 3C0C 4678          movem.l   (A7)+,D2/D3/A2/A3/A4/A5
000026EA  4E5E      4679          unlk      A6
000026EC  4E75      4680          rts
                    4681   ; }
                    4682   ; void BreakPointDisplay(void)
                    4683   ; {
                    4684   _BreakPointDisplay:
000026EE  48E7 3030 4685          movem.l   D2/D3/A2/A3,-(A7)
000026F2  45F9 0000 4686          lea       _printf.L,A2
000026F6  3A1C      
000026F8  47F9 0B00 4687          lea       _BreakPointAddress.L,A3
000026FC  012E      
                    4688   ; int i, BreakPointsSet = 0 ;
000026FE  4283      4689          clr.l     D3
                    4690   ; // any break points  set
                    4691   ; for(i = 0; i < 8; i++)  {
00002700  4282      4692          clr.l     D2
                    4693   BreakPointDisplay_1:
00002702  0C82 0000 4694          cmp.l     #8,D2
00002706  0008      
00002708  6C1C      4695          bge.s     BreakPointDisplay_3
                    4696   ; if(BreakPointSetOrCleared[i] == 1)
0000270A  2002      4697          move.l    D2,D0
0000270C  E588      4698          lsl.l     #2,D0
0000270E  41F9 0B00 4699          lea       _BreakPointSetOrCleared.L,A0
00002712  015E      
00002714  2030 0800 4700          move.l    0(A0,D0.L),D0
00002718  0C80 0000 4701          cmp.l     #1,D0
0000271C  0001      
0000271E  6602      4702          bne.s     BreakPointDisplay_4
                    4703   ; BreakPointsSet = 1;
00002720  7601      4704          moveq     #1,D3
                    4705   BreakPointDisplay_4:
00002722  5282      4706          addq.l    #1,D2
00002724  60DC      4707          bra       BreakPointDisplay_1
                    4708   BreakPointDisplay_3:
                    4709   ; }
                    4710   ; if(BreakPointsSet == 1) {
00002726  0C83 0000 4711          cmp.l     #1,D3
0000272A  0001      
0000272C  6616      4712          bne.s     BreakPointDisplay_6
                    4713   ; printf("\r\n\r\nNum     Address      Instruction") ;
0000272E  4879 0000 4714          pea       @m68kde~1_98.L
00002732  5904      
00002734  4E92      4715          jsr       (A2)
00002736  584F      4716          addq.w    #4,A7
                    4717   ; printf("\r\n---     ---------    -----------") ;
00002738  4879 0000 4718          pea       @m68kde~1_99.L
0000273C  592A      
0000273E  4E92      4719          jsr       (A2)
00002740  584F      4720          addq.w    #4,A7
00002742  600A      4721          bra.s     BreakPointDisplay_7
                    4722   BreakPointDisplay_6:
                    4723   ; }
                    4724   ; else
                    4725   ; printf("\r\nNo BreakPoints Set") ;
00002744  4879 0000 4726          pea       @m68kde~1_100.L
00002748  594E      
0000274A  4E92      4727          jsr       (A2)
0000274C  584F      4728          addq.w    #4,A7
                    4729   BreakPointDisplay_7:
                    4730   ; for(i = 0; i < 8; i++)  {
0000274E  4282      4731          clr.l     D2
                    4732   BreakPointDisplay_8:
00002750  0C82 0000 4733          cmp.l     #8,D2
00002754  0008      
00002756  6C00 005A 4734          bge       BreakPointDisplay_10
                    4735   ; // put opcode back, then put break point back
                    4736   ; if(BreakPointSetOrCleared[i] == 1)  {
0000275A  2002      4737          move.l    D2,D0
0000275C  E588      4738          lsl.l     #2,D0
0000275E  41F9 0B00 4739          lea       _BreakPointSetOrCleared.L,A0
00002762  015E      
00002764  2030 0800 4740          move.l    0(A0,D0.L),D0
00002768  0C80 0000 4741          cmp.l     #1,D0
0000276C  0001      
0000276E  6600 003E 4742          bne       BreakPointDisplay_11
                    4743   ; *(unsigned short int *)(BreakPointAddress[i]) = BreakPointInstruction[i];
00002772  2002      4744          move.l    D2,D0
00002774  E388      4745          lsl.l     #1,D0
00002776  41F9 0B00 4746          lea       _BreakPointInstruction.L,A0
0000277A  014E      
0000277C  2202      4747          move.l    D2,D1
0000277E  E589      4748          lsl.l     #2,D1
00002780  2233 1800 4749          move.l    0(A3,D1.L),D1
00002784  2241      4750          move.l    D1,A1
00002786  32B0 0800 4751          move.w    0(A0,D0.L),(A1)
                    4752   ; *(unsigned short int *)(BreakPointAddress[i]) = (unsigned short int)(0x4e4e) ;
0000278A  2002      4753          move.l    D2,D0
0000278C  E588      4754          lsl.l     #2,D0
0000278E  2033 0800 4755          move.l    0(A3,D0.L),D0
00002792  2040      4756          move.l    D0,A0
00002794  30BC 4E4E 4757          move.w    #20046,(A0)
                    4758   ; printf("\r\n%3d     $%08x",i, BreakPointAddress[i]) ;
00002798  2202      4759          move.l    D2,D1
0000279A  E589      4760          lsl.l     #2,D1
0000279C  2F33 1800 4761          move.l    0(A3,D1.L),-(A7)
000027A0  2F02      4762          move.l    D2,-(A7)
000027A2  4879 0000 4763          pea       @m68kde~1_101.L
000027A6  5964      
000027A8  4E92      4764          jsr       (A2)
000027AA  DEFC 000C 4765          add.w     #12,A7
                    4766   BreakPointDisplay_11:
000027AE  5282      4767          addq.l    #1,D2
000027B0  609E      4768          bra       BreakPointDisplay_8
                    4769   BreakPointDisplay_10:
                    4770   ; }
                    4771   ; }
                    4772   ; printf("\r\n") ;
000027B2  4879 0000 4773          pea       @m68kde~1_1.L
000027B6  4EBC      
000027B8  4E92      4774          jsr       (A2)
000027BA  584F      4775          addq.w    #4,A7
000027BC  4CDF 0C0C 4776          movem.l   (A7)+,D2/D3/A2/A3
000027C0  4E75      4777          rts
                    4778   ; }
                    4779   ; void WatchPointDisplay(void)
                    4780   ; {
                    4781   _WatchPointDisplay:
000027C2  48E7 3020 4782          movem.l   D2/D3/A2,-(A7)
000027C6  45F9 0000 4783          lea       _printf.L,A2
000027CA  3A1C      
                    4784   ; int i ;
                    4785   ; int WatchPointsSet = 0 ;
000027CC  4283      4786          clr.l     D3
                    4787   ; // any watchpoints set
                    4788   ; for(i = 0; i < 8; i++)  {
000027CE  4282      4789          clr.l     D2
                    4790   WatchPointDisplay_1:
000027D0  0C82 0000 4791          cmp.l     #8,D2
000027D4  0008      
000027D6  6C1C      4792          bge.s     WatchPointDisplay_3
                    4793   ; if(WatchPointSetOrCleared[i] == 1)
000027D8  2002      4794          move.l    D2,D0
000027DA  E588      4795          lsl.l     #2,D0
000027DC  41F9 0B00 4796          lea       _WatchPointSetOrCleared.L,A0
000027E0  01A2      
000027E2  2030 0800 4797          move.l    0(A0,D0.L),D0
000027E6  0C80 0000 4798          cmp.l     #1,D0
000027EA  0001      
000027EC  6602      4799          bne.s     WatchPointDisplay_4
                    4800   ; WatchPointsSet = 1;
000027EE  7601      4801          moveq     #1,D3
                    4802   WatchPointDisplay_4:
000027F0  5282      4803          addq.l    #1,D2
000027F2  60DC      4804          bra       WatchPointDisplay_1
                    4805   WatchPointDisplay_3:
                    4806   ; }
                    4807   ; if(WatchPointsSet == 1) {
000027F4  0C83 0000 4808          cmp.l     #1,D3
000027F8  0001      
000027FA  6616      4809          bne.s     WatchPointDisplay_6
                    4810   ; printf("\r\nNum     Address") ;
000027FC  4879 0000 4811          pea       @m68kde~1_102.L
00002800  5974      
00002802  4E92      4812          jsr       (A2)
00002804  584F      4813          addq.w    #4,A7
                    4814   ; printf("\r\n---     ---------") ;
00002806  4879 0000 4815          pea       @m68kde~1_103.L
0000280A  5986      
0000280C  4E92      4816          jsr       (A2)
0000280E  584F      4817          addq.w    #4,A7
00002810  600A      4818          bra.s     WatchPointDisplay_7
                    4819   WatchPointDisplay_6:
                    4820   ; }
                    4821   ; else
                    4822   ; printf("\r\nNo WatchPoints Set") ;
00002812  4879 0000 4823          pea       @m68kde~1_104.L
00002816  599A      
00002818  4E92      4824          jsr       (A2)
0000281A  584F      4825          addq.w    #4,A7
                    4826   WatchPointDisplay_7:
                    4827   ; for(i = 0; i < 8; i++)  {
0000281C  4282      4828          clr.l     D2
                    4829   WatchPointDisplay_8:
0000281E  0C82 0000 4830          cmp.l     #8,D2
00002822  0008      
00002824  6C00 0038 4831          bge       WatchPointDisplay_10
                    4832   ; if(WatchPointSetOrCleared[i] == 1)
00002828  2002      4833          move.l    D2,D0
0000282A  E588      4834          lsl.l     #2,D0
0000282C  41F9 0B00 4835          lea       _WatchPointSetOrCleared.L,A0
00002830  01A2      
00002832  2030 0800 4836          move.l    0(A0,D0.L),D0
00002836  0C80 0000 4837          cmp.l     #1,D0
0000283A  0001      
0000283C  661C      4838          bne.s     WatchPointDisplay_11
                    4839   ; printf("\r\n%3d     $%08x",i, WatchPointAddress[i]) ;
0000283E  2202      4840          move.l    D2,D1
00002840  E589      4841          lsl.l     #2,D1
00002842  41F9 0B00 4842          lea       _WatchPointAddress.L,A0
00002846  0182      
00002848  2F30 1800 4843          move.l    0(A0,D1.L),-(A7)
0000284C  2F02      4844          move.l    D2,-(A7)
0000284E  4879 0000 4845          pea       @m68kde~1_101.L
00002852  5964      
00002854  4E92      4846          jsr       (A2)
00002856  DEFC 000C 4847          add.w     #12,A7
                    4848   WatchPointDisplay_11:
0000285A  5282      4849          addq.l    #1,D2
0000285C  60C0      4850          bra       WatchPointDisplay_8
                    4851   WatchPointDisplay_10:
                    4852   ; }
                    4853   ; printf("\r\n") ;
0000285E  4879 0000 4854          pea       @m68kde~1_1.L
00002862  4EBC      
00002864  4E92      4855          jsr       (A2)
00002866  584F      4856          addq.w    #4,A7
00002868  4CDF 040C 4857          movem.l   (A7)+,D2/D3/A2
0000286C  4E75      4858          rts
                    4859   ; }
                    4860   ; void BreakPointClear(void)
                    4861   ; {
                    4862   _BreakPointClear:
0000286E  4E56 FFFC 4863          link      A6,#-4
00002872  48E7 2020 4864          movem.l   D2/A2,-(A7)
00002876  45F9 0000 4865          lea       _printf.L,A2
0000287A  3A1C      
                    4866   ; unsigned int i ;
                    4867   ; volatile unsigned short int *ProgramBreakPointAddress ;
                    4868   ; BreakPointDisplay() ;
0000287C  4EB8 26EE 4869          jsr       _BreakPointDisplay
                    4870   ; printf("\r\nEnter Break Point Number: ") ;
00002880  4879 0000 4871          pea       @m68kde~1_105.L
00002884  59B0      
00002886  4E92      4872          jsr       (A2)
00002888  584F      4873          addq.w    #4,A7
                    4874   ; i = xtod(_getch()) ;           // get break pointer number
0000288A  2F00      4875          move.l    D0,-(A7)
0000288C  4EB8 0BBE 4876          jsr       __getch
00002890  2200      4877          move.l    D0,D1
00002892  201F      4878          move.l    (A7)+,D0
00002894  2F01      4879          move.l    D1,-(A7)
00002896  4EB8 0C28 4880          jsr       _xtod
0000289A  584F      4881          addq.w    #4,A7
0000289C  C0BC 0000 4882          and.l     #255,D0
000028A0  00FF      
000028A2  2400      4883          move.l    D0,D2
                    4884   ; if((i < 0) || (i > 7))   {
000028A4  0C82 0000 4885          cmp.l     #0,D2
000028A8  0000      
000028AA  6508      4886          blo.s     BreakPointClear_3
000028AC  0C82 0000 4887          cmp.l     #7,D2
000028B0  0007      
000028B2  630E      4888          bls.s     BreakPointClear_1
                    4889   BreakPointClear_3:
                    4890   ; printf("\r\nIllegal Range : Use 0 - 7") ;
000028B4  4879 0000 4891          pea       @m68kde~1_106.L
000028B8  59CE      
000028BA  4E92      4892          jsr       (A2)
000028BC  584F      4893          addq.w    #4,A7
                    4894   ; return ;
000028BE  6000 0080 4895          bra       BreakPointClear_4
                    4896   BreakPointClear_1:
                    4897   ; }
                    4898   ; if(BreakPointSetOrCleared[i] == 1)  {       // if break point set
000028C2  2002      4899          move.l    D2,D0
000028C4  E588      4900          lsl.l     #2,D0
000028C6  41F9 0B00 4901          lea       _BreakPointSetOrCleared.L,A0
000028CA  015E      
000028CC  2030 0800 4902          move.l    0(A0,D0.L),D0
000028D0  0C80 0000 4903          cmp.l     #1,D0
000028D4  0001      
000028D6  6600 005A 4904          bne       BreakPointClear_5
                    4905   ; ProgramBreakPointAddress = (volatile unsigned short int *)(BreakPointAddress[i]) ;     // point to the instruction in the user program we are about to change
000028DA  2002      4906          move.l    D2,D0
000028DC  E588      4907          lsl.l     #2,D0
000028DE  41F9 0B00 4908          lea       _BreakPointAddress.L,A0
000028E2  012E      
000028E4  2D70 0800 4909          move.l    0(A0,D0.L),-4(A6)
000028E8  FFFC      
                    4910   ; BreakPointAddress[i] = 0 ;
000028EA  2002      4911          move.l    D2,D0
000028EC  E588      4912          lsl.l     #2,D0
000028EE  41F9 0B00 4913          lea       _BreakPointAddress.L,A0
000028F2  012E      
000028F4  42B0 0800 4914          clr.l     0(A0,D0.L)
                    4915   ; BreakPointSetOrCleared[i] = 0 ;
000028F8  2002      4916          move.l    D2,D0
000028FA  E588      4917          lsl.l     #2,D0
000028FC  41F9 0B00 4918          lea       _BreakPointSetOrCleared.L,A0
00002900  015E      
00002902  42B0 0800 4919          clr.l     0(A0,D0.L)
                    4920   ; *ProgramBreakPointAddress = BreakPointInstruction[i] ;  // put original instruction back
00002906  2002      4921          move.l    D2,D0
00002908  E388      4922          lsl.l     #1,D0
0000290A  41F9 0B00 4923          lea       _BreakPointInstruction.L,A0
0000290E  014E      
00002910  226E FFFC 4924          move.l    -4(A6),A1
00002914  32B0 0800 4925          move.w    0(A0,D0.L),(A1)
                    4926   ; BreakPointInstruction[i] = 0 ;
00002918  2002      4927          move.l    D2,D0
0000291A  E388      4928          lsl.l     #1,D0
0000291C  41F9 0B00 4929          lea       _BreakPointInstruction.L,A0
00002920  014E      
00002922  4270 0800 4930          clr.w     0(A0,D0.L)
                    4931   ; printf("\r\nBreak Point Cleared.....\r\n") ;
00002926  4879 0000 4932          pea       @m68kde~1_107.L
0000292A  59EA      
0000292C  4E92      4933          jsr       (A2)
0000292E  584F      4934          addq.w    #4,A7
00002930  600A      4935          bra.s     BreakPointClear_6
                    4936   BreakPointClear_5:
                    4937   ; }
                    4938   ; else
                    4939   ; printf("\r\nBreak Point wasn't Set.....") ;
00002932  4879 0000 4940          pea       @m68kde~1_108.L
00002936  5A08      
00002938  4E92      4941          jsr       (A2)
0000293A  584F      4942          addq.w    #4,A7
                    4943   BreakPointClear_6:
                    4944   ; BreakPointDisplay() ;
0000293C  4EB8 26EE 4945          jsr       _BreakPointDisplay
                    4946   ; return ;
                    4947   BreakPointClear_4:
00002940  4CDF 0404 4948          movem.l   (A7)+,D2/A2
00002944  4E5E      4949          unlk      A6
00002946  4E75      4950          rts
                    4951   ; }
                    4952   ; void WatchPointClear(void)
                    4953   ; {
                    4954   _WatchPointClear:
00002948  48E7 2020 4955          movem.l   D2/A2,-(A7)
0000294C  45F9 0000 4956          lea       _printf.L,A2
00002950  3A1C      
                    4957   ; unsigned int i ;
                    4958   ; WatchPointDisplay() ;
00002952  4EB8 27C2 4959          jsr       _WatchPointDisplay
                    4960   ; printf("\r\nEnter Watch Point Number: ") ;
00002956  4879 0000 4961          pea       @m68kde~1_109.L
0000295A  5A26      
0000295C  4E92      4962          jsr       (A2)
0000295E  584F      4963          addq.w    #4,A7
                    4964   ; i = xtod(_getch()) ;           // get watch pointer number
00002960  2F00      4965          move.l    D0,-(A7)
00002962  4EB8 0BBE 4966          jsr       __getch
00002966  2200      4967          move.l    D0,D1
00002968  201F      4968          move.l    (A7)+,D0
0000296A  2F01      4969          move.l    D1,-(A7)
0000296C  4EB8 0C28 4970          jsr       _xtod
00002970  584F      4971          addq.w    #4,A7
00002972  C0BC 0000 4972          and.l     #255,D0
00002976  00FF      
00002978  2400      4973          move.l    D0,D2
                    4974   ; if((i < 0) || (i > 7))   {
0000297A  0C82 0000 4975          cmp.l     #0,D2
0000297E  0000      
00002980  6508      4976          blo.s     WatchPointClear_3
00002982  0C82 0000 4977          cmp.l     #7,D2
00002986  0007      
00002988  630E      4978          bls.s     WatchPointClear_1
                    4979   WatchPointClear_3:
                    4980   ; printf("\r\nIllegal Range : Use 0 - 7") ;
0000298A  4879 0000 4981          pea       @m68kde~1_106.L
0000298E  59CE      
00002990  4E92      4982          jsr       (A2)
00002992  584F      4983          addq.w    #4,A7
                    4984   ; return ;
00002994  6000 004E 4985          bra       WatchPointClear_4
                    4986   WatchPointClear_1:
                    4987   ; }
                    4988   ; if(WatchPointSetOrCleared[i] == 1)  {       // if watch point set
00002998  2002      4989          move.l    D2,D0
0000299A  E588      4990          lsl.l     #2,D0
0000299C  41F9 0B00 4991          lea       _WatchPointSetOrCleared.L,A0
000029A0  01A2      
000029A2  2030 0800 4992          move.l    0(A0,D0.L),D0
000029A6  0C80 0000 4993          cmp.l     #1,D0
000029AA  0001      
000029AC  6628      4994          bne.s     WatchPointClear_5
                    4995   ; WatchPointAddress[i] = 0 ;
000029AE  2002      4996          move.l    D2,D0
000029B0  E588      4997          lsl.l     #2,D0
000029B2  41F9 0B00 4998          lea       _WatchPointAddress.L,A0
000029B6  0182      
000029B8  42B0 0800 4999          clr.l     0(A0,D0.L)
                    5000   ; WatchPointSetOrCleared[i] = 0 ;
000029BC  2002      5001          move.l    D2,D0
000029BE  E588      5002          lsl.l     #2,D0
000029C0  41F9 0B00 5003          lea       _WatchPointSetOrCleared.L,A0
000029C4  01A2      
000029C6  42B0 0800 5004          clr.l     0(A0,D0.L)
                    5005   ; printf("\r\nWatch Point Cleared.....\r\n") ;
000029CA  4879 0000 5006          pea       @m68kde~1_110.L
000029CE  5A44      
000029D0  4E92      5007          jsr       (A2)
000029D2  584F      5008          addq.w    #4,A7
000029D4  600A      5009          bra.s     WatchPointClear_6
                    5010   WatchPointClear_5:
                    5011   ; }
                    5012   ; else
                    5013   ; printf("\r\nWatch Point Was not Set.....") ;
000029D6  4879 0000 5014          pea       @m68kde~1_111.L
000029DA  5A62      
000029DC  4E92      5015          jsr       (A2)
000029DE  584F      5016          addq.w    #4,A7
                    5017   WatchPointClear_6:
                    5018   ; WatchPointDisplay() ;
000029E0  4EB8 27C2 5019          jsr       _WatchPointDisplay
                    5020   ; return ;
                    5021   WatchPointClear_4:
000029E4  4CDF 0404 5022          movem.l   (A7)+,D2/A2
000029E8  4E75      5023          rts
                    5024   ; }
                    5025   ; void DisableBreakPoints(void)
                    5026   ; {
                    5027   _DisableBreakPoints:
000029EA  4E56 FFFC 5028          link      A6,#-4
000029EE  2F02      5029          move.l    D2,-(A7)
                    5030   ; int i ;
                    5031   ; volatile unsigned short int *ProgramBreakPointAddress ;
                    5032   ; for(i = 0; i < 8; i++)  {
000029F0  4282      5033          clr.l     D2
                    5034   DisableBreakPoints_1:
000029F2  0C82 0000 5035          cmp.l     #8,D2
000029F6  0008      
000029F8  6C00 003E 5036          bge       DisableBreakPoints_3
                    5037   ; if(BreakPointSetOrCleared[i] == 1)    {                                                    // if break point set
000029FC  2002      5038          move.l    D2,D0
000029FE  E588      5039          lsl.l     #2,D0
00002A00  41F9 0B00 5040          lea       _BreakPointSetOrCleared.L,A0
00002A04  015E      
00002A06  2030 0800 5041          move.l    0(A0,D0.L),D0
00002A0A  0C80 0000 5042          cmp.l     #1,D0
00002A0E  0001      
00002A10  6622      5043          bne.s     DisableBreakPoints_4
                    5044   ; ProgramBreakPointAddress = (volatile unsigned short int *)(BreakPointAddress[i]) ;     // point to the instruction in the user program where the break point has been set
00002A12  2002      5045          move.l    D2,D0
00002A14  E588      5046          lsl.l     #2,D0
00002A16  41F9 0B00 5047          lea       _BreakPointAddress.L,A0
00002A1A  012E      
00002A1C  2D70 0800 5048          move.l    0(A0,D0.L),-4(A6)
00002A20  FFFC      
                    5049   ; *ProgramBreakPointAddress = BreakPointInstruction[i];                                  // copy the instruction back to the user program overwritting the $4e4e
00002A22  2002      5050          move.l    D2,D0
00002A24  E388      5051          lsl.l     #1,D0
00002A26  41F9 0B00 5052          lea       _BreakPointInstruction.L,A0
00002A2A  014E      
00002A2C  226E FFFC 5053          move.l    -4(A6),A1
00002A30  32B0 0800 5054          move.w    0(A0,D0.L),(A1)
                    5055   DisableBreakPoints_4:
00002A34  5282      5056          addq.l    #1,D2
00002A36  60BA      5057          bra       DisableBreakPoints_1
                    5058   DisableBreakPoints_3:
00002A38  241F      5059          move.l    (A7)+,D2
00002A3A  4E5E      5060          unlk      A6
00002A3C  4E75      5061          rts
                    5062   ; }
                    5063   ; }
                    5064   ; }
                    5065   ; void EnableBreakPoints(void)
                    5066   ; {
                    5067   _EnableBreakPoints:
00002A3E  4E56 FFFC 5068          link      A6,#-4
00002A42  2F02      5069          move.l    D2,-(A7)
                    5070   ; int i ;
                    5071   ; volatile unsigned short int *ProgramBreakPointAddress ;
                    5072   ; for(i = 0; i < 8; i++)  {
00002A44  4282      5073          clr.l     D2
                    5074   EnableBreakPoints_1:
00002A46  0C82 0000 5075          cmp.l     #8,D2
00002A4A  0008      
00002A4C  6C32      5076          bge.s     EnableBreakPoints_3
                    5077   ; if(BreakPointSetOrCleared[i] == 1)    {                                                     // if break point set
00002A4E  2002      5078          move.l    D2,D0
00002A50  E588      5079          lsl.l     #2,D0
00002A52  41F9 0B00 5080          lea       _BreakPointSetOrCleared.L,A0
00002A56  015E      
00002A58  2030 0800 5081          move.l    0(A0,D0.L),D0
00002A5C  0C80 0000 5082          cmp.l     #1,D0
00002A60  0001      
00002A62  6618      5083          bne.s     EnableBreakPoints_4
                    5084   ; ProgramBreakPointAddress = (volatile unsigned short int *)(BreakPointAddress[i]) ;     // point to the instruction in the user program where the break point has been set
00002A64  2002      5085          move.l    D2,D0
00002A66  E588      5086          lsl.l     #2,D0
00002A68  41F9 0B00 5087          lea       _BreakPointAddress.L,A0
00002A6C  012E      
00002A6E  2D70 0800 5088          move.l    0(A0,D0.L),-4(A6)
00002A72  FFFC      
                    5089   ; *ProgramBreakPointAddress = (unsigned short int)(0x4e4e);                              // put the breakpoint back in user program
00002A74  206E FFFC 5090          move.l    -4(A6),A0
00002A78  30BC 4E4E 5091          move.w    #20046,(A0)
                    5092   EnableBreakPoints_4:
00002A7C  5282      5093          addq.l    #1,D2
00002A7E  60C6      5094          bra       EnableBreakPoints_1
                    5095   EnableBreakPoints_3:
00002A80  241F      5096          move.l    (A7)+,D2
00002A82  4E5E      5097          unlk      A6
00002A84  4E75      5098          rts
                    5099   ; }
                    5100   ; }
                    5101   ; }
                    5102   ; void KillAllBreakPoints(void)
                    5103   ; {
                    5104   _KillAllBreakPoints:
00002A86  4E56 FFFC 5105          link      A6,#-4
00002A8A  2F02      5106          move.l    D2,-(A7)
                    5107   ; int i ;
                    5108   ; volatile unsigned short int *ProgramBreakPointAddress ;
                    5109   ; for(i = 0; i < 8; i++)  {
00002A8C  4282      5110          clr.l     D2
                    5111   KillAllBreakPoints_1:
00002A8E  0C82 0000 5112          cmp.l     #8,D2
00002A92  0008      
00002A94  6C00 0052 5113          bge       KillAllBreakPoints_3
                    5114   ; // clear BP
                    5115   ; ProgramBreakPointAddress = (volatile unsigned short int *)(BreakPointAddress[i]) ;     // point to the instruction in the user program where the break point has been set
00002A98  2002      5116          move.l    D2,D0
00002A9A  E588      5117          lsl.l     #2,D0
00002A9C  41F9 0B00 5118          lea       _BreakPointAddress.L,A0
00002AA0  012E      
00002AA2  2D70 0800 5119          move.l    0(A0,D0.L),-4(A6)
00002AA6  FFFC      
                    5120   ; *ProgramBreakPointAddress = BreakPointInstruction[i];                                  // copy the instruction back to the user program
00002AA8  2002      5121          move.l    D2,D0
00002AAA  E388      5122          lsl.l     #1,D0
00002AAC  41F9 0B00 5123          lea       _BreakPointInstruction.L,A0
00002AB0  014E      
00002AB2  226E FFFC 5124          move.l    -4(A6),A1
00002AB6  32B0 0800 5125          move.w    0(A0,D0.L),(A1)
                    5126   ; BreakPointAddress[i] = 0 ;                                                             // set BP address to NULL
00002ABA  2002      5127          move.l    D2,D0
00002ABC  E588      5128          lsl.l     #2,D0
00002ABE  41F9 0B00 5129          lea       _BreakPointAddress.L,A0
00002AC2  012E      
00002AC4  42B0 0800 5130          clr.l     0(A0,D0.L)
                    5131   ; BreakPointInstruction[i] = 0 ;
00002AC8  2002      5132          move.l    D2,D0
00002ACA  E388      5133          lsl.l     #1,D0
00002ACC  41F9 0B00 5134          lea       _BreakPointInstruction.L,A0
00002AD0  014E      
00002AD2  4270 0800 5135          clr.w     0(A0,D0.L)
                    5136   ; BreakPointSetOrCleared[i] = 0 ;                                                        // mark break point as cleared for future setting
00002AD6  2002      5137          move.l    D2,D0
00002AD8  E588      5138          lsl.l     #2,D0
00002ADA  41F9 0B00 5139          lea       _BreakPointSetOrCleared.L,A0
00002ADE  015E      
00002AE0  42B0 0800 5140          clr.l     0(A0,D0.L)
00002AE4  5282      5141          addq.l    #1,D2
00002AE6  60A6      5142          bra       KillAllBreakPoints_1
                    5143   KillAllBreakPoints_3:
00002AE8  241F      5144          move.l    (A7)+,D2
00002AEA  4E5E      5145          unlk      A6
00002AEC  4E75      5146          rts
                    5147   ; }
                    5148   ; //BreakPointDisplay() ;       // display the break points
                    5149   ; }
                    5150   ; void KillAllWatchPoints(void)
                    5151   ; {
                    5152   _KillAllWatchPoints:
00002AEE  2F02      5153          move.l    D2,-(A7)
                    5154   ; int i ;
                    5155   ; for(i = 0; i < 8; i++)  {
00002AF0  4282      5156          clr.l     D2
                    5157   KillAllWatchPoints_1:
00002AF2  0C82 0000 5158          cmp.l     #8,D2
00002AF6  0008      
00002AF8  6C20      5159          bge.s     KillAllWatchPoints_3
                    5160   ; WatchPointAddress[i] = 0 ;                                                             // set BP address to NULL
00002AFA  2002      5161          move.l    D2,D0
00002AFC  E588      5162          lsl.l     #2,D0
00002AFE  41F9 0B00 5163          lea       _WatchPointAddress.L,A0
00002B02  0182      
00002B04  42B0 0800 5164          clr.l     0(A0,D0.L)
                    5165   ; WatchPointSetOrCleared[i] = 0 ;                                                        // mark break point as cleared for future setting
00002B08  2002      5166          move.l    D2,D0
00002B0A  E588      5167          lsl.l     #2,D0
00002B0C  41F9 0B00 5168          lea       _WatchPointSetOrCleared.L,A0
00002B10  01A2      
00002B12  42B0 0800 5169          clr.l     0(A0,D0.L)
00002B16  5282      5170          addq.l    #1,D2
00002B18  60D8      5171          bra       KillAllWatchPoints_1
                    5172   KillAllWatchPoints_3:
00002B1A  241F      5173          move.l    (A7)+,D2
00002B1C  4E75      5174          rts
                    5175   ; }
                    5176   ; //WatchPointDisplay() ;       // display the break points
                    5177   ; }
                    5178   ; void SetBreakPoint(void)
                    5179   ; {
                    5180   _SetBreakPoint:
00002B1E  4E56 FFFC 5181          link      A6,#-4
00002B22  48E7 3830 5182          movem.l   D2/D3/D4/A2/A3,-(A7)
00002B26  45F9 0000 5183          lea       _printf.L,A2
00002B2A  3A1C      
00002B2C  47F9 0B00 5184          lea       _BreakPointSetOrCleared.L,A3
00002B30  015E      
                    5185   ; int i ;
                    5186   ; int BPNumber;
                    5187   ; int BPAddress;
                    5188   ; volatile unsigned short int *ProgramBreakPointAddress ;
                    5189   ; // see if any free break points
                    5190   ; for(i = 0; i < 8; i ++) {
00002B32  4282      5191          clr.l     D2
                    5192   SetBreakPoint_1:
00002B34  0C82 0000 5193          cmp.l     #8,D2
00002B38  0008      
00002B3A  6C10      5194          bge.s     SetBreakPoint_3
                    5195   ; if( BreakPointSetOrCleared[i] == 0)
00002B3C  2002      5196          move.l    D2,D0
00002B3E  E588      5197          lsl.l     #2,D0
00002B40  2033 0800 5198          move.l    0(A3,D0.L),D0
00002B44  6602      5199          bne.s     SetBreakPoint_4
                    5200   ; break ;         // if spare BP found allow user to set it
00002B46  6004      5201          bra.s     SetBreakPoint_3
                    5202   SetBreakPoint_4:
00002B48  5282      5203          addq.l    #1,D2
00002B4A  60E8      5204          bra       SetBreakPoint_1
                    5205   SetBreakPoint_3:
                    5206   ; }
                    5207   ; if(i == 8) {
00002B4C  0C82 0000 5208          cmp.l     #8,D2
00002B50  0008      
00002B52  660E      5209          bne.s     SetBreakPoint_6
                    5210   ; printf("\r\nNo FREE Break Points.....") ;
00002B54  4879 0000 5211          pea       @m68kde~1_112.L
00002B58  5A82      
00002B5A  4E92      5212          jsr       (A2)
00002B5C  584F      5213          addq.w    #4,A7
                    5214   ; return ;
00002B5E  6000 00D6 5215          bra       SetBreakPoint_15
                    5216   SetBreakPoint_6:
                    5217   ; }
                    5218   ; printf("\r\nBreak Point Address: ") ;
00002B62  4879 0000 5219          pea       @m68kde~1_113.L
00002B66  5A9E      
00002B68  4E92      5220          jsr       (A2)
00002B6A  584F      5221          addq.w    #4,A7
                    5222   ; BPAddress = Get8HexDigits(0) ;
00002B6C  42A7      5223          clr.l     -(A7)
00002B6E  4EB8 0CFA 5224          jsr       _Get8HexDigits
00002B72  584F      5225          addq.w    #4,A7
00002B74  2600      5226          move.l    D0,D3
                    5227   ; ProgramBreakPointAddress = (volatile unsigned short int *)(BPAddress) ;     // point to the instruction in the user program we are about to change
00002B76  2803      5228          move.l    D3,D4
                    5229   ; if((BPAddress & 0x00000001) == 0x00000001)  {   // cannot set BP at an odd address
00002B78  2003      5230          move.l    D3,D0
00002B7A  C0BC 0000 5231          and.l     #1,D0
00002B7E  0001      
00002B80  0C80 0000 5232          cmp.l     #1,D0
00002B84  0001      
00002B86  660E      5233          bne.s     SetBreakPoint_9
                    5234   ; printf("\r\nError : Break Points CANNOT be set at ODD addresses") ;
00002B88  4879 0000 5235          pea       @m68kde~1_114.L
00002B8C  5AB6      
00002B8E  4E92      5236          jsr       (A2)
00002B90  584F      5237          addq.w    #4,A7
                    5238   ; return ;
00002B92  6000 00A2 5239          bra       SetBreakPoint_15
                    5240   SetBreakPoint_9:
                    5241   ; }
                    5242   ; if(BPAddress < 0x00008000)  {   // cannot set BP in ROM
00002B96  0C83 0000 5243          cmp.l     #32768,D3
00002B9A  8000      
00002B9C  640E      5244          bhs.s     SetBreakPoint_11
                    5245   ; printf("\r\nError : Break Points CANNOT be set for ROM in Range : [$0-$00007FFF]") ;
00002B9E  4879 0000 5246          pea       @m68kde~1_115.L
00002BA2  5AEC      
00002BA4  4E92      5247          jsr       (A2)
00002BA6  584F      5248          addq.w    #4,A7
                    5249   ; return ;
00002BA8  6000 008C 5250          bra       SetBreakPoint_15
                    5251   SetBreakPoint_11:
                    5252   ; }
                    5253   ; // search for first free bp or existing same BP
                    5254   ; for(i = 0; i < 8; i++)  {
00002BAC  4282      5255          clr.l     D2
                    5256   SetBreakPoint_13:
00002BAE  0C82 0000 5257          cmp.l     #8,D2
00002BB2  0008      
00002BB4  6C00 0080 5258          bge       SetBreakPoint_15
                    5259   ; if(BreakPointAddress[i] == BPAddress)   {
00002BB8  2002      5260          move.l    D2,D0
00002BBA  E588      5261          lsl.l     #2,D0
00002BBC  41F9 0B00 5262          lea       _BreakPointAddress.L,A0
00002BC0  012E      
00002BC2  B6B0 0800 5263          cmp.l     0(A0,D0.L),D3
00002BC6  6610      5264          bne.s     SetBreakPoint_16
                    5265   ; printf("\r\nError: Break Point Already Exists at Address : %08x\r\n", BPAddress) ;
00002BC8  2F03      5266          move.l    D3,-(A7)
00002BCA  4879 0000 5267          pea       @m68kde~1_116.L
00002BCE  5B34      
00002BD0  4E92      5268          jsr       (A2)
00002BD2  504F      5269          addq.w    #8,A7
                    5270   ; return ;
00002BD4  6000 0060 5271          bra       SetBreakPoint_15
                    5272   SetBreakPoint_16:
                    5273   ; }
                    5274   ; if(BreakPointSetOrCleared[i] == 0) {
00002BD8  2002      5275          move.l    D2,D0
00002BDA  E588      5276          lsl.l     #2,D0
00002BDC  2033 0800 5277          move.l    0(A3,D0.L),D0
00002BE0  6600 004E 5278          bne       SetBreakPoint_18
                    5279   ; // set BP here
                    5280   ; BreakPointSetOrCleared[i] = 1 ;                                 // mark this breakpoint as set
00002BE4  2002      5281          move.l    D2,D0
00002BE6  E588      5282          lsl.l     #2,D0
00002BE8  27BC 0000 5283          move.l    #1,0(A3,D0.L)
00002BEC  0001 0800 
                    5284   ; BreakPointInstruction[i] = *ProgramBreakPointAddress ;          // copy the user program instruction here so we can put it back afterwards
00002BF0  2044      5285          move.l    D4,A0
00002BF2  2002      5286          move.l    D2,D0
00002BF4  E388      5287          lsl.l     #1,D0
00002BF6  43F9 0B00 5288          lea       _BreakPointInstruction.L,A1
00002BFA  014E      
00002BFC  3390 0800 5289          move.w    (A0),0(A1,D0.L)
                    5290   ; printf("\r\nBreak Point Set at Address: [$%08x]", ProgramBreakPointAddress) ;
00002C00  2F04      5291          move.l    D4,-(A7)
00002C02  4879 0000 5292          pea       @m68kde~1_117.L
00002C06  5B6C      
00002C08  4E92      5293          jsr       (A2)
00002C0A  504F      5294          addq.w    #8,A7
                    5295   ; *ProgramBreakPointAddress = (unsigned short int)(0x4e4e)    ;   // put a Trap14 instruction at the user specified address
00002C0C  2044      5296          move.l    D4,A0
00002C0E  30BC 4E4E 5297          move.w    #20046,(A0)
                    5298   ; BreakPointAddress[i] = BPAddress ;                              // record the address of this break point in the debugger
00002C12  2002      5299          move.l    D2,D0
00002C14  E588      5300          lsl.l     #2,D0
00002C16  41F9 0B00 5301          lea       _BreakPointAddress.L,A0
00002C1A  012E      
00002C1C  2183 0800 5302          move.l    D3,0(A0,D0.L)
                    5303   ; printf("\r\n") ;
00002C20  4879 0000 5304          pea       @m68kde~1_1.L
00002C24  4EBC      
00002C26  4E92      5305          jsr       (A2)
00002C28  584F      5306          addq.w    #4,A7
                    5307   ; BreakPointDisplay() ;       // display the break points
00002C2A  4EB8 26EE 5308          jsr       _BreakPointDisplay
                    5309   ; return ;
00002C2E  6006      5310          bra.s     SetBreakPoint_15
                    5311   SetBreakPoint_18:
00002C30  5282      5312          addq.l    #1,D2
00002C32  6000 FF7A 5313          bra       SetBreakPoint_13
                    5314   SetBreakPoint_15:
00002C36  4CDF 0C1C 5315          movem.l   (A7)+,D2/D3/D4/A2/A3
00002C3A  4E5E      5316          unlk      A6
00002C3C  4E75      5317          rts
                    5318   ; }
                    5319   ; }
                    5320   ; }
                    5321   ; void SetWatchPoint(void)
                    5322   ; {
                    5323   _SetWatchPoint:
00002C3E  4E56 FFF8 5324          link      A6,#-8
00002C42  48E7 3030 5325          movem.l   D2/D3/A2/A3,-(A7)
00002C46  45F9 0000 5326          lea       _printf.L,A2
00002C4A  3A1C      
00002C4C  47F9 0B00 5327          lea       _WatchPointSetOrCleared.L,A3
00002C50  01A2      
                    5328   ; int i ;
                    5329   ; int WPNumber;
                    5330   ; int WPAddress;
                    5331   ; volatile unsigned short int *ProgramWatchPointAddress ;
                    5332   ; // see if any free break points
                    5333   ; for(i = 0; i < 8; i ++) {
00002C52  4282      5334          clr.l     D2
                    5335   SetWatchPoint_1:
00002C54  0C82 0000 5336          cmp.l     #8,D2
00002C58  0008      
00002C5A  6C10      5337          bge.s     SetWatchPoint_3
                    5338   ; if( WatchPointSetOrCleared[i] == 0)
00002C5C  2002      5339          move.l    D2,D0
00002C5E  E588      5340          lsl.l     #2,D0
00002C60  2033 0800 5341          move.l    0(A3,D0.L),D0
00002C64  6602      5342          bne.s     SetWatchPoint_4
                    5343   ; break ;         // if spare WP found allow user to set it
00002C66  6004      5344          bra.s     SetWatchPoint_3
                    5345   SetWatchPoint_4:
00002C68  5282      5346          addq.l    #1,D2
00002C6A  60E8      5347          bra       SetWatchPoint_1
                    5348   SetWatchPoint_3:
                    5349   ; }
                    5350   ; if(i == 8) {
00002C6C  0C82 0000 5351          cmp.l     #8,D2
00002C70  0008      
00002C72  660E      5352          bne.s     SetWatchPoint_6
                    5353   ; printf("\r\nNo FREE Watch Points.....") ;
00002C74  4879 0000 5354          pea       @m68kde~1_118.L
00002C78  5B92      
00002C7A  4E92      5355          jsr       (A2)
00002C7C  584F      5356          addq.w    #4,A7
                    5357   ; return ;
00002C7E  6000 008C 5358          bra       SetWatchPoint_11
                    5359   SetWatchPoint_6:
                    5360   ; }
                    5361   ; printf("\r\nWatch Point Address: ") ;
00002C82  4879 0000 5362          pea       @m68kde~1_119.L
00002C86  5BAE      
00002C88  4E92      5363          jsr       (A2)
00002C8A  584F      5364          addq.w    #4,A7
                    5365   ; WPAddress = Get8HexDigits(0) ;
00002C8C  42A7      5366          clr.l     -(A7)
00002C8E  4EB8 0CFA 5367          jsr       _Get8HexDigits
00002C92  584F      5368          addq.w    #4,A7
00002C94  2600      5369          move.l    D0,D3
                    5370   ; // search for first free wp or existing same wp
                    5371   ; for(i = 0; i < 8; i++)  {
00002C96  4282      5372          clr.l     D2
                    5373   SetWatchPoint_9:
00002C98  0C82 0000 5374          cmp.l     #8,D2
00002C9C  0008      
00002C9E  6C00 006C 5375          bge       SetWatchPoint_11
                    5376   ; if(WatchPointAddress[i] == WPAddress && WPAddress != 0)   {     //so we can set a wp at 0
00002CA2  2002      5377          move.l    D2,D0
00002CA4  E588      5378          lsl.l     #2,D0
00002CA6  41F9 0B00 5379          lea       _WatchPointAddress.L,A0
00002CAA  0182      
00002CAC  B6B0 0800 5380          cmp.l     0(A0,D0.L),D3
00002CB0  6614      5381          bne.s     SetWatchPoint_12
00002CB2  4A83      5382          tst.l     D3
00002CB4  6710      5383          beq.s     SetWatchPoint_12
                    5384   ; printf("\r\nError: Watch Point Already Set at Address : %08x\r\n", WPAddress) ;
00002CB6  2F03      5385          move.l    D3,-(A7)
00002CB8  4879 0000 5386          pea       @m68kde~1_120.L
00002CBC  5BC6      
00002CBE  4E92      5387          jsr       (A2)
00002CC0  504F      5388          addq.w    #8,A7
                    5389   ; return ;
00002CC2  6000 0048 5390          bra       SetWatchPoint_11
                    5391   SetWatchPoint_12:
                    5392   ; }
                    5393   ; if(WatchPointSetOrCleared[i] == 0) {
00002CC6  2002      5394          move.l    D2,D0
00002CC8  E588      5395          lsl.l     #2,D0
00002CCA  2033 0800 5396          move.l    0(A3,D0.L),D0
00002CCE  6600 0038 5397          bne       SetWatchPoint_14
                    5398   ; WatchPointSetOrCleared[i] = 1 ;                                 // mark this watchpoint as set
00002CD2  2002      5399          move.l    D2,D0
00002CD4  E588      5400          lsl.l     #2,D0
00002CD6  27BC 0000 5401          move.l    #1,0(A3,D0.L)
00002CDA  0001 0800 
                    5402   ; printf("\r\nWatch Point Set at Address: [$%08x]", WPAddress) ;
00002CDE  2F03      5403          move.l    D3,-(A7)
00002CE0  4879 0000 5404          pea       @m68kde~1_121.L
00002CE4  5BFC      
00002CE6  4E92      5405          jsr       (A2)
00002CE8  504F      5406          addq.w    #8,A7
                    5407   ; WatchPointAddress[i] = WPAddress ;                              // record the address of this watch point in the debugger
00002CEA  2002      5408          move.l    D2,D0
00002CEC  E588      5409          lsl.l     #2,D0
00002CEE  41F9 0B00 5410          lea       _WatchPointAddress.L,A0
00002CF2  0182      
00002CF4  2183 0800 5411          move.l    D3,0(A0,D0.L)
                    5412   ; printf("\r\n") ;
00002CF8  4879 0000 5413          pea       @m68kde~1_1.L
00002CFC  4EBC      
00002CFE  4E92      5414          jsr       (A2)
00002D00  584F      5415          addq.w    #4,A7
                    5416   ; WatchPointDisplay() ;       // display the break points
00002D02  4EB8 27C2 5417          jsr       _WatchPointDisplay
                    5418   ; return ;
00002D06  6004      5419          bra.s     SetWatchPoint_11
                    5420   SetWatchPoint_14:
00002D08  5282      5421          addq.l    #1,D2
00002D0A  608C      5422          bra       SetWatchPoint_9
                    5423   SetWatchPoint_11:
00002D0C  4CDF 0C0C 5424          movem.l   (A7)+,D2/D3/A2/A3
00002D10  4E5E      5425          unlk      A6
00002D12  4E75      5426          rts
                    5427   ; }
                    5428   ; }
                    5429   ; }
                    5430   ; void HandleBreakPoint(void)
                    5431   ; {
                    5432   _HandleBreakPoint:
00002D14  4E56 FFFC 5433          link      A6,#-4
00002D18  48E7 0038 5434          movem.l   A2/A3/A4,-(A7)
00002D1C  45F9 0B00 5435          lea       _i.L,A2
00002D20  00C4      
00002D22  47F9 0000 5436          lea       _printf.L,A3
00002D26  3A1C      
00002D28  49F9 0B00 5437          lea       _PC.L,A4
00002D2C  0120      
                    5438   ; volatile unsigned short int *ProgramBreakPointAddress ;
                    5439   ; // now we have to put the break point back to run the instruction
                    5440   ; // PC will contain the address of the TRAP instruction but advanced by two bytes so lets play with that
                    5441   ; PC = PC - 2 ;  // ready for user to resume after reaching breakpoint
00002D2E  5594      5442          subq.l    #2,(A4)
                    5443   ; printf("\r\n\r\n\r\n\r\n@BREAKPOINT") ;
00002D30  4879 0000 5444          pea       @m68kde~1_122.L
00002D34  5C22      
00002D36  4E93      5445          jsr       (A3)
00002D38  584F      5446          addq.w    #4,A7
                    5447   ; printf("\r\nSingle Step : [ON]") ;
00002D3A  4879 0000 5448          pea       @m68kde~1_123.L
00002D3E  5C36      
00002D40  4E93      5449          jsr       (A3)
00002D42  584F      5450          addq.w    #4,A7
                    5451   ; printf("\r\nBreakPoints : [Enabled]") ;
00002D44  4879 0000 5452          pea       @m68kde~1_124.L
00002D48  5C4C      
00002D4A  4E93      5453          jsr       (A3)
00002D4C  584F      5454          addq.w    #4,A7
                    5455   ; // now clear the break point (put original instruction back)
                    5456   ; ProgramBreakPointAddress = PC ;
00002D4E  2D54 FFFC 5457          move.l    (A4),-4(A6)
                    5458   ; for(i = 0; i < 8; i ++) {
00002D52  4292      5459          clr.l     (A2)
                    5460   HandleBreakPoint_1:
00002D54  2012      5461          move.l    (A2),D0
00002D56  0C80 0000 5462          cmp.l     #8,D0
00002D5A  0008      
00002D5C  6400 0056 5463          bhs       HandleBreakPoint_3
                    5464   ; if(BreakPointAddress[i] == PC) {        // if we have found the breakpoint
00002D60  2012      5465          move.l    (A2),D0
00002D62  E588      5466          lsl.l     #2,D0
00002D64  41F9 0B00 5467          lea       _BreakPointAddress.L,A0
00002D68  012E      
00002D6A  2230 0800 5468          move.l    0(A0,D0.L),D1
00002D6E  B294      5469          cmp.l     (A4),D1
00002D70  6600 003E 5470          bne       HandleBreakPoint_4
                    5471   ; BreakPointAddress[i] = 0 ;
00002D74  2012      5472          move.l    (A2),D0
00002D76  E588      5473          lsl.l     #2,D0
00002D78  41F9 0B00 5474          lea       _BreakPointAddress.L,A0
00002D7C  012E      
00002D7E  42B0 0800 5475          clr.l     0(A0,D0.L)
                    5476   ; BreakPointSetOrCleared[i] = 0 ;
00002D82  2012      5477          move.l    (A2),D0
00002D84  E588      5478          lsl.l     #2,D0
00002D86  41F9 0B00 5479          lea       _BreakPointSetOrCleared.L,A0
00002D8A  015E      
00002D8C  42B0 0800 5480          clr.l     0(A0,D0.L)
                    5481   ; *ProgramBreakPointAddress = BreakPointInstruction[i] ;  // put original instruction back
00002D90  2012      5482          move.l    (A2),D0
00002D92  E388      5483          lsl.l     #1,D0
00002D94  41F9 0B00 5484          lea       _BreakPointInstruction.L,A0
00002D98  014E      
00002D9A  226E FFFC 5485          move.l    -4(A6),A1
00002D9E  32B0 0800 5486          move.w    0(A0,D0.L),(A1)
                    5487   ; BreakPointInstruction[i] = 0 ;
00002DA2  2012      5488          move.l    (A2),D0
00002DA4  E388      5489          lsl.l     #1,D0
00002DA6  41F9 0B00 5490          lea       _BreakPointInstruction.L,A0
00002DAA  014E      
00002DAC  4270 0800 5491          clr.w     0(A0,D0.L)
                    5492   HandleBreakPoint_4:
00002DB0  5292      5493          addq.l    #1,(A2)
00002DB2  60A0      5494          bra       HandleBreakPoint_1
                    5495   HandleBreakPoint_3:
                    5496   ; }
                    5497   ; }
                    5498   ; DumpRegisters() ;
00002DB4  4EB8 1F40 5499          jsr       _DumpRegisters
                    5500   ; printf("\r\nPress <SPACE> to Execute Next Instruction");
00002DB8  4879 0000 5501          pea       @m68kde~1_86.L
00002DBC  57C8      
00002DBE  4E93      5502          jsr       (A3)
00002DC0  584F      5503          addq.w    #4,A7
                    5504   ; printf("\r\nPress <ESC> to Resume User Program\r\n") ;
00002DC2  4879 0000 5505          pea       @m68kde~1_125.L
00002DC6  5C66      
00002DC8  4E93      5506          jsr       (A3)
00002DCA  584F      5507          addq.w    #4,A7
                    5508   ; menu() ;
00002DCC  4EB9 0000 5509          jsr       _menu
00002DD0  2FD8      
00002DD2  4CDF 1C00 5510          movem.l   (A7)+,A2/A3/A4
00002DD6  4E5E      5511          unlk      A6
00002DD8  4E75      5512          rts
                    5513   ; }
                    5514   ; void UnknownCommand()
                    5515   ; {
                    5516   _UnknownCommand:
                    5517   ; printf("\r\nUnknown Command.....\r\n") ;
00002DDA  4879 0000 5518          pea       @m68kde~1_126.L
00002DDE  5C8E      
00002DE0  4EB9 0000 5519          jsr       _printf
00002DE4  3A1C      
00002DE6  584F      5520          addq.w    #4,A7
                    5521   ; Help() ;
00002DE8  4EB9 0000 5522          jsr       _Help
00002DEC  2EFE      
00002DEE  4E75      5523          rts
                    5524   ; }
                    5525   ; // system when the users program executes a TRAP #15 instruction to halt program and return to debug monitor
                    5526   ; void CallDebugMonitor(void)
                    5527   ; {
                    5528   _CallDebugMonitor:
                    5529   ; printf("\r\nProgram Ended (TRAP #15)....") ;
00002DF0  4879 0000 5530          pea       @m68kde~1_127.L
00002DF4  5CA8      
00002DF6  4EB9 0000 5531          jsr       _printf
00002DFA  3A1C      
00002DFC  584F      5532          addq.w    #4,A7
                    5533   ; menu();
00002DFE  4EB9 0000 5534          jsr       _menu
00002E02  2FD8      
00002E04  4E75      5535          rts
                    5536   ; }
                    5537   ; void Breakpoint(void)
                    5538   ; {
                    5539   _Breakpoint:
00002E06  2F02      5540          move.l    D2,-(A7)
                    5541   ; char c;
                    5542   ; c = toupper(_getch());
00002E08  2F00      5543          move.l    D0,-(A7)
00002E0A  4EB8 0BBE 5544          jsr       __getch
00002E0E  2200      5545          move.l    D0,D1
00002E10  201F      5546          move.l    (A7)+,D0
00002E12  2F01      5547          move.l    D1,-(A7)
00002E14  4EB9 0000 5548          jsr       _toupper
00002E18  3C36      
00002E1A  584F      5549          addq.w    #4,A7
00002E1C  1400      5550          move.b    D0,D2
                    5551   ; if( c == (char)('D'))                                      // BreakPoint Display
00002E1E  0C02 0044 5552          cmp.b     #68,D2
00002E22  6608      5553          bne.s     Breakpoint_1
                    5554   ; BreakPointDisplay() ;
00002E24  4EB8 26EE 5555          jsr       _BreakPointDisplay
00002E28  6000 0054 5556          bra       Breakpoint_10
                    5557   Breakpoint_1:
                    5558   ; else if(c == (char)('K')) {                                 // breakpoint Kill
00002E2C  0C02 004B 5559          cmp.b     #75,D2
00002E30  6630      5560          bne.s     Breakpoint_3
                    5561   ; printf("\r\nKill All Break Points...(y/n)?") ;
00002E32  4879 0000 5562          pea       @m68kde~1_128.L
00002E36  5CC8      
00002E38  4EB9 0000 5563          jsr       _printf
00002E3C  3A1C      
00002E3E  584F      5564          addq.w    #4,A7
                    5565   ; c = toupper(_getch());
00002E40  2F00      5566          move.l    D0,-(A7)
00002E42  4EB8 0BBE 5567          jsr       __getch
00002E46  2200      5568          move.l    D0,D1
00002E48  201F      5569          move.l    (A7)+,D0
00002E4A  2F01      5570          move.l    D1,-(A7)
00002E4C  4EB9 0000 5571          jsr       _toupper
00002E50  3C36      
00002E52  584F      5572          addq.w    #4,A7
00002E54  1400      5573          move.b    D0,D2
                    5574   ; if(c == (char)('Y'))
00002E56  0C02 0059 5575          cmp.b     #89,D2
00002E5A  6604      5576          bne.s     Breakpoint_5
                    5577   ; KillAllBreakPoints() ;
00002E5C  4EB8 2A86 5578          jsr       _KillAllBreakPoints
                    5579   Breakpoint_5:
00002E60  601C      5580          bra.s     Breakpoint_10
                    5581   Breakpoint_3:
                    5582   ; }
                    5583   ; else if(c == (char)('S')) {
00002E62  0C02 0053 5584          cmp.b     #83,D2
00002E66  6606      5585          bne.s     Breakpoint_7
                    5586   ; SetBreakPoint() ;
00002E68  4EB8 2B1E 5587          jsr       _SetBreakPoint
00002E6C  6010      5588          bra.s     Breakpoint_10
                    5589   Breakpoint_7:
                    5590   ; }
                    5591   ; else if(c == (char)('C')) {
00002E6E  0C02 0043 5592          cmp.b     #67,D2
00002E72  6606      5593          bne.s     Breakpoint_9
                    5594   ; BreakPointClear() ;
00002E74  4EB8 286E 5595          jsr       _BreakPointClear
00002E78  6004      5596          bra.s     Breakpoint_10
                    5597   Breakpoint_9:
                    5598   ; }
                    5599   ; else
                    5600   ; UnknownCommand() ;
00002E7A  4EB8 2DDA 5601          jsr       _UnknownCommand
                    5602   Breakpoint_10:
00002E7E  241F      5603          move.l    (A7)+,D2
00002E80  4E75      5604          rts
                    5605   ; }
                    5606   ; void Watchpoint(void)
                    5607   ; {
                    5608   _Watchpoint:
00002E82  2F02      5609          move.l    D2,-(A7)
                    5610   ; char c;
                    5611   ; c = toupper(_getch());
00002E84  2F00      5612          move.l    D0,-(A7)
00002E86  4EB8 0BBE 5613          jsr       __getch
00002E8A  2200      5614          move.l    D0,D1
00002E8C  201F      5615          move.l    (A7)+,D0
00002E8E  2F01      5616          move.l    D1,-(A7)
00002E90  4EB9 0000 5617          jsr       _toupper
00002E94  3C36      
00002E96  584F      5618          addq.w    #4,A7
00002E98  1400      5619          move.b    D0,D2
                    5620   ; if( c == (char)('D'))                                      // WatchPoint Display
00002E9A  0C02 0044 5621          cmp.b     #68,D2
00002E9E  6608      5622          bne.s     Watchpoint_1
                    5623   ; WatchPointDisplay() ;
00002EA0  4EB8 27C2 5624          jsr       _WatchPointDisplay
00002EA4  6000 0054 5625          bra       Watchpoint_10
                    5626   Watchpoint_1:
                    5627   ; else if(c == (char)('K')) {                                 // wtahcpoint Kill
00002EA8  0C02 004B 5628          cmp.b     #75,D2
00002EAC  6630      5629          bne.s     Watchpoint_3
                    5630   ; printf("\r\nKill All Watch Points...(y/n)?") ;
00002EAE  4879 0000 5631          pea       @m68kde~1_129.L
00002EB2  5CEA      
00002EB4  4EB9 0000 5632          jsr       _printf
00002EB8  3A1C      
00002EBA  584F      5633          addq.w    #4,A7
                    5634   ; c = toupper(_getch());
00002EBC  2F00      5635          move.l    D0,-(A7)
00002EBE  4EB8 0BBE 5636          jsr       __getch
00002EC2  2200      5637          move.l    D0,D1
00002EC4  201F      5638          move.l    (A7)+,D0
00002EC6  2F01      5639          move.l    D1,-(A7)
00002EC8  4EB9 0000 5640          jsr       _toupper
00002ECC  3C36      
00002ECE  584F      5641          addq.w    #4,A7
00002ED0  1400      5642          move.b    D0,D2
                    5643   ; if(c == (char)('Y'))
00002ED2  0C02 0059 5644          cmp.b     #89,D2
00002ED6  6604      5645          bne.s     Watchpoint_5
                    5646   ; KillAllWatchPoints() ;
00002ED8  4EB8 2AEE 5647          jsr       _KillAllWatchPoints
                    5648   Watchpoint_5:
00002EDC  601C      5649          bra.s     Watchpoint_10
                    5650   Watchpoint_3:
                    5651   ; }
                    5652   ; else if(c == (char)('S')) {
00002EDE  0C02 0053 5653          cmp.b     #83,D2
00002EE2  6606      5654          bne.s     Watchpoint_7
                    5655   ; SetWatchPoint() ;
00002EE4  4EB8 2C3E 5656          jsr       _SetWatchPoint
00002EE8  6010      5657          bra.s     Watchpoint_10
                    5658   Watchpoint_7:
                    5659   ; }
                    5660   ; else if(c == (char)('C')) {
00002EEA  0C02 0043 5661          cmp.b     #67,D2
00002EEE  6606      5662          bne.s     Watchpoint_9
                    5663   ; WatchPointClear() ;
00002EF0  4EB8 2948 5664          jsr       _WatchPointClear
00002EF4  6004      5665          bra.s     Watchpoint_10
                    5666   Watchpoint_9:
                    5667   ; }
                    5668   ; else
                    5669   ; UnknownCommand() ;
00002EF6  4EB8 2DDA 5670          jsr       _UnknownCommand
                    5671   Watchpoint_10:
00002EFA  241F      5672          move.l    (A7)+,D2
00002EFC  4E75      5673          rts
                    5674   ; }
                    5675   ; void Help(void)
                    5676   ; {
                    5677   _Help:
00002EFE  48E7 2020 5678          movem.l   D2/A2,-(A7)
00002F02  45F9 0000 5679          lea       _printf.L,A2
00002F06  3A1C      
                    5680   ; char *banner = "\r\n----------------------------------------------------------------" ;
00002F08  41F9 0000 5681          lea       @m68kde~1_130.L,A0
00002F0C  5D0C      
00002F0E  2408      5682          move.l    A0,D2
                    5683   ; printf(banner) ;
00002F10  2F02      5684          move.l    D2,-(A7)
00002F12  4E92      5685          jsr       (A2)
00002F14  584F      5686          addq.w    #4,A7
                    5687   ; printf("\r\n  Debugger Command Summary") ;
00002F16  4879 0000 5688          pea       @m68kde~1_131.L
00002F1A  5D50      
00002F1C  4E92      5689          jsr       (A2)
00002F1E  584F      5690          addq.w    #4,A7
                    5691   ; printf(banner) ;
00002F20  2F02      5692          move.l    D2,-(A7)
00002F22  4E92      5693          jsr       (A2)
00002F24  584F      5694          addq.w    #4,A7
                    5695   ; printf("\r\n  .(reg)       - Change Registers: e.g A0-A7,D0-D7,PC,SSP,USP,SR");
00002F26  4879 0000 5696          pea       @m68kde~1_132.L
00002F2A  5D6E      
00002F2C  4E92      5697          jsr       (A2)
00002F2E  584F      5698          addq.w    #4,A7
                    5699   ; printf("\r\n  BD/BS/BC/BK  - Break Point: Display/Set/Clear/Kill") ;
00002F30  4879 0000 5700          pea       @m68kde~1_133.L
00002F34  5DB2      
00002F36  4E92      5701          jsr       (A2)
00002F38  584F      5702          addq.w    #4,A7
                    5703   ; printf("\r\n  C            - Copy Program from Flash to Main Memory") ;
00002F3A  4879 0000 5704          pea       @m68kde~1_134.L
00002F3E  5DEA      
00002F40  4E92      5705          jsr       (A2)
00002F42  584F      5706          addq.w    #4,A7
                    5707   ; printf("\r\n  D            - Dump Memory Contents to Screen") ;
00002F44  4879 0000 5708          pea       @m68kde~1_135.L
00002F48  5E24      
00002F4A  4E92      5709          jsr       (A2)
00002F4C  584F      5710          addq.w    #4,A7
                    5711   ; printf("\r\n  E            - Enter String into Memory") ;
00002F4E  4879 0000 5712          pea       @m68kde~1_136.L
00002F52  5E56      
00002F54  4E92      5713          jsr       (A2)
00002F56  584F      5714          addq.w    #4,A7
                    5715   ; printf("\r\n  F            - Fill Memory with Data") ;
00002F58  4879 0000 5716          pea       @m68kde~1_137.L
00002F5C  5E82      
00002F5E  4E92      5717          jsr       (A2)
00002F60  584F      5718          addq.w    #4,A7
                    5719   ; printf("\r\n  G            - Go Program Starting at Address: $%08X", PC) ;
00002F62  2F39 0B00 5720          move.l    _PC.L,-(A7)
00002F66  0120      
00002F68  4879 0000 5721          pea       @m68kde~1_138.L
00002F6C  5EAC      
00002F6E  4E92      5722          jsr       (A2)
00002F70  504F      5723          addq.w    #8,A7
                    5724   ; printf("\r\n  L            - Load Program (.HEX file) from Laptop") ;
00002F72  4879 0000 5725          pea       @m68kde~1_139.L
00002F76  5EE6      
00002F78  4E92      5726          jsr       (A2)
00002F7A  584F      5727          addq.w    #4,A7
                    5728   ; printf("\r\n  M            - Memory Examine and Change");
00002F7C  4879 0000 5729          pea       @m68kde~1_140.L
00002F80  5F1E      
00002F82  4E92      5730          jsr       (A2)
00002F84  584F      5731          addq.w    #4,A7
                    5732   ; printf("\r\n  P            - Program Flash Memory with User Program") ;
00002F86  4879 0000 5733          pea       @m68kde~1_141.L
00002F8A  5F4C      
00002F8C  4E92      5734          jsr       (A2)
00002F8E  584F      5735          addq.w    #4,A7
                    5736   ; printf("\r\n  R            - Display 68000 Registers") ;
00002F90  4879 0000 5737          pea       @m68kde~1_142.L
00002F94  5F86      
00002F96  4E92      5738          jsr       (A2)
00002F98  584F      5739          addq.w    #4,A7
                    5740   ; printf("\r\n  S            - Toggle ON/OFF Single Step Mode") ;
00002F9A  4879 0000 5741          pea       @m68kde~1_143.L
00002F9E  5FB2      
00002FA0  4E92      5742          jsr       (A2)
00002FA2  584F      5743          addq.w    #4,A7
                    5744   ; printf("\r\n  TM           - Test Memory") ;
00002FA4  4879 0000 5745          pea       @m68kde~1_144.L
00002FA8  5FE4      
00002FAA  4E92      5746          jsr       (A2)
00002FAC  584F      5747          addq.w    #4,A7
                    5748   ; printf("\r\n  TS           - Test Switches: SW7-0") ;
00002FAE  4879 0000 5749          pea       @m68kde~1_145.L
00002FB2  6004      
00002FB4  4E92      5750          jsr       (A2)
00002FB6  584F      5751          addq.w    #4,A7
                    5752   ; printf("\r\n  TD           - Test Displays: LEDs and 7-Segment") ;
00002FB8  4879 0000 5753          pea       @m68kde~1_146.L
00002FBC  602C      
00002FBE  4E92      5754          jsr       (A2)
00002FC0  584F      5755          addq.w    #4,A7
                    5756   ; printf("\r\n  WD/WS/WC/WK  - Watch Point: Display/Set/Clear/Kill") ;
00002FC2  4879 0000 5757          pea       @m68kde~1_147.L
00002FC6  6062      
00002FC8  4E92      5758          jsr       (A2)
00002FCA  584F      5759          addq.w    #4,A7
                    5760   ; printf(banner) ;
00002FCC  2F02      5761          move.l    D2,-(A7)
00002FCE  4E92      5762          jsr       (A2)
00002FD0  584F      5763          addq.w    #4,A7
00002FD2  4CDF 0404 5764          movem.l   (A7)+,D2/A2
00002FD6  4E75      5765          rts
                    5766   ; }
                    5767   ; void menu(void)
                    5768   ; {
                    5769   _menu:
00002FD8  48E7 303C 5770          movem.l   D2/D3/A2/A3/A4/A5,-(A7)
00002FDC  45F9 0000 5771          lea       _printf.L,A2
00002FE0  3A1C      
00002FE2  47F9 0B00 5772          lea       _Trace.L,A3
00002FE6  00D8      
00002FE8  49F9 0B00 5773          lea       _x.L,A4
00002FEC  00C8      
00002FEE  4BF9 0B00 5774          lea       _SR.L,A5
00002FF2  012C      
                    5775   ; char c,c1 ;
                    5776   ; while(1)    {
                    5777   menu_1:
                    5778   ; FlushKeyboard() ;               // dump unread characters from keyboard
00002FF4  4EB8 0BFC 5779          jsr       _FlushKeyboard
                    5780   ; printf("\r\n#") ;
00002FF8  4879 0000 5781          pea       @m68kde~1_148.L
00002FFC  609A      
00002FFE  4E92      5782          jsr       (A2)
00003000  584F      5783          addq.w    #4,A7
                    5784   ; c = toupper(_getch());
00003002  2F00      5785          move.l    D0,-(A7)
00003004  4EB8 0BBE 5786          jsr       __getch
00003008  2200      5787          move.l    D0,D1
0000300A  201F      5788          move.l    (A7)+,D0
0000300C  2F01      5789          move.l    D1,-(A7)
0000300E  4EB9 0000 5790          jsr       _toupper
00003012  3C36      
00003014  584F      5791          addq.w    #4,A7
00003016  1400      5792          move.b    D0,D2
                    5793   ; if( c == (char)('L'))                  // load s record file
00003018  0C02 004C 5794          cmp.b     #76,D2
0000301C  6608      5795          bne.s     menu_4
                    5796   ; Load_SRecordFile() ;
0000301E  4EB8 0E8C 5797          jsr       _Load_SRecordFile
00003022  6000 023A 5798          bra       menu_50
                    5799   menu_4:
                    5800   ; else if( c == (char)('D'))             // dump memory
00003026  0C02 0044 5801          cmp.b     #68,D2
0000302A  6608      5802          bne.s     menu_6
                    5803   ; DumpMemory() ;
0000302C  4EB8 0D22 5804          jsr       _DumpMemory
00003030  6000 022C 5805          bra       menu_50
                    5806   menu_6:
                    5807   ; else if( c == (char)('E'))             // Enter String into memory
00003034  0C02 0045 5808          cmp.b     #69,D2
00003038  660A      5809          bne.s     menu_8
                    5810   ; EnterString() ;
0000303A  4EB9 0000 5811          jsr       _EnterString
0000303E  33A6      
00003040  6000 021C 5812          bra       menu_50
                    5813   menu_8:
                    5814   ; else if( c == (char)('F'))             // fill memory
00003044  0C02 0046 5815          cmp.b     #70,D2
00003048  6608      5816          bne.s     menu_10
                    5817   ; FillMemory() ;
0000304A  4EB8 0E12 5818          jsr       _FillMemory
0000304E  6000 020E 5819          bra       menu_50
                    5820   menu_10:
                    5821   ; else if( c == (char)('G'))  {           // go user program
00003052  0C02 0047 5822          cmp.b     #71,D2
00003056  6626      5823          bne.s     menu_12
                    5824   ; printf("\r\nProgram Running.....") ;
00003058  4879 0000 5825          pea       @m68kde~1_149.L
0000305C  609E      
0000305E  4E92      5826          jsr       (A2)
00003060  584F      5827          addq.w    #4,A7
                    5828   ; printf("\r\nPress <RESET> button <Key0> on DE1 to stop") ;
00003062  4879 0000 5829          pea       @m68kde~1_150.L
00003066  60B6      
00003068  4E92      5830          jsr       (A2)
0000306A  584F      5831          addq.w    #4,A7
                    5832   ; GoFlag = 1 ;
0000306C  23FC 0000 5833          move.l    #1,_GoFlag.L
00003070  0001 0B00 
00003074  00DC      
                    5834   ; go() ;
00003076  4EB8 08B8 5835          jsr       _go
0000307A  6000 01E2 5836          bra       menu_50
                    5837   menu_12:
                    5838   ; }
                    5839   ; else if( c == (char)('M'))           // memory examine and modify
0000307E  0C02 004D 5840          cmp.b     #77,D2
00003082  6608      5841          bne.s     menu_14
                    5842   ; MemoryChange() ;
00003084  4EB8 101A 5843          jsr       _MemoryChange
00003088  6000 01D4 5844          bra       menu_50
                    5845   menu_14:
                    5846   ; else if( c == (char)('I'))           //I2Ctest()
0000308C  0C02 0049 5847          cmp.b     #73,D2
00003090  6608      5848          bne.s     menu_16
                    5849   ; I2CTest(); 
00003092  4EB8 1AAC 5850          jsr       _I2CTest
00003096  6000 01C6 5851          bra       menu_50
                    5852   menu_16:
                    5853   ; else if( c == (char)('W'))           // DAC test
0000309A  0C02 0057 5854          cmp.b     #87,D2
0000309E  6608      5855          bne.s     menu_18
                    5856   ; DACWave();
000030A0  4EB8 1E90 5857          jsr       _DACWave
000030A4  6000 01B8 5858          bra       menu_50
                    5859   menu_18:
                    5860   ; else if( c == (char)('P'))            // Program Flash Chip
000030A8  0C02 0050 5861          cmp.b     #80,D2
000030AC  6608      5862          bne.s     menu_20
                    5863   ; ProgramFlashChip() ;
000030AE  4EB8 13BE 5864          jsr       _ProgramFlashChip
000030B2  6000 01AA 5865          bra       menu_50
                    5866   menu_20:
                    5867   ; else if( c == (char)('C'))             // copy flash chip to ram and go
000030B6  0C02 0043 5868          cmp.b     #67,D2
000030BA  6608      5869          bne.s     menu_22
                    5870   ; LoadFromFlashChip();
000030BC  4EB8 13E0 5871          jsr       _LoadFromFlashChip
000030C0  6000 019C 5872          bra       menu_50
                    5873   menu_22:
                    5874   ; else if( c == (char)('R'))             // dump registers
000030C4  0C02 0052 5875          cmp.b     #82,D2
000030C8  6608      5876          bne.s     menu_24
                    5877   ; DumpRegisters() ;
000030CA  4EB8 1F40 5878          jsr       _DumpRegisters
000030CE  6000 018E 5879          bra       menu_50
                    5880   menu_24:
                    5881   ; else if( c == (char)('.'))           // change registers
000030D2  0C02 002E 5882          cmp.b     #46,D2
000030D6  6608      5883          bne.s     menu_26
                    5884   ; ChangeRegisters() ;
000030D8  4EB8 2432 5885          jsr       _ChangeRegisters
000030DC  6000 0180 5886          bra       menu_50
                    5887   menu_26:
                    5888   ; else if( c == (char)('B'))              // breakpoint command
000030E0  0C02 0042 5889          cmp.b     #66,D2
000030E4  6608      5890          bne.s     menu_28
                    5891   ; Breakpoint() ;
000030E6  4EB8 2E06 5892          jsr       _Breakpoint
000030EA  6000 0172 5893          bra       menu_50
                    5894   menu_28:
                    5895   ; else if( c == (char)('T'))  {          // Test command
000030EE  0C02 0054 5896          cmp.b     #84,D2
000030F2  6600 0046 5897          bne       menu_30
                    5898   ; c1 = toupper(_getch()) ;
000030F6  2F00      5899          move.l    D0,-(A7)
000030F8  4EB8 0BBE 5900          jsr       __getch
000030FC  2200      5901          move.l    D0,D1
000030FE  201F      5902          move.l    (A7)+,D0
00003100  2F01      5903          move.l    D1,-(A7)
00003102  4EB9 0000 5904          jsr       _toupper
00003106  3C36      
00003108  584F      5905          addq.w    #4,A7
0000310A  1600      5906          move.b    D0,D3
                    5907   ; if(c1 == (char)('M'))                    // memory test
0000310C  0C03 004D 5908          cmp.b     #77,D3
00003110  6608      5909          bne.s     menu_32
                    5910   ; MemoryTest() ;
00003112  4EB9 0000 5911          jsr       _MemoryTest
00003116  341E      
00003118  601C      5912          bra.s     menu_37
                    5913   menu_32:
                    5914   ; else if( c1 == (char)('S'))              // Switch Test command
0000311A  0C03 0053 5915          cmp.b     #83,D3
0000311E  6606      5916          bne.s     menu_34
                    5917   ; SwitchTest() ;
00003120  4EB8 0AFA 5918          jsr       _SwitchTest
00003124  6010      5919          bra.s     menu_37
                    5920   menu_34:
                    5921   ; else if( c1 == (char)('D'))              // display Test command
00003126  0C03 0044 5922          cmp.b     #68,D3
0000312A  6606      5923          bne.s     menu_36
                    5924   ; TestLEDS() ;
0000312C  4EB8 0AA6 5925          jsr       _TestLEDS
00003130  6004      5926          bra.s     menu_37
                    5927   menu_36:
                    5928   ; else
                    5929   ; UnknownCommand() ;
00003132  4EB8 2DDA 5930          jsr       _UnknownCommand
                    5931   menu_37:
00003136  6000 0126 5932          bra       menu_50
                    5933   menu_30:
                    5934   ; }
                    5935   ; else if( c == (char)(' ')) {             // Next instruction command
0000313A  0C02 0020 5936          cmp.b     #32,D2
0000313E  6636      5937          bne.s     menu_38
                    5938   ; DisableBreakPoints() ;
00003140  4EB8 29EA 5939          jsr       _DisableBreakPoints
                    5940   ; if(Trace == 1 && GoFlag == 1)   {    // if the program is running and trace mode on then 'N' is valid
00003144  2013      5941          move.l    (A3),D0
00003146  0C80 0000 5942          cmp.l     #1,D0
0000314A  0001      
0000314C  661A      5943          bne.s     menu_40
0000314E  2039 0B00 5944          move.l    _GoFlag.L,D0
00003152  00DC      
00003154  0C80 0000 5945          cmp.l     #1,D0
00003158  0001      
0000315A  660C      5946          bne.s     menu_40
                    5947   ; TraceException = 1 ;             // generate a trace exception for the next instruction if user wants to single step though next instruction
0000315C  13FC 0001 5948          move.b    #1,4194314
00003160  0040 000A 
                    5949   ; return ;
00003164  6000 00FC 5950          bra       menu_42
                    5951   menu_40:
                    5952   ; }
                    5953   ; else
                    5954   ; printf("\r\nError: Press 'G' first to start program") ;
00003168  4879 0000 5955          pea       @m68kde~1_151.L
0000316C  60E4      
0000316E  4E92      5956          jsr       (A2)
00003170  584F      5957          addq.w    #4,A7
00003172  6000 00EA 5958          bra       menu_50
                    5959   menu_38:
                    5960   ; }
                    5961   ; else if( c == (char)('S')) {             // single step
00003176  0C02 0053 5962          cmp.b     #83,D2
0000317A  6600 008C 5963          bne       menu_43
                    5964   ; if(Trace == 0) {
0000317E  2013      5965          move.l    (A3),D0
00003180  6600 0050 5966          bne       menu_45
                    5967   ; DisableBreakPoints() ;
00003184  4EB8 29EA 5968          jsr       _DisableBreakPoints
                    5969   ; printf("\r\nSingle Step  :[ON]") ;
00003188  4879 0000 5970          pea       @m68kde~1_152.L
0000318C  610E      
0000318E  4E92      5971          jsr       (A2)
00003190  584F      5972          addq.w    #4,A7
                    5973   ; printf("\r\nBreak Points :[Disabled]") ;
00003192  4879 0000 5974          pea       @m68kde~1_85.L
00003196  57AC      
00003198  4E92      5975          jsr       (A2)
0000319A  584F      5976          addq.w    #4,A7
                    5977   ; SR = SR | (unsigned short int)(0x8000) ;    // set T bit in status register
0000319C  0055 8000 5978          or.w      #32768,(A5)
                    5979   ; printf("\r\nPress 'G' to Trace Program from address $%X.....",PC) ;
000031A0  2F39 0B00 5980          move.l    _PC.L,-(A7)
000031A4  0120      
000031A6  4879 0000 5981          pea       @m68kde~1_153.L
000031AA  6124      
000031AC  4E92      5982          jsr       (A2)
000031AE  504F      5983          addq.w    #8,A7
                    5984   ; printf("\r\nPush <RESET Button> to Stop.....") ;
000031B0  4879 0000 5985          pea       @m68kde~1_154.L
000031B4  6158      
000031B6  4E92      5986          jsr       (A2)
000031B8  584F      5987          addq.w    #4,A7
                    5988   ; DumpRegisters() ;
000031BA  4EB8 1F40 5989          jsr       _DumpRegisters
                    5990   ; Trace = 1;
000031BE  26BC 0000 5991          move.l    #1,(A3)
000031C2  0001      
                    5992   ; TraceException = 1;
000031C4  13FC 0001 5993          move.b    #1,4194314
000031C8  0040 000A 
                    5994   ; x = *(unsigned int *)(0x00000074) ;       // simulate responding to a Level 5 IRQ by reading vector to reset Trace exception generator
000031CC  28B8 0074 5995          move.l    116,(A4)
000031D0  6032      5996          bra.s     menu_46
                    5997   menu_45:
                    5998   ; }
                    5999   ; else {
                    6000   ; Trace = 0 ;
000031D2  4293      6001          clr.l     (A3)
                    6002   ; TraceException = 0 ;
000031D4  4239 0040 6003          clr.b     4194314
000031D8  000A      
                    6004   ; x = *(unsigned int *)(0x00000074) ;       // simulate responding to a Level 5 IRQ by reading vector to reset Trace exception generator
000031DA  28B8 0074 6005          move.l    116,(A4)
                    6006   ; EnableBreakPoints() ;
000031DE  4EB8 2A3E 6007          jsr       _EnableBreakPoints
                    6008   ; SR = SR & (unsigned short int)(0x7FFF) ;    // clear T bit in status register
000031E2  0255 7FFF 6009          and.w     #32767,(A5)
                    6010   ; printf("\r\nSingle Step : [OFF]") ;
000031E6  4879 0000 6011          pea       @m68kde~1_155.L
000031EA  617C      
000031EC  4E92      6012          jsr       (A2)
000031EE  584F      6013          addq.w    #4,A7
                    6014   ; printf("\r\nBreak Points :[Enabled]") ;
000031F0  4879 0000 6015          pea       @m68kde~1_156.L
000031F4  6192      
000031F6  4E92      6016          jsr       (A2)
000031F8  584F      6017          addq.w    #4,A7
                    6018   ; printf("\r\nPress <ESC> to Resume User Program.....") ;
000031FA  4879 0000 6019          pea       @m68kde~1_157.L
000031FE  61AC      
00003200  4E92      6020          jsr       (A2)
00003202  584F      6021          addq.w    #4,A7
                    6022   menu_46:
00003204  6000 0058 6023          bra       menu_50
                    6024   menu_43:
                    6025   ; }
                    6026   ; }
                    6027   ; else if(c == (char)(0x1b))  {   // if user choses to end trace and run program
00003208  0C02 001B 6028          cmp.b     #27,D2
0000320C  6600 0040 6029          bne       menu_47
                    6030   ; Trace = 0;
00003210  4293      6031          clr.l     (A3)
                    6032   ; TraceException = 0;
00003212  4239 0040 6033          clr.b     4194314
00003216  000A      
                    6034   ; x = *(unsigned int *)(0x00000074) ;   // read IRQ 5 vector to reset trace vector generator
00003218  28B8 0074 6035          move.l    116,(A4)
                    6036   ; EnableBreakPoints() ;
0000321C  4EB8 2A3E 6037          jsr       _EnableBreakPoints
                    6038   ; SR = SR & (unsigned short int)(0x7FFF) ;    // clear T bit in status register
00003220  0255 7FFF 6039          and.w     #32767,(A5)
                    6040   ; printf("\r\nSingle Step  :[OFF]") ;
00003224  4879 0000 6041          pea       @m68kde~1_158.L
00003228  61D6      
0000322A  4E92      6042          jsr       (A2)
0000322C  584F      6043          addq.w    #4,A7
                    6044   ; printf("\r\nBreak Points :[Enabled]");
0000322E  4879 0000 6045          pea       @m68kde~1_156.L
00003232  6192      
00003234  4E92      6046          jsr       (A2)
00003236  584F      6047          addq.w    #4,A7
                    6048   ; printf("\r\nProgram Running.....") ;
00003238  4879 0000 6049          pea       @m68kde~1_149.L
0000323C  609E      
0000323E  4E92      6050          jsr       (A2)
00003240  584F      6051          addq.w    #4,A7
                    6052   ; printf("\r\nPress <RESET> button <Key0> on DE1 to stop") ;
00003242  4879 0000 6053          pea       @m68kde~1_150.L
00003246  60B6      
00003248  4E92      6054          jsr       (A2)
0000324A  584F      6055          addq.w    #4,A7
                    6056   ; return ;
0000324C  6014      6057          bra.s     menu_42
                    6058   menu_47:
                    6059   ; }
                    6060   ; else if( c == (char)('W'))              // Watchpoint command
0000324E  0C02 0057 6061          cmp.b     #87,D2
00003252  6606      6062          bne.s     menu_49
                    6063   ; Watchpoint() ;
00003254  4EB8 2E82 6064          jsr       _Watchpoint
00003258  6004      6065          bra.s     menu_50
                    6066   menu_49:
                    6067   ; else
                    6068   ; UnknownCommand() ;
0000325A  4EB8 2DDA 6069          jsr       _UnknownCommand
                    6070   menu_50:
0000325E  6000 FD94 6071          bra       menu_1
                    6072   menu_42:
00003262  4CDF 3C0C 6073          movem.l   (A7)+,D2/D3/A2/A3/A4/A5
00003266  4E75      6074          rts
                    6075   ; }
                    6076   ; }
                    6077   ; void PrintErrorMessageandAbort(char *string) {
                    6078   _PrintErrorMessageandAbort:
00003268  4E56 0000 6079          link      A6,#0
                    6080   ; printf("\r\n\r\nProgram ABORT !!!!!!\r\n") ;
0000326C  4879 0000 6081          pea       @m68kde~1_159.L
00003270  61EC      
00003272  4EB9 0000 6082          jsr       _printf
00003276  3A1C      
00003278  584F      6083          addq.w    #4,A7
                    6084   ; printf("%s\r\n", string) ;
0000327A  2F2E 0008 6085          move.l    8(A6),-(A7)
0000327E  4879 0000 6086          pea       @m68kde~1_160.L
00003282  6208      
00003284  4EB9 0000 6087          jsr       _printf
00003288  3A1C      
0000328A  504F      6088          addq.w    #8,A7
                    6089   ; menu() ;
0000328C  4EB8 2FD8 6090          jsr       _menu
00003290  4E5E      6091          unlk      A6
00003292  4E75      6092          rts
                    6093   ; }
                    6094   ; void IRQMessage(int level) {
                    6095   _IRQMessage:
00003294  4E56 0000 6096          link      A6,#0
                    6097   ; printf("\r\n\r\nProgram ABORT !!!!!");
00003298  4879 0000 6098          pea       @m68kde~1_161.L
0000329C  620E      
0000329E  4EB9 0000 6099          jsr       _printf
000032A2  3A1C      
000032A4  584F      6100          addq.w    #4,A7
                    6101   ; printf("\r\nUnhandled Interrupt: IRQ%d !!!!!", level) ;
000032A6  2F2E 0008 6102          move.l    8(A6),-(A7)
000032AA  4879 0000 6103          pea       @m68kde~1_162.L
000032AE  6226      
000032B0  4EB9 0000 6104          jsr       _printf
000032B4  3A1C      
000032B6  504F      6105          addq.w    #8,A7
                    6106   ; menu() ;
000032B8  4EB8 2FD8 6107          jsr       _menu
000032BC  4E5E      6108          unlk      A6
000032BE  4E75      6109          rts
                    6110   ; }
                    6111   ; void UnhandledIRQ1(void) {
                    6112   _UnhandledIRQ1:
                    6113   ; IRQMessage(1);
000032C0  4878 0001 6114          pea       1
000032C4  4EB8 3294 6115          jsr       _IRQMessage
000032C8  584F      6116          addq.w    #4,A7
000032CA  4E75      6117          rts
                    6118   ; }
                    6119   ; void UnhandledIRQ2(void) {
                    6120   _UnhandledIRQ2:
                    6121   ; IRQMessage(2);
000032CC  4878 0002 6122          pea       2
000032D0  4EB8 3294 6123          jsr       _IRQMessage
000032D4  584F      6124          addq.w    #4,A7
000032D6  4E75      6125          rts
                    6126   ; }
                    6127   ; void UnhandledIRQ3(void){
                    6128   _UnhandledIRQ3:
                    6129   ; IRQMessage(3);
000032D8  4878 0003 6130          pea       3
000032DC  4EB8 3294 6131          jsr       _IRQMessage
000032E0  584F      6132          addq.w    #4,A7
000032E2  4E75      6133          rts
                    6134   ; }
                    6135   ; void UnhandledIRQ4(void) {
                    6136   _UnhandledIRQ4:
                    6137   ; IRQMessage(4);
000032E4  4878 0004 6138          pea       4
000032E8  4EB8 3294 6139          jsr       _IRQMessage
000032EC  584F      6140          addq.w    #4,A7
000032EE  4E75      6141          rts
                    6142   ; }
                    6143   ; void UnhandledIRQ5(void) {
                    6144   _UnhandledIRQ5:
                    6145   ; IRQMessage(5);
000032F0  4878 0005 6146          pea       5
000032F4  4EB8 3294 6147          jsr       _IRQMessage
000032F8  584F      6148          addq.w    #4,A7
000032FA  4E75      6149          rts
                    6150   ; }
                    6151   ; void UnhandledIRQ6(void) {
                    6152   _UnhandledIRQ6:
                    6153   ; PrintErrorMessageandAbort("ADDRESS ERROR: 16 or 32 Bit Transfer to/from an ODD Address....") ;
000032FC  4879 0000 6154          pea       @m68kde~1_163.L
00003300  624A      
00003302  4EB8 3268 6155          jsr       _PrintErrorMessageandAbort
00003306  584F      6156          addq.w    #4,A7
                    6157   ; menu() ;
00003308  4EB8 2FD8 6158          jsr       _menu
0000330C  4E75      6159          rts
                    6160   ; }
                    6161   ; void UnhandledIRQ7(void) {
                    6162   _UnhandledIRQ7:
                    6163   ; IRQMessage(7);
0000330E  4878 0007 6164          pea       7
00003312  4EB8 3294 6165          jsr       _IRQMessage
00003316  584F      6166          addq.w    #4,A7
00003318  4E75      6167          rts
                    6168   ; }
                    6169   ; void UnhandledTrap(void) {
                    6170   _UnhandledTrap:
                    6171   ; PrintErrorMessageandAbort("Unhandled Trap !!!!!") ;
0000331A  4879 0000 6172          pea       @m68kde~1_164.L
0000331E  628A      
00003320  4EB8 3268 6173          jsr       _PrintErrorMessageandAbort
00003324  584F      6174          addq.w    #4,A7
00003326  4E75      6175          rts
                    6176   ; }
                    6177   ; void BusError() {
                    6178   _BusError:
                    6179   ; PrintErrorMessageandAbort("BUS Error!") ;
00003328  4879 0000 6180          pea       @m68kde~1_165.L
0000332C  62A0      
0000332E  4EB8 3268 6181          jsr       _PrintErrorMessageandAbort
00003332  584F      6182          addq.w    #4,A7
00003334  4E75      6183          rts
                    6184   ; }
                    6185   ; void AddressError() {
                    6186   _AddressError:
                    6187   ; PrintErrorMessageandAbort("ADDRESS Error!") ;
00003336  4879 0000 6188          pea       @m68kde~1_166.L
0000333A  62AC      
0000333C  4EB8 3268 6189          jsr       _PrintErrorMessageandAbort
00003340  584F      6190          addq.w    #4,A7
00003342  4E75      6191          rts
                    6192   ; }
                    6193   ; void IllegalInstruction() {
                    6194   _IllegalInstruction:
                    6195   ; PrintErrorMessageandAbort("ILLEGAL INSTRUCTION") ;
00003344  4879 0000 6196          pea       @m68kde~1_167.L
00003348  62BC      
0000334A  4EB8 3268 6197          jsr       _PrintErrorMessageandAbort
0000334E  584F      6198          addq.w    #4,A7
00003350  4E75      6199          rts
                    6200   ; }
                    6201   ; void Dividebyzero() {
                    6202   _Dividebyzero:
                    6203   ; PrintErrorMessageandAbort("DIVIDE BY ZERO") ;
00003352  4879 0000 6204          pea       @m68kde~1_168.L
00003356  62D0      
00003358  4EB8 3268 6205          jsr       _PrintErrorMessageandAbort
0000335C  584F      6206          addq.w    #4,A7
0000335E  4E75      6207          rts
                    6208   ; }
                    6209   ; void Check() {
                    6210   _Check:
                    6211   ; PrintErrorMessageandAbort("'CHK' INSTRUCTION") ;
00003360  4879 0000 6212          pea       @m68kde~1_169.L
00003364  62E0      
00003366  4EB8 3268 6213          jsr       _PrintErrorMessageandAbort
0000336A  584F      6214          addq.w    #4,A7
0000336C  4E75      6215          rts
                    6216   ; }
                    6217   ; void Trapv() {
                    6218   _Trapv:
                    6219   ; PrintErrorMessageandAbort("TRAPV INSTRUCTION") ;
0000336E  4879 0000 6220          pea       @m68kde~1_170.L
00003372  62F2      
00003374  4EB8 3268 6221          jsr       _PrintErrorMessageandAbort
00003378  584F      6222          addq.w    #4,A7
0000337A  4E75      6223          rts
                    6224   ; }
                    6225   ; void PrivError() {
                    6226   _PrivError:
                    6227   ; PrintErrorMessageandAbort("PRIVILEGE VIOLATION") ;
0000337C  4879 0000 6228          pea       @m68kde~1_171.L
00003380  6304      
00003382  4EB8 3268 6229          jsr       _PrintErrorMessageandAbort
00003386  584F      6230          addq.w    #4,A7
00003388  4E75      6231          rts
                    6232   ; }
                    6233   ; void UnitIRQ() {
                    6234   _UnitIRQ:
                    6235   ; PrintErrorMessageandAbort("UNINITIALISED IRQ") ;
0000338A  4879 0000 6236          pea       @m68kde~1_172.L
0000338E  6318      
00003390  4EB8 3268 6237          jsr       _PrintErrorMessageandAbort
00003394  584F      6238          addq.w    #4,A7
00003396  4E75      6239          rts
                    6240   ; }
                    6241   ; void Spurious() {
                    6242   _Spurious:
                    6243   ; PrintErrorMessageandAbort("SPURIOUS IRQ") ;
00003398  4879 0000 6244          pea       @m68kde~1_173.L
0000339C  632A      
0000339E  4EB8 3268 6245          jsr       _PrintErrorMessageandAbort
000033A2  584F      6246          addq.w    #4,A7
000033A4  4E75      6247          rts
                    6248   ; }
                    6249   ; void EnterString(void)
                    6250   ; {
                    6251   _EnterString:
000033A6  4E56 FFFC 6252          link      A6,#-4
000033AA  2F02      6253          move.l    D2,-(A7)
                    6254   ; unsigned char *Start;
                    6255   ; unsigned char c;
                    6256   ; printf("\r\nStart Address in Memory: ") ;
000033AC  4879 0000 6257          pea       @m68kde~1_174.L
000033B0  6338      
000033B2  4EB9 0000 6258          jsr       _printf
000033B6  3A1C      
000033B8  584F      6259          addq.w    #4,A7
                    6260   ; Start = Get8HexDigits(0) ;
000033BA  42A7      6261          clr.l     -(A7)
000033BC  4EB8 0CFA 6262          jsr       _Get8HexDigits
000033C0  584F      6263          addq.w    #4,A7
000033C2  2400      6264          move.l    D0,D2
                    6265   ; printf("\r\nEnter String (ESC to end) :") ;
000033C4  4879 0000 6266          pea       @m68kde~1_175.L
000033C8  6354      
000033CA  4EB9 0000 6267          jsr       _printf
000033CE  3A1C      
000033D0  584F      6268          addq.w    #4,A7
                    6269   ; while((c = getchar()) != 0x1b)
                    6270   EnterString_1:
000033D2  4EB9 0000 6271          jsr       _getch
000033D6  3B6C      
000033D8  1D40 FFFF 6272          move.b    D0,-1(A6)
000033DC  0C00 001B 6273          cmp.b     #27,D0
000033E0  670A      6274          beq.s     EnterString_3
                    6275   ; *Start++ = c ;
000033E2  2042      6276          move.l    D2,A0
000033E4  5282      6277          addq.l    #1,D2
000033E6  10AE FFFF 6278          move.b    -1(A6),(A0)
000033EA  60E6      6279          bra       EnterString_1
                    6280   EnterString_3:
                    6281   ; *Start = 0x00;  // terminate with a null
000033EC  2042      6282          move.l    D2,A0
000033EE  4210      6283          clr.b     (A0)
000033F0  241F      6284          move.l    (A7)+,D2
000033F2  4E5E      6285          unlk      A6
000033F4  4E75      6286          rts
                    6287   ; }
                    6288   ; // Sourced from this stack overflow post: https://stackoverflow.com/questions/7898215/how-can-i-clear-an-input-buffer-in-c
                    6289   ; void clearInputBuffer() {
                    6290   _clearInputBuffer:
000033F6  4E56 FFFC 6291          link      A6,#-4
                    6292   ; int c;
                    6293   ; while ((c = getchar()) != '\n' && c != EOF);
                    6294   clearInputBuffer_1:
000033FA  4EB9 0000 6295          jsr       _getch
000033FE  3B6C      
00003400  2D40 FFFC 6296          move.l    D0,-4(A6)
00003404  0C80 0000 6297          cmp.l     #10,D0
00003408  000A      
0000340A  670E      6298          beq.s     clearInputBuffer_3
0000340C  202E FFFC 6299          move.l    -4(A6),D0
00003410  0C80 FFFF 6300          cmp.l     #-1,D0
00003414  FFFF      
00003416  6702      6301          beq.s     clearInputBuffer_3
00003418  60E0      6302          bra       clearInputBuffer_1
                    6303   clearInputBuffer_3:
0000341A  4E5E      6304          unlk      A6
0000341C  4E75      6305          rts
                    6306   ; }
                    6307   ; void MemoryTest(void)
                    6308   ; {
                    6309   _MemoryTest:
0000341E  4E56 FF40 6310          link      A6,#-192
00003422  48E7 3F3C 6311          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
00003426  45F9 0000 6312          lea       _printf.L,A2
0000342A  3A1C      
0000342C  4BF8 0BBE 6313          lea       __getch.L,A5
                    6314   ; unsigned int *RamPtr, counter1=1 ;
00003430  2D7C 0000 6315          move.l    #1,-188(A6)
00003434  0001 FF44 
                    6316   ; register unsigned int i ;
                    6317   ; unsigned int Start, End ;
                    6318   ; char c, text[150];
                    6319   ; unsigned int* addressPointer;
                    6320   ; unsigned int startAddress = NULL;
00003438  42AE FFF0 6321          clr.l     -16(A6)
                    6322   ; unsigned int endAddress = NULL;
0000343C  42AE FFF4 6323          clr.l     -12(A6)
                    6324   ; unsigned int byteLength;
                    6325   ; unsigned int dataSize = 0;
00003440  4285      6326          clr.l     D5
                    6327   ; unsigned int dataPattern = 0;
00003442  4283      6328          clr.l     D3
                    6329   ; unsigned int currAddress;
                    6330   ; unsigned int addrCount;
                    6331   ; unsigned int intBuffer = NULL;
00003444  7E00      6332          moveq     #0,D7
                    6333   ; unsigned char *startAddressPtr = NULL;
00003446  4282      6334          clr.l     D2
                    6335   ; unsigned char *endAddressPtr = NULL;
00003448  4286      6336          clr.l     D6
                    6337   ; unsigned short int *wordAddressPtr = NULL;
0000344A  387C 0000 6338          move.w    #0,A4
                    6339   ; unsigned int *longAddressPtr = NULL;
0000344E  367C 0000 6340          move.w    #0,A3
                    6341   ; // IMPROVEMENTS TO BE MADE:
                    6342   ; // Suppossed to be able to write an odd address as a byte
                    6343   ; // We should be blocking certian thresholds from getting written according to SRAM and DRAM reqs. 
                    6344   ; // printf("\r\nStart Address: ") ;
                    6345   ; // Start = Get8HexDigits(0) ;
                    6346   ; // printf("\r\nEnd Address: ") ;
                    6347   ; // End = Get8HexDigits(0) ;
                    6348   ; // TODO
                    6349   ; scanflush();
00003452  4EB9 0000 6350          jsr       _scanflush
00003456  3EEE      
                    6351   ; memset(text, 0, sizeof(text));  // fills with zeros
00003458  4878 0096 6352          pea       150
0000345C  42A7      6353          clr.l     -(A7)
0000345E  486E FF56 6354          pea       -170(A6)
00003462  4EB9 0000 6355          jsr       _memset
00003466  3C08      
00003468  DEFC 000C 6356          add.w     #12,A7
                    6357   ; printf("\nEnter what size of memory you want to read/write\n Byte = 0\n Word = 1\n Long Word = 2\n");
0000346C  4879 0000 6358          pea       @m68kde~1_176.L
00003470  6372      
00003472  4E92      6359          jsr       (A2)
00003474  584F      6360          addq.w    #4,A7
                    6361   ; dataSize = _getch() - 48;
00003476  4E95      6362          jsr       (A5)
00003478  0480 0000 6363          sub.l     #48,D0
0000347C  0030      
0000347E  2A00      6364          move.l    D0,D5
                    6365   ; printf("\n");
00003480  4879 0000 6366          pea       @m68kde~1_28.L
00003484  5164      
00003486  4E92      6367          jsr       (A2)
00003488  584F      6368          addq.w    #4,A7
                    6369   ; if (dataSize == 0) {
0000348A  4A85      6370          tst.l     D5
0000348C  6600 0058 6371          bne       MemoryTest_1
                    6372   ; printf("\nEnter which data pattern you want to write into memory\n 0x00 = 0\n 0xB2 = 1\n 0xC3 = 2\n 0xD4 = 3\n");
00003490  4879 0000 6373          pea       @m68kde~1_177.L
00003494  63C8      
00003496  4E92      6374          jsr       (A2)
00003498  584F      6375          addq.w    #4,A7
                    6376   ; intBuffer = _getch() - 48;
0000349A  4E95      6377          jsr       (A5)
0000349C  0480 0000 6378          sub.l     #48,D0
000034A0  0030      
000034A2  2E00      6379          move.l    D0,D7
                    6380   ; // scanf("%d", &intBuffer);
                    6381   ; switch (intBuffer) {
000034A4  2007      6382          move.l    D7,D0
000034A6  0C80 0000 6383          cmp.l     #4,D0
000034AA  0004      
000034AC  642C      6384          bhs.s     MemoryTest_4
000034AE  E380      6385          asl.l     #1,D0
000034B0  303B 0806 6386          move.w    MemoryTest_5(PC,D0.L),D0
000034B4  4EFB 0002 6387          jmp       MemoryTest_5(PC,D0.W)
                    6388   MemoryTest_5:
000034B8  0008      6389          dc.w      MemoryTest_6-MemoryTest_5
000034BA  000C      6390          dc.w      MemoryTest_7-MemoryTest_5
000034BC  0014      6391          dc.w      MemoryTest_8-MemoryTest_5
000034BE  001C      6392          dc.w      MemoryTest_9-MemoryTest_5
                    6393   MemoryTest_6:
                    6394   ; case(0):
                    6395   ; dataPattern = 0x00; break;
000034C0  4283      6396          clr.l     D3
000034C2  6016      6397          bra.s     MemoryTest_4
                    6398   MemoryTest_7:
                    6399   ; case(1):
                    6400   ; dataPattern = 0xB2; break;
000034C4  263C 0000 6401          move.l    #178,D3
000034C8  00B2      
000034CA  600E      6402          bra.s     MemoryTest_4
                    6403   MemoryTest_8:
                    6404   ; case(2):
                    6405   ; dataPattern = 0xC3; break;
000034CC  263C 0000 6406          move.l    #195,D3
000034D0  00C3      
000034D2  6006      6407          bra.s     MemoryTest_4
                    6408   MemoryTest_9:
                    6409   ; case(3):
                    6410   ; dataPattern = 0xD4; break;
000034D4  263C 0000 6411          move.l    #212,D3
000034D8  00D4      
                    6412   MemoryTest_4:
                    6413   ; }
                    6414   ; dataPattern &= 0xFF;
000034DA  C6BC 0000 6415          and.l     #255,D3
000034DE  00FF      
                    6416   ; byteLength = 1;
000034E0  7801      6417          moveq     #1,D4
000034E2  6000 00AE 6418          bra       MemoryTest_11
                    6419   MemoryTest_1:
                    6420   ; } else if (dataSize == 1) {
000034E6  0C85 0000 6421          cmp.l     #1,D5
000034EA  0001      
000034EC  6600 0058 6422          bne       MemoryTest_10
                    6423   ; printf("\nEnter which data pattern you want to write into memory\n 0x0000 = 0\n 0x1234 = 1\n 0xA1B2 = 2\n 0xC3D4 = 3\n");
000034F0  4879 0000 6424          pea       @m68kde~1_178.L
000034F4  642A      
000034F6  4E92      6425          jsr       (A2)
000034F8  584F      6426          addq.w    #4,A7
                    6427   ; intBuffer = _getch() - 48;
000034FA  4E95      6428          jsr       (A5)
000034FC  0480 0000 6429          sub.l     #48,D0
00003500  0030      
00003502  2E00      6430          move.l    D0,D7
                    6431   ; switch (intBuffer) {
00003504  2007      6432          move.l    D7,D0
00003506  0C80 0000 6433          cmp.l     #4,D0
0000350A  0004      
0000350C  642C      6434          bhs.s     MemoryTest_13
0000350E  E380      6435          asl.l     #1,D0
00003510  303B 0806 6436          move.w    MemoryTest_14(PC,D0.L),D0
00003514  4EFB 0002 6437          jmp       MemoryTest_14(PC,D0.W)
                    6438   MemoryTest_14:
00003518  0008      6439          dc.w      MemoryTest_15-MemoryTest_14
0000351A  000C      6440          dc.w      MemoryTest_16-MemoryTest_14
0000351C  0014      6441          dc.w      MemoryTest_17-MemoryTest_14
0000351E  001C      6442          dc.w      MemoryTest_18-MemoryTest_14
                    6443   MemoryTest_15:
                    6444   ; case(0):
                    6445   ; dataPattern = 0x0000; break;
00003520  4283      6446          clr.l     D3
00003522  6016      6447          bra.s     MemoryTest_13
                    6448   MemoryTest_16:
                    6449   ; case(1):
                    6450   ; dataPattern = 0x1234; break;
00003524  263C 0000 6451          move.l    #4660,D3
00003528  1234      
0000352A  600E      6452          bra.s     MemoryTest_13
                    6453   MemoryTest_17:
                    6454   ; case(2):
                    6455   ; dataPattern = 0xA1B2; break;
0000352C  263C 0000 6456          move.l    #41394,D3
00003530  A1B2      
00003532  6006      6457          bra.s     MemoryTest_13
                    6458   MemoryTest_18:
                    6459   ; case(3):
                    6460   ; dataPattern = 0xC3D4; break;
00003534  263C 0000 6461          move.l    #50132,D3
00003538  C3D4      
                    6462   MemoryTest_13:
                    6463   ; }
                    6464   ; dataPattern &= 0xFFFF;
0000353A  C6BC 0000 6465          and.l     #65535,D3
0000353E  FFFF      
                    6466   ; byteLength = 2;
00003540  7802      6467          moveq     #2,D4
00003542  6000 004E 6468          bra       MemoryTest_11
                    6469   MemoryTest_10:
                    6470   ; } else {
                    6471   ; printf("\nEnter which data pattern you want to write into memory\n 0x0000_0000 = 0\n 0xAABB_CCDD = 1\n 0x1122_3344 = 2\n 0x7654_3210 = 3\n");
00003546  4879 0000 6472          pea       @m68kde~1_179.L
0000354A  6494      
0000354C  4E92      6473          jsr       (A2)
0000354E  584F      6474          addq.w    #4,A7
                    6475   ; intBuffer = _getch() - 48;
00003550  4E95      6476          jsr       (A5)
00003552  0480 0000 6477          sub.l     #48,D0
00003556  0030      
00003558  2E00      6478          move.l    D0,D7
                    6479   ; switch (intBuffer) {
0000355A  2007      6480          move.l    D7,D0
0000355C  0C80 0000 6481          cmp.l     #4,D0
00003560  0004      
00003562  642C      6482          bhs.s     MemoryTest_20
00003564  E380      6483          asl.l     #1,D0
00003566  303B 0806 6484          move.w    MemoryTest_21(PC,D0.L),D0
0000356A  4EFB 0002 6485          jmp       MemoryTest_21(PC,D0.W)
                    6486   MemoryTest_21:
0000356E  0008      6487          dc.w      MemoryTest_22-MemoryTest_21
00003570  000C      6488          dc.w      MemoryTest_23-MemoryTest_21
00003572  0014      6489          dc.w      MemoryTest_24-MemoryTest_21
00003574  001C      6490          dc.w      MemoryTest_25-MemoryTest_21
                    6491   MemoryTest_22:
                    6492   ; case(0):
                    6493   ; dataPattern = 0x00000000; break;
00003576  4283      6494          clr.l     D3
00003578  6016      6495          bra.s     MemoryTest_20
                    6496   MemoryTest_23:
                    6497   ; case(1):
                    6498   ; dataPattern = 0xAABBCCDD; break;
0000357A  263C AABB 6499          move.l    #-1430532899,D3
0000357E  CCDD      
00003580  600E      6500          bra.s     MemoryTest_20
                    6501   MemoryTest_24:
                    6502   ; case(2):
                    6503   ; dataPattern = 0x11223344; break;
00003582  263C 1122 6504          move.l    #287454020,D3
00003586  3344      
00003588  6006      6505          bra.s     MemoryTest_20
                    6506   MemoryTest_25:
                    6507   ; case(3):
                    6508   ; dataPattern = 0x76543210; break;
0000358A  263C 7654 6509          move.l    #1985229328,D3
0000358E  3210      
                    6510   MemoryTest_20:
                    6511   ; }
                    6512   ; byteLength = 4;
00003590  7804      6513          moveq     #4,D4
                    6514   MemoryTest_11:
                    6515   ; }
                    6516   ; // Tests the DRAM range memory from 0x0802_0000 to 0x0B00_0000
                    6517   ; while (startAddressPtr == NULL || 
                    6518   MemoryTest_26:
00003592  4A82      6519          tst.l     D2
00003594  6732      6520          beq.s     MemoryTest_29
00003596  0C84 0000 6521          cmp.l     #1,D4
0000359A  0001      
0000359C  6316      6522          bls.s     MemoryTest_30
0000359E  2F02      6523          move.l    D2,-(A7)
000035A0  4878 0002 6524          pea       2
000035A4  4EB9 0000 6525          jsr       ULDIV
000035A8  3A5E      
000035AA  202F 0004 6526          move.l    4(A7),D0
000035AE  504F      6527          addq.w    #8,A7
000035B0  4A80      6528          tst.l     D0
000035B2  6614      6529          bne.s     MemoryTest_29
                    6530   MemoryTest_30:
000035B4  0C82 0802 6531          cmp.l     #134348800,D2
000035B8  0000      
000035BA  650C      6532          blo.s     MemoryTest_29
000035BC  203C 0B00 6533          move.l    #184549376,D0
000035C0  0000      
000035C2  9084      6534          sub.l     D4,D0
000035C4  B480      6535          cmp.l     D0,D2
000035C6  6316      6536          bls.s     MemoryTest_28
                    6537   MemoryTest_29:
                    6538   ; (byteLength > 1 && (unsigned int) startAddressPtr % 2 != 0) || 
                    6539   ; (unsigned int) startAddressPtr < 0x08020000 || 
                    6540   ; (unsigned int) startAddressPtr > 0x0B000000 - byteLength) {
                    6541   ; printf("\nProvide Start Address in hex (do not use 0x prefix)\n0x");
000035C8  4879 0000 6542          pea       @m68kde~1_180.L
000035CC  6512      
000035CE  4E92      6543          jsr       (A2)
000035D0  584F      6544          addq.w    #4,A7
                    6545   ; startAddressPtr =  Get8HexDigits(0);
000035D2  42A7      6546          clr.l     -(A7)
000035D4  4EB8 0CFA 6547          jsr       _Get8HexDigits
000035D8  584F      6548          addq.w    #4,A7
000035DA  2400      6549          move.l    D0,D2
000035DC  60B4      6550          bra       MemoryTest_26
                    6551   MemoryTest_28:
                    6552   ; }
                    6553   ; while (endAddressPtr == NULL || 
                    6554   MemoryTest_31:
000035DE  4A86      6555          tst.l     D6
000035E0  670A      6556          beq.s     MemoryTest_34
000035E2  202E FFF0 6557          move.l    -16(A6),D0
000035E6  D084      6558          add.l     D4,D0
000035E8  BC80      6559          cmp.l     D0,D6
000035EA  6416      6560          bhs.s     MemoryTest_33
                    6561   MemoryTest_34:
                    6562   ; (unsigned int) endAddressPtr < startAddress + byteLength) {
                    6563   ; printf("\nProvide End Address in hex (do not use 0x prefix)\n0x");
000035EC  4879 0000 6564          pea       @m68kde~1_181.L
000035F0  654A      
000035F2  4E92      6565          jsr       (A2)
000035F4  584F      6566          addq.w    #4,A7
                    6567   ; endAddressPtr =  Get8HexDigits(0);
000035F6  42A7      6568          clr.l     -(A7)
000035F8  4EB8 0CFA 6569          jsr       _Get8HexDigits
000035FC  584F      6570          addq.w    #4,A7
000035FE  2C00      6571          move.l    D0,D6
00003600  60DC      6572          bra       MemoryTest_31
                    6573   MemoryTest_33:
                    6574   ; }
                    6575   ; printf("\nStart Address 0x%08x\n", (unsigned int) startAddressPtr);
00003602  2F02      6576          move.l    D2,-(A7)
00003604  4879 0000 6577          pea       @m68kde~1_182.L
00003608  6580      
0000360A  4E92      6578          jsr       (A2)
0000360C  504F      6579          addq.w    #8,A7
                    6580   ; printf("\nEnd Address: 0x%08x\n",(unsigned int) endAddressPtr);
0000360E  2F06      6581          move.l    D6,-(A7)
00003610  4879 0000 6582          pea       @m68kde~1_183.L
00003614  6598      
00003616  4E92      6583          jsr       (A2)
00003618  504F      6584          addq.w    #8,A7
                    6585   ; addrCount = 0;
0000361A  42AE FFFC 6586          clr.l     -4(A6)
                    6587   ; while (startAddressPtr < endAddressPtr && ((unsigned int)endAddressPtr - (unsigned int)startAddressPtr + 1) >= (byteLength)) {
                    6588   MemoryTest_35:
0000361E  B486      6589          cmp.l     D6,D2
00003620  6400 0132 6590          bhs       MemoryTest_37
00003624  2006      6591          move.l    D6,D0
00003626  9082      6592          sub.l     D2,D0
00003628  5280      6593          addq.l    #1,D0
0000362A  B084      6594          cmp.l     D4,D0
0000362C  6500 0126 6595          blo       MemoryTest_37
                    6596   ; // If address goes beyond 0x0B00_0000 then break
                    6597   ; if ((unsigned int)startAddressPtr > 0x0B000000 - byteLength) {
00003630  203C 0B00 6598          move.l    #184549376,D0
00003634  0000      
00003636  9084      6599          sub.l     D4,D0
00003638  B480      6600          cmp.l     D0,D2
0000363A  6310      6601          bls.s     MemoryTest_38
                    6602   ; printf("ERROR... Address 0x%x is beyond the memory range\n", (void*)startAddressPtr);
0000363C  2F02      6603          move.l    D2,-(A7)
0000363E  4879 0000 6604          pea       @m68kde~1_184.L
00003642  65AE      
00003644  4E92      6605          jsr       (A2)
00003646  504F      6606          addq.w    #8,A7
                    6607   ; break;
00003648  6000 010A 6608          bra       MemoryTest_37
                    6609   MemoryTest_38:
                    6610   ; }
                    6611   ; longAddressPtr = startAddressPtr;
0000364C  2642      6612          move.l    D2,A3
                    6613   ; wordAddressPtr = startAddressPtr;
0000364E  2842      6614          move.l    D2,A4
                    6615   ; if (dataSize == 0) {
00003650  4A85      6616          tst.l     D5
00003652  6600 0034 6617          bne       MemoryTest_40
                    6618   ; *startAddressPtr = dataPattern;
00003656  2042      6619          move.l    D2,A0
00003658  1083      6620          move.b    D3,(A0)
                    6621   ; if ((*startAddressPtr) != dataPattern) {
0000365A  2042      6622          move.l    D2,A0
0000365C  1010      6623          move.b    (A0),D0
0000365E  C0BC 0000 6624          and.l     #255,D0
00003662  00FF      
00003664  B083      6625          cmp.l     D3,D0
00003666  671C      6626          beq.s     MemoryTest_42
                    6627   ; printf("ERROR... Value written to address 0x%x == 0x%x. Value Expected: 0x%x\n", (void*)startAddressPtr, *startAddressPtr, dataPattern);
00003668  2F03      6628          move.l    D3,-(A7)
0000366A  2042      6629          move.l    D2,A0
0000366C  1210      6630          move.b    (A0),D1
0000366E  C2BC 0000 6631          and.l     #255,D1
00003672  00FF      
00003674  2F01      6632          move.l    D1,-(A7)
00003676  2F02      6633          move.l    D2,-(A7)
00003678  4879 0000 6634          pea       @m68kde~1_185.L
0000367C  65E0      
0000367E  4E92      6635          jsr       (A2)
00003680  DEFC 0010 6636          add.w     #16,A7
                    6637   MemoryTest_42:
00003684  6000 0058 6638          bra       MemoryTest_48
                    6639   MemoryTest_40:
                    6640   ; }
                    6641   ; } else if (dataSize == 1) {
00003688  0C85 0000 6642          cmp.l     #1,D5
0000368C  0001      
0000368E  662C      6643          bne.s     MemoryTest_44
                    6644   ; *wordAddressPtr = dataPattern;
00003690  3883      6645          move.w    D3,(A4)
                    6646   ; if ((*wordAddressPtr) != dataPattern) {
00003692  3014      6647          move.w    (A4),D0
00003694  C0BC 0000 6648          and.l     #65535,D0
00003698  FFFF      
0000369A  B083      6649          cmp.l     D3,D0
0000369C  671C      6650          beq.s     MemoryTest_46
                    6651   ; printf("ERROR... Value written to address 0x%x == 0x%x. Value Expected: 0x%x\n", (void*)startAddressPtr, *startAddressPtr, dataPattern);
0000369E  2F03      6652          move.l    D3,-(A7)
000036A0  2042      6653          move.l    D2,A0
000036A2  1210      6654          move.b    (A0),D1
000036A4  C2BC 0000 6655          and.l     #255,D1
000036A8  00FF      
000036AA  2F01      6656          move.l    D1,-(A7)
000036AC  2F02      6657          move.l    D2,-(A7)
000036AE  4879 0000 6658          pea       @m68kde~1_185.L
000036B2  65E0      
000036B4  4E92      6659          jsr       (A2)
000036B6  DEFC 0010 6660          add.w     #16,A7
                    6661   MemoryTest_46:
000036BA  6022      6662          bra.s     MemoryTest_48
                    6663   MemoryTest_44:
                    6664   ; }
                    6665   ; } else {
                    6666   ; *longAddressPtr = dataPattern;
000036BC  2683      6667          move.l    D3,(A3)
                    6668   ; if ((*longAddressPtr) != dataPattern) {
000036BE  B693      6669          cmp.l     (A3),D3
000036C0  671C      6670          beq.s     MemoryTest_48
                    6671   ; printf("ERROR... Value written to address 0x%x == 0x%x. Value Expected: 0x%x\n", (void*)startAddressPtr, *startAddressPtr, dataPattern);
000036C2  2F03      6672          move.l    D3,-(A7)
000036C4  2042      6673          move.l    D2,A0
000036C6  1210      6674          move.b    (A0),D1
000036C8  C2BC 0000 6675          and.l     #255,D1
000036CC  00FF      
000036CE  2F01      6676          move.l    D1,-(A7)
000036D0  2F02      6677          move.l    D2,-(A7)
000036D2  4879 0000 6678          pea       @m68kde~1_185.L
000036D6  65E0      
000036D8  4E92      6679          jsr       (A2)
000036DA  DEFC 0010 6680          add.w     #16,A7
                    6681   MemoryTest_48:
                    6682   ; }
                    6683   ; }
                    6684   ; // if ((*startAddressPtr) != dataPattern) {
                    6685   ; //     printf("ERROR... Value written to address 0x%x == 0x%x. Value Expected: 0x%x\n", (void*)startAddressPtr, *startAddressPtr, dataPattern);
                    6686   ; // }
                    6687   ; addrCount++;
000036DE  52AE FFFC 6688          addq.l    #1,-4(A6)
                    6689   ; if (addrCount % 128 == 0) {
000036E2  2F2E FFFC 6690          move.l    -4(A6),-(A7)
000036E6  4878 0080 6691          pea       128
000036EA  4EB9 0000 6692          jsr       ULDIV
000036EE  3A5E      
000036F0  202F 0004 6693          move.l    4(A7),D0
000036F4  504F      6694          addq.w    #8,A7
000036F6  4A80      6695          tst.l     D0
000036F8  6600 0054 6696          bne       MemoryTest_55
                    6697   ; if (dataSize == 0) {
000036FC  4A85      6698          tst.l     D5
000036FE  661C      6699          bne.s     MemoryTest_52
                    6700   ; printf("Address: 0x%x Value: 0x%02X\n",
00003700  2042      6701          move.l    D2,A0
00003702  1210      6702          move.b    (A0),D1
00003704  C2BC 0000 6703          and.l     #255,D1
00003708  00FF      
0000370A  2F01      6704          move.l    D1,-(A7)
0000370C  2F02      6705          move.l    D2,-(A7)
0000370E  4879 0000 6706          pea       @m68kde~1_186.L
00003712  6626      
00003714  4E92      6707          jsr       (A2)
00003716  DEFC 000C 6708          add.w     #12,A7
0000371A  6032      6709          bra.s     MemoryTest_55
                    6710   MemoryTest_52:
                    6711   ; (unsigned int)startAddressPtr, *startAddressPtr);
                    6712   ; }
                    6713   ; else if (dataSize == 1) {
0000371C  0C85 0000 6714          cmp.l     #1,D5
00003720  0001      
00003722  661A      6715          bne.s     MemoryTest_54
                    6716   ; printf("Address: 0x%x Value: 0x%04X\n",
00003724  3214      6717          move.w    (A4),D1
00003726  C2BC 0000 6718          and.l     #65535,D1
0000372A  FFFF      
0000372C  2F01      6719          move.l    D1,-(A7)
0000372E  2F0C      6720          move.l    A4,-(A7)
00003730  4879 0000 6721          pea       @m68kde~1_187.L
00003734  6644      
00003736  4E92      6722          jsr       (A2)
00003738  DEFC 000C 6723          add.w     #12,A7
0000373C  6010      6724          bra.s     MemoryTest_55
                    6725   MemoryTest_54:
                    6726   ; (unsigned int)wordAddressPtr, *wordAddressPtr);
                    6727   ; }
                    6728   ; else {
                    6729   ; printf("Address: 0x%x Value: 0x%08X\n",
0000373E  2F13      6730          move.l    (A3),-(A7)
00003740  2F0B      6731          move.l    A3,-(A7)
00003742  4879 0000 6732          pea       @m68kde~1_188.L
00003746  6662      
00003748  4E92      6733          jsr       (A2)
0000374A  DEFC 000C 6734          add.w     #12,A7
                    6735   MemoryTest_55:
                    6736   ; (unsigned int)longAddressPtr, *longAddressPtr);
                    6737   ; }
                    6738   ; }
                    6739   ; startAddressPtr += byteLength;
0000374E  D484      6740          add.l     D4,D2
00003750  6000 FECC 6741          bra       MemoryTest_35
                    6742   MemoryTest_37:
00003754  4CDF 3CFC 6743          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
00003758  4E5E      6744          unlk      A6
0000375A  4E75      6745          rts
                    6746   ; }
                    6747   ; // add your code to test memory here using 32 bit reads and writes of data between the start and end of memory
                    6748   ; }
                    6749   ; void main(void)
                    6750   ; {
                    6751   _main:
0000375C  4E56 FFF4 6752          link      A6,#-12
00003760  48E7 3030 6753          movem.l   D2/D3/A2/A3,-(A7)
00003764  45F8 0A86 6754          lea       _InstallExceptionHandler.L,A2
00003768  47F9 0000 6755          lea       _printf.L,A3
0000376C  3A1C      
                    6756   ; char c ;
                    6757   ; int i, j ;
                    6758   ; char *BugMessage = "DE1-68k Bug V1.77";
0000376E  41F9 0000 6759          lea       @m68kde~1_189.L,A0
00003772  6680      
00003774  2608      6760          move.l    A0,D3
                    6761   ; char *CopyrightMessage = "Copyright (C) PJ Davies 2016";
00003776  41F9 0000 6762          lea       @m68kde~1_190.L,A0
0000377A  6692      
0000377C  2D48 FFFC 6763          move.l    A0,-4(A6)
                    6764   ; KillAllBreakPoints() ;
00003780  4EB8 2A86 6765          jsr       _KillAllBreakPoints
                    6766   ; i = x = y = z = PortA_Count = 0;
00003784  42B9 0B00 6767          clr.l     _PortA_Count.L
00003788  00D4      
0000378A  42B9 0B00 6768          clr.l     _z.L
0000378E  00D0      
00003790  42B9 0B00 6769          clr.l     _y.L
00003794  00CC      
00003796  42B9 0B00 6770          clr.l     _x.L
0000379A  00C8      
0000379C  4282      6771          clr.l     D2
                    6772   ; Trace = GoFlag = 0;                       // used in tracing/single stepping
0000379E  42B9 0B00 6773          clr.l     _GoFlag.L
000037A2  00DC      
000037A4  42B9 0B00 6774          clr.l     _Trace.L
000037A8  00D8      
                    6775   ; Echo = 1 ;
000037AA  23FC 0000 6776          move.l    #1,_Echo.L
000037AE  0001 0B00 
000037B2  00E0      
                    6777   ; d0=d1=d2=d3=d4=d5=d6=d7=0 ;
000037B4  42B9 0B00 6778          clr.l     _d7.L
000037B8  0100      
000037BA  42B9 0B00 6779          clr.l     _d6.L
000037BE  00FC      
000037C0  42B9 0B00 6780          clr.l     _d5.L
000037C4  00F8      
000037C6  42B9 0B00 6781          clr.l     _d4.L
000037CA  00F4      
000037CC  42B9 0B00 6782          clr.l     _d3.L
000037D0  00F0      
000037D2  42B9 0B00 6783          clr.l     _d2.L
000037D6  00EC      
000037D8  42B9 0B00 6784          clr.l     _d1.L
000037DC  00E8      
000037DE  42B9 0B00 6785          clr.l     _d0.L
000037E2  00E4      
                    6786   ; a0=a1=a2=a3=a4=a5=a6=0 ;
000037E4  42B9 0B00 6787          clr.l     _a6.L
000037E8  011C      
000037EA  42B9 0B00 6788          clr.l     _a5.L
000037EE  0118      
000037F0  42B9 0B00 6789          clr.l     _a4.L
000037F4  0114      
000037F6  42B9 0B00 6790          clr.l     _a3.L
000037FA  0110      
000037FC  42B9 0B00 6791          clr.l     _a2.L
00003800  010C      
00003802  42B9 0B00 6792          clr.l     _a1.L
00003806  0108      
00003808  42B9 0B00 6793          clr.l     _a0.L
0000380C  0104      
                    6794   ; PC = ProgramStart, SSP=TopOfStack, USP = TopOfStack;
0000380E  23FC 0800 6795          move.l    #134217728,_PC.L
00003812  0000 0B00 
00003816  0120      
00003818  23FC 0C00 6796          move.l    #201326592,_SSP.L
0000381C  0000 0B00 
00003820  0124      
00003822  23FC 0C00 6797          move.l    #201326592,_USP.L
00003826  0000 0B00 
0000382A  0128      
                    6798   ; SR = 0x2000;                            // clear interrupts enable tracing  uses IRQ6
0000382C  33FC 2000 6799          move.w    #8192,_SR.L
00003830  0B00 012C 
                    6800   ; // Initialise Breakpoint variables
                    6801   ; for(i = 0; i < 8; i++)  {
00003834  4282      6802          clr.l     D2
                    6803   main_1:
00003836  0C82 0000 6804          cmp.l     #8,D2
0000383A  0008      
0000383C  6C00 004C 6805          bge       main_3
                    6806   ; BreakPointAddress[i] = 0;               //array of 8 breakpoint addresses
00003840  2002      6807          move.l    D2,D0
00003842  E588      6808          lsl.l     #2,D0
00003844  41F9 0B00 6809          lea       _BreakPointAddress.L,A0
00003848  012E      
0000384A  42B0 0800 6810          clr.l     0(A0,D0.L)
                    6811   ; WatchPointAddress[i] = 0 ;
0000384E  2002      6812          move.l    D2,D0
00003850  E588      6813          lsl.l     #2,D0
00003852  41F9 0B00 6814          lea       _WatchPointAddress.L,A0
00003856  0182      
00003858  42B0 0800 6815          clr.l     0(A0,D0.L)
                    6816   ; BreakPointInstruction[i] = 0;           // to hold the instruction at the break point
0000385C  2002      6817          move.l    D2,D0
0000385E  E388      6818          lsl.l     #1,D0
00003860  41F9 0B00 6819          lea       _BreakPointInstruction.L,A0
00003864  014E      
00003866  4270 0800 6820          clr.w     0(A0,D0.L)
                    6821   ; BreakPointSetOrCleared[i] = 0;          // indicates if break point set
0000386A  2002      6822          move.l    D2,D0
0000386C  E588      6823          lsl.l     #2,D0
0000386E  41F9 0B00 6824          lea       _BreakPointSetOrCleared.L,A0
00003872  015E      
00003874  42B0 0800 6825          clr.l     0(A0,D0.L)
                    6826   ; WatchPointSetOrCleared[i] = 0;
00003878  2002      6827          move.l    D2,D0
0000387A  E588      6828          lsl.l     #2,D0
0000387C  41F9 0B00 6829          lea       _WatchPointSetOrCleared.L,A0
00003880  01A2      
00003882  42B0 0800 6830          clr.l     0(A0,D0.L)
00003886  5282      6831          addq.l    #1,D2
00003888  60AC      6832          bra       main_1
                    6833   main_3:
                    6834   ; }
                    6835   ; Init_RS232() ;     // initialise the RS232 port
0000388A  4EB8 0B68 6836          jsr       _Init_RS232
                    6837   ; Init_LCD() ;
0000388E  4EB8 09B4 6838          jsr       _Init_LCD
                    6839   ; SPI_Init();
00003892  4EB8 1152 6840          jsr       _SPI_Init
                    6841   ; IIC_Init();
00003896  4EB8 147E 6842          jsr       _IIC_Init
                    6843   ; for( i = 32; i < 48; i++)
0000389A  7420      6844          moveq     #32,D2
                    6845   main_4:
0000389C  0C82 0000 6846          cmp.l     #48,D2
000038A0  0030      
000038A2  6C0E      6847          bge.s     main_6
                    6848   ; InstallExceptionHandler(UnhandledTrap, i) ;		        // install Trap exception handler on vector 32-47
000038A4  2F02      6849          move.l    D2,-(A7)
000038A6  4878 331A 6850          pea       _UnhandledTrap.L
000038AA  4E92      6851          jsr       (A2)
000038AC  504F      6852          addq.w    #8,A7
000038AE  5282      6853          addq.l    #1,D2
000038B0  60EA      6854          bra       main_4
                    6855   main_6:
                    6856   ; InstallExceptionHandler(menu, 47) ;		                   // TRAP #15 call debug and end program
000038B2  4878 002F 6857          pea       47
000038B6  4878 2FD8 6858          pea       _menu.L
000038BA  4E92      6859          jsr       (A2)
000038BC  504F      6860          addq.w    #8,A7
                    6861   ; InstallExceptionHandler(UnhandledIRQ1, 25) ;		      // install handler for interrupts
000038BE  4878 0019 6862          pea       25
000038C2  4878 32C0 6863          pea       _UnhandledIRQ1.L
000038C6  4E92      6864          jsr       (A2)
000038C8  504F      6865          addq.w    #8,A7
                    6866   ; InstallExceptionHandler(UnhandledIRQ2, 26) ;		      // install handler for interrupts
000038CA  4878 001A 6867          pea       26
000038CE  4878 32CC 6868          pea       _UnhandledIRQ2.L
000038D2  4E92      6869          jsr       (A2)
000038D4  504F      6870          addq.w    #8,A7
                    6871   ; InstallExceptionHandler(UnhandledIRQ3, 27) ;		      // install handler for interrupts
000038D6  4878 001B 6872          pea       27
000038DA  4878 32D8 6873          pea       _UnhandledIRQ3.L
000038DE  4E92      6874          jsr       (A2)
000038E0  504F      6875          addq.w    #8,A7
                    6876   ; InstallExceptionHandler(UnhandledIRQ4, 28) ;		      // install handler for interrupts
000038E2  4878 001C 6877          pea       28
000038E6  4878 32E4 6878          pea       _UnhandledIRQ4.L
000038EA  4E92      6879          jsr       (A2)
000038EC  504F      6880          addq.w    #8,A7
                    6881   ; InstallExceptionHandler(UnhandledIRQ5, 29) ;		      // install handler for interrupts
000038EE  4878 001D 6882          pea       29
000038F2  4878 32F0 6883          pea       _UnhandledIRQ5.L
000038F6  4E92      6884          jsr       (A2)
000038F8  504F      6885          addq.w    #8,A7
                    6886   ; InstallExceptionHandler(UnhandledIRQ6, 30) ;		      // install handler for interrupts
000038FA  4878 001E 6887          pea       30
000038FE  4878 32FC 6888          pea       _UnhandledIRQ6.L
00003902  4E92      6889          jsr       (A2)
00003904  504F      6890          addq.w    #8,A7
                    6891   ; InstallExceptionHandler(UnhandledIRQ7, 31) ;		      // install handler for interrupts
00003906  4878 001F 6892          pea       31
0000390A  4878 330E 6893          pea       _UnhandledIRQ7.L
0000390E  4E92      6894          jsr       (A2)
00003910  504F      6895          addq.w    #8,A7
                    6896   ; InstallExceptionHandler(HandleBreakPoint, 46) ;		           // install Trap 14 Break Point exception handler on vector 46
00003912  4878 002E 6897          pea       46
00003916  4878 2D14 6898          pea       _HandleBreakPoint.L
0000391A  4E92      6899          jsr       (A2)
0000391C  504F      6900          addq.w    #8,A7
                    6901   ; InstallExceptionHandler(DumpRegistersandPause, 29) ;		   // install TRACE handler for IRQ5 on vector 29
0000391E  4878 001D 6902          pea       29
00003922  4878 23F4 6903          pea       _DumpRegistersandPause.L
00003926  4E92      6904          jsr       (A2)
00003928  504F      6905          addq.w    #8,A7
                    6906   ; InstallExceptionHandler(BusError,2) ;                          // install Bus error handler
0000392A  4878 0002 6907          pea       2
0000392E  4878 3328 6908          pea       _BusError.L
00003932  4E92      6909          jsr       (A2)
00003934  504F      6910          addq.w    #8,A7
                    6911   ; InstallExceptionHandler(AddressError,3) ;                      // install address error handler (doesn't work on soft core 68k implementation)
00003936  4878 0003 6912          pea       3
0000393A  4878 3336 6913          pea       _AddressError.L
0000393E  4E92      6914          jsr       (A2)
00003940  504F      6915          addq.w    #8,A7
                    6916   ; InstallExceptionHandler(IllegalInstruction,4) ;                // install illegal instruction exception handler
00003942  4878 0004 6917          pea       4
00003946  4878 3344 6918          pea       _IllegalInstruction.L
0000394A  4E92      6919          jsr       (A2)
0000394C  504F      6920          addq.w    #8,A7
                    6921   ; InstallExceptionHandler(Dividebyzero,5) ;                      // install /0 exception handler
0000394E  4878 0005 6922          pea       5
00003952  4878 3352 6923          pea       _Dividebyzero.L
00003956  4E92      6924          jsr       (A2)
00003958  504F      6925          addq.w    #8,A7
                    6926   ; InstallExceptionHandler(Check,6) ;                             // install check instruction exception handler
0000395A  4878 0006 6927          pea       6
0000395E  4878 3360 6928          pea       _Check.L
00003962  4E92      6929          jsr       (A2)
00003964  504F      6930          addq.w    #8,A7
                    6931   ; InstallExceptionHandler(Trapv,7) ;                             // install trapv instruction exception handler
00003966  4878 0007 6932          pea       7
0000396A  4878 336E 6933          pea       _Trapv.L
0000396E  4E92      6934          jsr       (A2)
00003970  504F      6935          addq.w    #8,A7
                    6936   ; InstallExceptionHandler(PrivError,8) ;                         // install Priv Violation exception handler
00003972  4878 0008 6937          pea       8
00003976  4878 337C 6938          pea       _PrivError.L
0000397A  4E92      6939          jsr       (A2)
0000397C  504F      6940          addq.w    #8,A7
                    6941   ; InstallExceptionHandler(UnitIRQ,15) ;                          // install uninitialised IRQ exception handler
0000397E  4878 000F 6942          pea       15
00003982  4878 338A 6943          pea       _UnitIRQ.L
00003986  4E92      6944          jsr       (A2)
00003988  504F      6945          addq.w    #8,A7
                    6946   ; InstallExceptionHandler(Check,24) ;                            // install spurious IRQ exception handler
0000398A  4878 0018 6947          pea       24
0000398E  4878 3360 6948          pea       _Check.L
00003992  4E92      6949          jsr       (A2)
00003994  504F      6950          addq.w    #8,A7
                    6951   ; FlushKeyboard() ;                        // dump unread characters from keyboard
00003996  4EB8 0BFC 6952          jsr       _FlushKeyboard
                    6953   ; TraceException = 0 ;                     // clear trace exception port to remove any software generated single step/trace
0000399A  4239 0040 6954          clr.b     4194314
0000399E  000A      
                    6955   ; // test for auto flash boot and run from Flash by reading switch 9 on DE1-soc board. If set, copy program from flash into Dram and run
                    6956   ; if (((char)(PortB & 0x02)) == (char)(0x02))    {
000039A0  1039 0040 6957          move.b    4194306,D0
000039A4  0002      
000039A6  C03C 0002 6958          and.b     #2,D0
000039AA  0C00 0002 6959          cmp.b     #2,D0
000039AE  6628      6960          bne.s     main_7
                    6961   ; LoadFromFlashChip();
000039B0  4EB8 13E0 6962          jsr       _LoadFromFlashChip
                    6963   ; printf("\r\nRunning.....") ;
000039B4  4879 0000 6964          pea       @m68kde~1_191.L
000039B8  66B0      
000039BA  4E93      6965          jsr       (A3)
000039BC  584F      6966          addq.w    #4,A7
                    6967   ; Oline1("Running.....") ;
000039BE  4879 0000 6968          pea       @m68kde~1_192.L
000039C2  66C0      
000039C4  4EB8 0A58 6969          jsr       _Oline1
000039C8  584F      6970          addq.w    #4,A7
                    6971   ; GoFlag = 1;
000039CA  23FC 0000 6972          move.l    #1,_GoFlag.L
000039CE  0001 0B00 
000039D2  00DC      
                    6973   ; go() ;
000039D4  4EB8 08B8 6974          jsr       _go
                    6975   main_7:
                    6976   ; }
                    6977   ; // otherwise start the debug monitor
                    6978   ; Oline0(BugMessage) ;
000039D8  2F03      6979          move.l    D3,-(A7)
000039DA  4EB8 0A2A 6980          jsr       _Oline0
000039DE  584F      6981          addq.w    #4,A7
                    6982   ; Oline1("By: PJ Davies") ;
000039E0  4879 0000 6983          pea       @m68kde~1_193.L
000039E4  66CE      
000039E6  4EB8 0A58 6984          jsr       _Oline1
000039EA  584F      6985          addq.w    #4,A7
                    6986   ; printf("\r\n%s", BugMessage) ;
000039EC  2F03      6987          move.l    D3,-(A7)
000039EE  4879 0000 6988          pea       @m68kde~1_194.L
000039F2  66DC      
000039F4  4E93      6989          jsr       (A3)
000039F6  504F      6990          addq.w    #8,A7
                    6991   ; printf("\r\n%s", CopyrightMessage) ;
000039F8  2F2E FFFC 6992          move.l    -4(A6),-(A7)
000039FC  4879 0000 6993          pea       @m68kde~1_194.L
00003A00  66DC      
00003A02  4E93      6994          jsr       (A3)
00003A04  504F      6995          addq.w    #8,A7
                    6996   ; printf("\n Student Names:\n Zachariah Joseph: 45500055 \n Umair Mazhar: 20333308\n");
00003A06  4879 0000 6997          pea       @m68kde~1_195.L
00003A0A  66E2      
00003A0C  4E93      6998          jsr       (A3)
00003A0E  584F      6999          addq.w    #4,A7
                    7000   ; menu();
00003A10  4EB8 2FD8 7001          jsr       _menu
00003A14  4CDF 0C0C 7002          movem.l   (A7)+,D2/D3/A2/A3
00003A18  4E5E      7003          unlk      A6
00003A1A  4E75      7004          rts
                    7005   ; }
                    7006   _printf:
00003A1C  4E56 FFFC 7007          link      A6,#-4
00003A20  48E7 2000 7008          movem.l   D2,-(A7)
00003A24  41EE 0008 7009          lea       8(A6),A0
00003A28  5848      7010          addq.w    #4,A0
00003A2A  2408      7011          move.l    A0,D2
00003A2C  2F02      7012          move.l    D2,-(A7)
00003A2E  2F2E 0008 7013          move.l    8(A6),-(A7)
00003A32  42A7      7014          clr.l     -(A7)
00003A34  6100 0B74 7015          bsr       _vsprintf
00003A38  DEFC 000C 7016          add.w     #12,A7
00003A3C  2D40 FFFC 7017          move.l    D0,-4(A6)
00003A40  4282      7018          clr.l     D2
00003A42  202E FFFC 7019          move.l    -4(A6),D0
00003A46  4CDF 0004 7020          movem.l   (A7)+,D2
00003A4A  4E5E      7021          unlk      A6
00003A4C  4E75      7022          rts
                    7023   _strcpy:
00003A4E  206F 0004 7024          move.l    (4,A7),A0
00003A52  226F 0008 7025          move.l    (8,A7),A1
00003A56  2008      7026          move.l    A0,D0
                    7027   strcpy_1:
00003A58  10D9      7028          move.b    (A1)+,(A0)+
00003A5A  66FC      7029          bne       strcpy_1
00003A5C  4E75      7030          rts
                    7031   ULDIV:
00003A5E  4E56 0000 7032          link    A6,#0
00003A62  48E7 C000 7033          movem.l D0/D1,-(A7)
00003A66  222E 0008 7034          move.l  8(A6),D1
00003A6A  202E 000C 7035          move.l  12(A6),D0
00003A6E  6036      7036          bra.s   ldiv_3
                    7037   LDIV:
00003A70  4E56 0000 7038          link    A6,#0
00003A74  48E7 C000 7039          movem.l D0/D1,-(A7)
00003A78  222E 0008 7040          move.l  8(A6),D1
00003A7C  202E 000C 7041          move.l  12(A6),D0
00003A80  4A80      7042          tst.l   D0
00003A82  6A0E      7043          bpl.s   ldiv_1
00003A84  4480      7044          neg.l   D0
00003A86  4A81      7045          tst.l   D1
00003A88  6A14      7046          bpl.s   ldiv_2
00003A8A  4481      7047          neg.l   D1
00003A8C  612A      7048          bsr.s   dodiv
00003A8E  4481      7049          neg.l   D1
00003A90  6016      7050          bra.s   ldiv_4
                    7051   ldiv_1:
00003A92  4A81      7052          tst.l   D1
00003A94  6A10      7053          bpl.s   ldiv_3
00003A96  4481      7054          neg.l   D1
00003A98  611E      7055          bsr.s   dodiv
00003A9A  4480      7056          neg.l   D0
00003A9C  600A      7057          bra.s   ldiv_4
                    7058   ldiv_2:
00003A9E  6118      7059          bsr.s   dodiv
00003AA0  4480      7060          neg.l   D0
00003AA2  4481      7061          neg.l   D1
00003AA4  6002      7062          bra.s   ldiv_4
                    7063   ldiv_3:
00003AA6  6110      7064          bsr.s   dodiv
                    7065   ldiv_4:
00003AA8  2D40 0008 7066          move.l  D0,8(A6)
00003AAC  2D41 000C 7067          move.l  D1,12(A6)
00003AB0  4CDF 0003 7068          movem.l (A7)+,D0/D1
00003AB4  4E5E      7069          unlk    A6
00003AB6  4E75      7070          rts
                    7071   dodiv:
00003AB8  0C81 0000 7072          cmpi.l  #$FFFF,D1
00003ABC  FFFF      
00003ABE  6236      7073          bhi.s   dodiv_2
00003AC0  0C80 0000 7074          cmpi.l  #$FFFF,D0
00003AC4  FFFF      
00003AC6  6210      7075          bhi.s   dodiv_1
00003AC8  80C1      7076          divu    D1,D0
00003ACA  2200      7077          move.l  D0,D1
00003ACC  4241      7078          clr.w   D1
00003ACE  4841      7079          swap    D1
00003AD0  0280 0000 7080          andi.l  #$FFFF,D0
00003AD4  FFFF      
00003AD6  4E75      7081          rts
                    7082   dodiv_1:
00003AD8  48A7 A000 7083          movem.w D0/D2,-(A7)
00003ADC  4240      7084          clr.w   D0
00003ADE  4840      7085          swap    D0
00003AE0  80C1      7086          divu    D1,D0
00003AE2  3400      7087          move.w  D0,D2
00003AE4  301F      7088          move.w  (A7)+,D0
00003AE6  80C1      7089          divu    D1,D0
00003AE8  4840      7090          swap    D0
00003AEA  4281      7091          clr.l   D1
00003AEC  3200      7092          move.w  D0,D1
00003AEE  3002      7093          move.w  D2,D0
00003AF0  4840      7094          swap    D0
00003AF2  341F      7095          move.w  (A7)+,D2
00003AF4  4E75      7096          rts
                    7097   dodiv_2:
00003AF6  48E7 3800 7098          movem.l D2/D3/D4,-(A7)
00003AFA  2401      7099          move.l  D1,D2
00003AFC  4242      7100          clr.w   D2
00003AFE  4842      7101          swap    D2
00003B00  5282      7102          addq.l  #1,D2
00003B02  2600      7103          move.l  D0,D3
00003B04  2801      7104          move.l  D1,D4
00003B06  2202      7105          move.l  D2,D1
00003B08  61CE      7106          bsr.s   dodiv_1
00003B0A  2204      7107          move.l  D4,D1
00003B0C  82C2      7108          divu    D2,D1
00003B0E  80C1      7109          divu    D1,D0
00003B10  0280 0000 7110          andi.l  #$FFFF,D0
00003B14  FFFF      
                    7111   dodiv_3:
00003B16  2204      7112          move.l  D4,D1
00003B18  2404      7113          move.l  D4,D2
00003B1A  4842      7114          swap    D2
00003B1C  C2C0      7115          mulu    D0,D1
00003B1E  C4C0      7116          mulu    D0,D2
00003B20  4842      7117          swap    D2
00003B22  D282      7118          add.l   D2,D1
00003B24  9283      7119          sub.l   D3,D1
00003B26  620A      7120          bhi.s   dodiv_4
00003B28  4481      7121          neg.l   D1
00003B2A  B881      7122          cmp.l   D1,D4
00003B2C  6208      7123          bhi.s   dodiv_5
00003B2E  5280      7124          addq.l  #1,D0
00003B30  60E4      7125          bra.s   dodiv_3
                    7126   dodiv_4:
00003B32  5380      7127          subq.l  #1,D0
00003B34  60E0      7128          bra.s   dodiv_3
                    7129   dodiv_5:
00003B36  4CDF 001C 7130          movem.l (A7)+,D2/D3/D4
00003B3A  4E75      7131          rts
                    7132   _putch:
00003B3C  4E56 0000 7133          link      A6,#0
00003B40  48E7 2000 7134          movem.l   D2,-(A7)
00003B44  242E 0008 7135          move.l    8(A6),D2
00003B48  0C82 0000 7136          cmp.l     #10,D2
00003B4C  000A      
00003B4E  660A      7137          bne.s     putch_1
00003B50  4878 000D 7138          pea       13
00003B54  6100 D03C 7139          bsr       __putch
00003B58  584F      7140          addq.w    #4,A7
                    7141   putch_1:
00003B5A  2F02      7142          move.l    D2,-(A7)
00003B5C  6100 D034 7143          bsr       __putch
00003B60  584F      7144          addq.w    #4,A7
00003B62  2002      7145          move.l    D2,D0
00003B64  4CDF 0004 7146          movem.l   (A7)+,D2
00003B68  4E5E      7147          unlk      A6
00003B6A  4E75      7148          rts
                    7149   _getch:
00003B6C  48E7 2000 7150          movem.l   D2,-(A7)
00003B70  2439 0B00 7151          move.l    __ungetbuf,D2
00003B74  00C0      
00003B76  2039 0B00 7152          move.l    __ungetbuf,D0
00003B7A  00C0      
00003B7C  0C80 FFFF 7153          cmp.l     #-1,D0
00003B80  FFFF      
00003B82  670C      7154          beq.s     getch_1
00003B84  23FC FFFF 7155          move.l    #-1,__ungetbuf
00003B88  FFFF 0B00 
00003B8C  00C0      
00003B8E  6010      7156          bra.s     getch_3
                    7157   getch_1:
00003B90  6100 D02C 7158          bsr       __getch
00003B94  2400      7159          move.l    D0,D2
00003B96  0C80 0000 7160          cmp.l     #13,D0
00003B9A  000D      
00003B9C  6602      7161          bne.s     getch_3
00003B9E  740A      7162          moveq     #10,D2
                    7163   getch_3:
00003BA0  2002      7164          move.l    D2,D0
00003BA2  4CDF 0004 7165          movem.l   (A7)+,D2
00003BA6  4E75      7166          rts
                    7167   _tolower:
00003BA8  4E56 0000 7168          link      A6,#0
00003BAC  48E7 2000 7169          movem.l   D2,-(A7)
00003BB0  242E 0008 7170          move.l    8(A6),D2
00003BB4  0C82 0000 7171          cmp.l     #65,D2
00003BB8  0041      
00003BBA  6D0E      7172          blt.s     tolower_1
00003BBC  0C82 0000 7173          cmp.l     #90,D2
00003BC0  005A      
00003BC2  6E06      7174          bgt.s     tolower_1
00003BC4  84BC 0000 7175          or.l      #32,D2
00003BC8  0020      
                    7176   tolower_1:
00003BCA  2002      7177          move.l    D2,D0
00003BCC  4CDF 0004 7178          movem.l   (A7)+,D2
00003BD0  4E5E      7179          unlk      A6
00003BD2  4E75      7180          rts
                    7181   _sprintf:
00003BD4  4E56 FFFC 7182          link      A6,#-4
00003BD8  48E7 2000 7183          movem.l   D2,-(A7)
00003BDC  41EE 000C 7184          lea       12(A6),A0
00003BE0  5848      7185          addq.w    #4,A0
00003BE2  2408      7186          move.l    A0,D2
00003BE4  2F02      7187          move.l    D2,-(A7)
00003BE6  2F2E 000C 7188          move.l    12(A6),-(A7)
00003BEA  2F2E 0008 7189          move.l    8(A6),-(A7)
00003BEE  6100 09BA 7190          bsr       _vsprintf
00003BF2  DEFC 000C 7191          add.w     #12,A7
00003BF6  2D40 FFFC 7192          move.l    D0,-4(A6)
00003BFA  4282      7193          clr.l     D2
00003BFC  202E FFFC 7194          move.l    -4(A6),D0
00003C00  4CDF 0004 7195          movem.l   (A7)+,D2
00003C04  4E5E      7196          unlk      A6
00003C06  4E75      7197          rts
                    7198   _memset:
00003C08  206F 0004 7199          move.l    (4,A7),A0
00003C0C  202F 0008 7200          move.l    (8,A7),D0
00003C10  222F 000C 7201          move.l    (12,A7),D1
00003C14  2248      7202          move.l    A0,A1	
                    7203   memset_1:
00003C16  12C0      7204          move.b    D0,(A1)+
00003C18  5341      7205          subq      #1,D1
00003C1A  66FA      7206          bne       memset_1
00003C1C  2008      7207          move.l    A0,D0
00003C1E  4E75      7208          rts
                    7209   _strcat:
00003C20  206F 0004 7210          move.l    (4,A7),A0	
00003C24  226F 0008 7211          move.l    (8,A7),A1	
00003C28  2008      7212          move.l    A0,D0		
                    7213   strcat_0:
00003C2A  4A18      7214          tst.b     (A0)+
00003C2C  66FC      7215          bne       strcat_0
00003C2E  5348      7216          subq      #1,A0
                    7217   strcat_1:
00003C30  10D9      7218          move.b    (A1)+,(A0)+
00003C32  66FC      7219          bne       strcat_1
00003C34  4E75      7220          rts
                    7221   _toupper:
00003C36  4E56 0000 7222          link      A6,#0
00003C3A  48E7 2000 7223          movem.l   D2,-(A7)
00003C3E  242E 0008 7224          move.l    8(A6),D2
00003C42  0C82 0000 7225          cmp.l     #97,D2
00003C46  0061      
00003C48  6D0E      7226          blt.s     toupper_1
00003C4A  0C82 0000 7227          cmp.l     #122,D2
00003C4E  007A      
00003C50  6E06      7228          bgt.s     toupper_1
00003C52  C4BC 0000 7229          and.l     #95,D2
00003C56  005F      
                    7230   toupper_1:
00003C58  2002      7231          move.l    D2,D0
00003C5A  4CDF 0004 7232          movem.l   (A7)+,D2
00003C5E  4E5E      7233          unlk      A6
00003C60  4E75      7234          rts
                    7235   @vsscanf_scanread:
00003C62  4E56 FFFC 7236          link      A6,#-4
00003C66  48E7 0020 7237          movem.l   A2,-(A7)
00003C6A  45F9 0000 7238          lea       @vsscanf_bufx,A2
00003C6E  672A      
00003C70  4AAE 0008 7239          tst.l     8(A6)
00003C74  6722      7240          beq.s     @vsscanf_scanread_1
00003C76  206E 0008 7241          move.l    8(A6),A0
00003C7A  58AE 0008 7242          addq.l    #4,8(A6)
00003C7E  2050      7243          move.l    (A0),A0
00003C80  1010      7244          move.b    (A0),D0
00003C82  4880      7245          ext.w     D0
00003C84  48C0      7246          ext.l     D0
00003C86  2D40 FFFC 7247          move.l    D0,-4(A6)
00003C8A  6706      7248          beq.s     @vsscanf_scanread_3
00003C8C  202E FFFC 7249          move.l    -4(A6),D0
00003C90  6002      7250          bra.s     @vsscanf_scanread_4
                    7251   @vsscanf_scanread_3:
00003C92  70FF      7252          moveq     #-1,D0
                    7253   @vsscanf_scanread_4:
00003C94  6000 0032 7254          bra       @vsscanf_scanread_5
                    7255   @vsscanf_scanread_1:
00003C98  2052      7256          move.l    (A2),A0
00003C9A  1010      7257          move.b    (A0),D0
00003C9C  6620      7258          bne.s     @vsscanf_scanread_6
00003C9E  4879 0B00 7259          pea       @vsscanf_buf
00003CA2  0546      
00003CA4  6100 1006 7260          bsr       _gets
00003CA8  584F      7261          addq.w    #4,A7
00003CAA  2480      7262          move.l    D0,(A2)
00003CAC  4879 0000 7263          pea       @vsscanf_1
00003CB0  672E      
00003CB2  4879 0B00 7264          pea       @vsscanf_buf
00003CB6  0546      
00003CB8  6100 FF66 7265          bsr       _strcat
00003CBC  504F      7266          addq.w    #8,A7
                    7267   @vsscanf_scanread_6:
00003CBE  2052      7268          move.l    (A2),A0
00003CC0  5292      7269          addq.l    #1,(A2)
00003CC2  1010      7270          move.b    (A0),D0
00003CC4  4880      7271          ext.w     D0
00003CC6  48C0      7272          ext.l     D0
                    7273   @vsscanf_scanread_5:
00003CC8  4CDF 0400 7274          movem.l   (A7)+,A2
00003CCC  4E5E      7275          unlk      A6
00003CCE  4E75      7276          rts
                    7277   @vsscanf_scanputback:
00003CD0  4E56 0000 7278          link      A6,#0
00003CD4  48E7 3000 7279          movem.l   D2/D3,-(A7)
00003CD8  242E 000C 7280          move.l    12(A6),D2
00003CDC  262E 0008 7281          move.l    8(A6),D3
00003CE0  6718      7282          beq.s     @vsscanf_scanputback_1
00003CE2  0C82 FFFF 7283          cmp.l     #-1,D2
00003CE6  FFFF      
00003CE8  670A      7284          beq.s     @vsscanf_scanputback_3
00003CEA  5983      7285          subq.l    #4,D3
00003CEC  2043      7286          move.l    D3,A0
00003CEE  2050      7287          move.l    (A0),A0
00003CF0  1082      7288          move.b    D2,(A0)
00003CF2  6004      7289          bra.s     @vsscanf_scanputback_4
                    7290   @vsscanf_scanputback_3:
00003CF4  2043      7291          move.l    D3,A0
00003CF6  5390      7292          subq.l    #1,(A0)
                    7293   @vsscanf_scanputback_4:
00003CF8  602E      7294          bra.s     @vsscanf_scanputback_6
                    7295   @vsscanf_scanputback_1:
00003CFA  41F9 0B00 7296          lea       @vsscanf_buf,A0
00003CFE  0546      
00003D00  2008      7297          move.l    A0,D0
00003D02  B0B9 0000 7298          cmp.l     @vsscanf_bufx,D0
00003D06  672A      
00003D08  6610      7299          bne.s     @vsscanf_scanputback_5
00003D0A  4239 0B00 7300          clr.b     @vsscanf_buf
00003D0E  0546      
00003D10  2F02      7301          move.l    D2,-(A7)
00003D12  6100 100A 7302          bsr       _ungetch
00003D16  584F      7303          addq.w    #4,A7
00003D18  600E      7304          bra.s     @vsscanf_scanputback_6
                    7305   @vsscanf_scanputback_5:
00003D1A  53B9 0000 7306          subq.l    #1,@vsscanf_bufx
00003D1E  672A      
00003D20  2079 0000 7307          move.l    @vsscanf_bufx,A0
00003D24  672A      
00003D26  1082      7308          move.b    D2,(A0)
                    7309   @vsscanf_scanputback_6:
00003D28  2002      7310          move.l    D2,D0
00003D2A  4CDF 000C 7311          movem.l   (A7)+,D2/D3
00003D2E  4E5E      7312          unlk      A6
00003D30  4E75      7313          rts
                    7314   @vsscanf_scanspace:
00003D32  4E56 0000 7315          link      A6,#0
00003D36  48E7 2000 7316          movem.l   D2,-(A7)
                    7317   @vsscanf_scanspace_1:
00003D3A  2F2E 0008 7318          move.l    8(A6),-(A7)
00003D3E  6100 FF22 7319          bsr       @vsscanf_scanread
00003D42  584F      7320          addq.w    #4,A7
00003D44  2400      7321          move.l    D0,D2
00003D46  206E 000C 7322          move.l    12(A6),A0
00003D4A  5290      7323          addq.l    #1,(A0)
00003D4C  2042      7324          move.l    D2,A0
00003D4E  43F9 0000 7325          lea       __ctype,A1
00003D52  6730      
00003D54  1030 9801 7326          move.b    1(A0,A1.L),D0
00003D58  C03C 0010 7327          and.b     #16,D0
00003D5C  66DC      7328          bne       @vsscanf_scanspace_1
00003D5E  2002      7329          move.l    D2,D0
00003D60  4CDF 0004 7330          movem.l   (A7)+,D2
00003D64  4E5E      7331          unlk      A6
00003D66  4E75      7332          rts
                    7333   @vsscanf_scanselect:
00003D68  4E56 0000 7334          link      A6,#0
00003D6C  48E7 3F20 7335          movem.l   D2/D3/D4/D5/D6/D7/A2,-(A7)
00003D70  262E 000C 7336          move.l    12(A6),D3
00003D74  2C2E 0018 7337          move.l    24(A6),D6
00003D78  2E2E 0014 7338          move.l    20(A6),D7
00003D7C  2043      7339          move.l    D3,A0
00003D7E  1010      7340          move.b    (A0),D0
00003D80  4880      7341          ext.w     D0
00003D82  48C0      7342          ext.l     D0
00003D84  0C80 0000 7343          cmp.l     #94,D0
00003D88  005E      
00003D8A  6608      7344          bne.s     @vsscanf_scanselect_1
00003D8C  347C 0001 7345          move.w    #1,A2
00003D90  5283      7346          addq.l    #1,D3
00003D92  6004      7347          bra.s     @vsscanf_scanselect_2
                    7348   @vsscanf_scanselect_1:
00003D94  347C 0000 7349          move.w    #0,A2
                    7350   @vsscanf_scanselect_2:
00003D98  202E 0010 7351          move.l    16(A6),D0
00003D9C  53AE 0010 7352          subq.l    #1,16(A6)
00003DA0  4A80      7353          tst.l     D0
00003DA2  6700 0108 7354          beq       @vsscanf_scanselect_5
00003DA6  2F2E 0008 7355          move.l    8(A6),-(A7)
00003DAA  6100 FEB6 7356          bsr       @vsscanf_scanread
00003DAE  584F      7357          addq.w    #4,A7
00003DB0  2800      7358          move.l    D0,D4
00003DB2  0C84 FFFF 7359          cmp.l     #-1,D4
00003DB6  FFFF      
00003DB8  6604      7360          bne.s     @vsscanf_scanselect_6
00003DBA  6000 00F0 7361          bra       @vsscanf_scanselect_5
                    7362   @vsscanf_scanselect_6:
00003DBE  206E 001C 7363          move.l    28(A6),A0
00003DC2  5290      7364          addq.l    #1,(A0)
00003DC4  4285      7365          clr.l     D5
00003DC6  4282      7366          clr.l     D2
                    7367   @vsscanf_scanselect_8:
00003DC8  2043      7368          move.l    D3,A0
00003DCA  1030 2800 7369          move.b    0(A0,D2.L),D0
00003DCE  4880      7370          ext.w     D0
00003DD0  48C0      7371          ext.l     D0
00003DD2  0C80 0000 7372          cmp.l     #93,D0
00003DD6  005D      
00003DD8  6700 008E 7373          beq       @vsscanf_scanselect_10
00003DDC  4A82      7374          tst.l     D2
00003DDE  6716      7375          beq.s     @vsscanf_scanselect_11
00003DE0  2043      7376          move.l    D3,A0
00003DE2  1030 2800 7377          move.b    0(A0,D2.L),D0
00003DE6  4880      7378          ext.w     D0
00003DE8  48C0      7379          ext.l     D0
00003DEA  0C80 0000 7380          cmp.l     #93,D0
00003DEE  005D      
00003DF0  6604      7381          bne.s     @vsscanf_scanselect_11
00003DF2  6000 0074 7382          bra       @vsscanf_scanselect_10
                    7383   @vsscanf_scanselect_11:
00003DF6  4A82      7384          tst.l     D2
00003DF8  6700 0058 7385          beq       @vsscanf_scanselect_15
00003DFC  2043      7386          move.l    D3,A0
00003DFE  1030 2800 7387          move.b    0(A0,D2.L),D0
00003E02  4880      7388          ext.w     D0
00003E04  48C0      7389          ext.l     D0
00003E06  0C80 0000 7390          cmp.l     #45,D0
00003E0A  002D      
00003E0C  6600 0044 7391          bne       @vsscanf_scanselect_15
00003E10  2043      7392          move.l    D3,A0
00003E12  2002      7393          move.l    D2,D0
00003E14  5380      7394          subq.l    #1,D0
00003E16  2243      7395          move.l    D3,A1
00003E18  2F08      7396          move.l    A0,-(A7)
00003E1A  2042      7397          move.l    D2,A0
00003E1C  1230 0800 7398          move.b    0(A0,D0.L),D1
00003E20  B230 9801 7399          cmp.b     1(A0,A1.L),D1
00003E24  6C00 002C 7400          bge       @vsscanf_scanselect_15
00003E28  205F      7401          move.l    (A7)+,A0
00003E2A  2043      7402          move.l    D3,A0
00003E2C  2002      7403          move.l    D2,D0
00003E2E  5380      7404          subq.l    #1,D0
00003E30  1030 0800 7405          move.b    0(A0,D0.L),D0
00003E34  4880      7406          ext.w     D0
00003E36  48C0      7407          ext.l     D0
00003E38  B880      7408          cmp.l     D0,D4
00003E3A  6D12      7409          blt.s     @vsscanf_scanselect_17
00003E3C  2043      7410          move.l    D3,A0
00003E3E  2242      7411          move.l    D2,A1
00003E40  1031 8801 7412          move.b    1(A1,A0.L),D0
00003E44  4880      7413          ext.w     D0
00003E46  48C0      7414          ext.l     D0
00003E48  B880      7415          cmp.l     D0,D4
00003E4A  6E02      7416          bgt.s     @vsscanf_scanselect_17
00003E4C  601A      7417          bra.s     @vsscanf_scanselect_10
                    7418   @vsscanf_scanselect_17:
00003E4E  5282      7419          addq.l    #1,D2
00003E50  6010      7420          bra.s     @vsscanf_scanselect_19
                    7421   @vsscanf_scanselect_15:
00003E52  2043      7422          move.l    D3,A0
00003E54  1030 2800 7423          move.b    0(A0,D2.L),D0
00003E58  4880      7424          ext.w     D0
00003E5A  48C0      7425          ext.l     D0
00003E5C  B880      7426          cmp.l     D0,D4
00003E5E  6602      7427          bne.s     @vsscanf_scanselect_19
00003E60  6006      7428          bra.s     @vsscanf_scanselect_10
                    7429   @vsscanf_scanselect_19:
00003E62  5282      7430          addq.l    #1,D2
00003E64  6000 FF62 7431          bra       @vsscanf_scanselect_8
                    7432   @vsscanf_scanselect_10:
00003E68  4A82      7433          tst.l     D2
00003E6A  6712      7434          beq.s     @vsscanf_scanselect_23
00003E6C  2043      7435          move.l    D3,A0
00003E6E  1030 2800 7436          move.b    0(A0,D2.L),D0
00003E72  4880      7437          ext.w     D0
00003E74  48C0      7438          ext.l     D0
00003E76  0C80 0000 7439          cmp.l     #93,D0
00003E7A  005D      
00003E7C  6702      7440          beq.s     @vsscanf_scanselect_21
                    7441   @vsscanf_scanselect_23:
00003E7E  7A01      7442          moveq     #1,D5
                    7443   @vsscanf_scanselect_21:
00003E80  200A      7444          move.l    A2,D0
00003E82  6712      7445          beq.s     @vsscanf_scanselect_24
00003E84  4A85      7446          tst.l     D5
00003E86  660C      7447          bne.s     @vsscanf_scanselect_26
00003E88  4A87      7448          tst.l     D7
00003E8A  6606      7449          bne.s     @vsscanf_scanselect_28
00003E8C  2046      7450          move.l    D6,A0
00003E8E  5286      7451          addq.l    #1,D6
00003E90  1084      7452          move.b    D4,(A0)
                    7453   @vsscanf_scanselect_28:
00003E92  6014      7454          bra.s     @vsscanf_scanselect_4
                    7455   @vsscanf_scanselect_26:
00003E94  6016      7456          bra.s     @vsscanf_scanselect_5
                    7457   @vsscanf_scanselect_24:
00003E96  4A85      7458          tst.l     D5
00003E98  670C      7459          beq.s     @vsscanf_scanselect_30
00003E9A  4A87      7460          tst.l     D7
00003E9C  6606      7461          bne.s     @vsscanf_scanselect_32
00003E9E  2046      7462          move.l    D6,A0
00003EA0  5286      7463          addq.l    #1,D6
00003EA2  1084      7464          move.b    D4,(A0)
                    7465   @vsscanf_scanselect_32:
00003EA4  6002      7466          bra.s     @vsscanf_scanselect_4
                    7467   @vsscanf_scanselect_30:
00003EA6  6004      7468          bra.s     @vsscanf_scanselect_5
                    7469   @vsscanf_scanselect_4:
00003EA8  6000 FEEE 7470          bra       @vsscanf_scanselect_2
                    7471   @vsscanf_scanselect_5:
00003EAC  0C84 FFFF 7472          cmp.l     #-1,D4
00003EB0  FFFF      
00003EB2  6712      7473          beq.s     @vsscanf_scanselect_34
00003EB4  2F04      7474          move.l    D4,-(A7)
00003EB6  2F2E 0008 7475          move.l    8(A6),-(A7)
00003EBA  6100 FE14 7476          bsr       @vsscanf_scanputback
00003EBE  504F      7477          addq.w    #8,A7
00003EC0  206E 001C 7478          move.l    28(A6),A0
00003EC4  5390      7479          subq.l    #1,(A0)
                    7480   @vsscanf_scanselect_34:
00003EC6  4A87      7481          tst.l     D7
00003EC8  6604      7482          bne.s     @vsscanf_scanselect_36
00003ECA  2046      7483          move.l    D6,A0
00003ECC  4210      7484          clr.b     (A0)
                    7485   @vsscanf_scanselect_36:
00003ECE  5283      7486          addq.l    #1,D3
00003ED0  2043      7487          move.l    D3,A0
00003ED2  1010      7488          move.b    (A0),D0
00003ED4  4880      7489          ext.w     D0
00003ED6  48C0      7490          ext.l     D0
00003ED8  0C80 0000 7491          cmp.l     #93,D0
00003EDC  005D      
00003EDE  6702      7492          beq.s     @vsscanf_scanselect_40
00003EE0  60EC      7493          bra       @vsscanf_scanselect_36
                    7494   @vsscanf_scanselect_40:
00003EE2  5283      7495          addq.l    #1,D3
00003EE4  2003      7496          move.l    D3,D0
00003EE6  4CDF 04FC 7497          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2
00003EEA  4E5E      7498          unlk      A6
00003EEC  4E75      7499          rts
                    7500   _scanflush:
00003EEE  41F9 0B00 7501          lea       @vsscanf_buf,A0
00003EF2  0546      
00003EF4  23C8 0000 7502          move.l    A0,@vsscanf_bufx
00003EF8  672A      
00003EFA  4239 0B00 7503          clr.b     @vsscanf_buf
00003EFE  0546      
00003F00  4878 FFFF 7504          pea       -1
00003F04  6100 0E18 7505          bsr       _ungetch
00003F08  584F      7506          addq.w    #4,A7
00003F0A  4E75      7507          rts
                    7508   _vsscanf:
00003F0C  4E56 FF88 7509          link      A6,#-120
00003F10  48E7 3F3C 7510          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
00003F14  47F8 3C62 7511          lea       @vsscanf_scanread,A3
00003F18  4AAE 0008 7512          tst.l     8(A6)
00003F1C  6706      7513          beq.s     vsscanf_1
00003F1E  41EE 0008 7514          lea       8(A6),A0
00003F22  6004      7515          bra.s     vsscanf_2
                    7516   vsscanf_1:
00003F24  4280      7517          clr.l     D0
00003F26  2040      7518          move.l    D0,A0
                    7519   vsscanf_2:
00003F28  2A08      7520          move.l    A0,D5
00003F2A  42AE FFE4 7521          clr.l     -28(A6)
00003F2E  4284      7522          clr.l     D4
                    7523   vsscanf_3:
00003F30  206E 000C 7524          move.l    12(A6),A0
00003F34  52AE 000C 7525          addq.l    #1,12(A6)
00003F38  1010      7526          move.b    (A0),D0
00003F3A  4880      7527          ext.w     D0
00003F3C  48C0      7528          ext.l     D0
00003F3E  2600      7529          move.l    D0,D3
00003F40  6700 05AC 7530          beq       vsscanf_5
00003F44  4286      7531          clr.l     D6
00003F46  387C 0000 7532          move.w    #0,A4
00003F4A  0C83 0000 7533          cmp.l     #32,D3
00003F4E  0020      
00003F50  6712      7534          beq.s     vsscanf_8
00003F52  0C83 0000 7535          cmp.l     #9,D3
00003F56  0009      
00003F58  670A      7536          beq.s     vsscanf_8
00003F5A  0C83 0000 7537          cmp.l     #10,D3
00003F5E  000A      
00003F60  6600 0048 7538          bne       vsscanf_6
                    7539   vsscanf_8:
00003F64  2F05      7540          move.l    D5,-(A7)
00003F66  4E93      7541          jsr       (A3)
00003F68  584F      7542          addq.w    #4,A7
00003F6A  2400      7543          move.l    D0,D2
00003F6C  52AE FFE4 7544          addq.l    #1,-28(A6)
00003F70  0C82 FFFF 7545          cmp.l     #-1,D2
00003F74  FFFF      
00003F76  660E      7546          bne.s     vsscanf_11
00003F78  4A84      7547          tst.l     D4
00003F7A  6704      7548          beq.s     vsscanf_13
00003F7C  2004      7549          move.l    D4,D0
00003F7E  6002      7550          bra.s     vsscanf_14
                    7551   vsscanf_13:
00003F80  70FF      7552          moveq     #-1,D0
                    7553   vsscanf_14:
00003F82  6000 056C 7554          bra       vsscanf_15
                    7555   vsscanf_11:
00003F86  2042      7556          move.l    D2,A0
00003F88  43F9 0000 7557          lea       __ctype,A1
00003F8C  6730      
00003F8E  1030 9801 7558          move.b    1(A0,A1.L),D0
00003F92  C03C 0010 7559          and.b     #16,D0
00003F96  66CC      7560          bne       vsscanf_8
00003F98  53AE FFE4 7561          subq.l    #1,-28(A6)
00003F9C  2F02      7562          move.l    D2,-(A7)
00003F9E  2F05      7563          move.l    D5,-(A7)
00003FA0  6100 FD2E 7564          bsr       @vsscanf_scanputback
00003FA4  504F      7565          addq.w    #8,A7
00003FA6  6000 0542 7566          bra       vsscanf_139
                    7567   vsscanf_6:
00003FAA  0C83 0000 7568          cmp.l     #37,D3
00003FAE  0025      
00003FB0  6600 0502 7569          bne       vsscanf_127
00003FB4  206E 000C 7570          move.l    12(A6),A0
00003FB8  52AE 000C 7571          addq.l    #1,12(A6)
00003FBC  1010      7572          move.b    (A0),D0
00003FBE  4880      7573          ext.w     D0
00003FC0  48C0      7574          ext.l     D0
00003FC2  2600      7575          move.l    D0,D3
00003FC4  42AE FFEC 7576          clr.l     -20(A6)
00003FC8  4286      7577          clr.l     D6
00003FCA  42AE FFE8 7578          clr.l     -24(A6)
00003FCE  347C 7FFF 7579          move.w    #32767,A2
00003FD2  0C83 0000 7580          cmp.l     #42,D3
00003FD6  002A      
00003FD8  6612      7581          bne.s     vsscanf_18
00003FDA  7C01      7582          moveq     #1,D6
00003FDC  206E 000C 7583          move.l    12(A6),A0
00003FE0  52AE 000C 7584          addq.l    #1,12(A6)
00003FE4  1010      7585          move.b    (A0),D0
00003FE6  4880      7586          ext.w     D0
00003FE8  48C0      7587          ext.l     D0
00003FEA  2600      7588          move.l    D0,D3
                    7589   vsscanf_18:
00003FEC  2043      7590          move.l    D3,A0
00003FEE  43F9 0000 7591          lea       __ctype,A1
00003FF2  6730      
00003FF4  1030 9801 7592          move.b    1(A0,A1.L),D0
00003FF8  C03C 0004 7593          and.b     #4,D0
00003FFC  6700 004E 7594          beq       vsscanf_24
00004000  2003      7595          move.l    D3,D0
00004002  0480 0000 7596          sub.l     #48,D0
00004006  0030      
00004008  2440      7597          move.l    D0,A2
                    7598   vsscanf_22:
0000400A  206E 000C 7599          move.l    12(A6),A0
0000400E  52AE 000C 7600          addq.l    #1,12(A6)
00004012  1010      7601          move.b    (A0),D0
00004014  4880      7602          ext.w     D0
00004016  48C0      7603          ext.l     D0
00004018  2600      7604          move.l    D0,D3
0000401A  2040      7605          move.l    D0,A0
0000401C  43F9 0000 7606          lea       __ctype,A1
00004020  6730      
00004022  1030 9801 7607          move.b    1(A0,A1.L),D0
00004026  C0BC 0000 7608          and.l     #255,D0
0000402A  00FF      
0000402C  C0BC 0000 7609          and.l     #4,D0
00004030  0004      
00004032  6718      7610          beq.s     vsscanf_24
00004034  70D0      7611          moveq     #-48,D0
00004036  2F0A      7612          move.l    A2,-(A7)
00004038  4878 000A 7613          pea       10
0000403C  6100 0BE0 7614          bsr       LMUL
00004040  2217      7615          move.l    (A7),D1
00004042  504F      7616          addq.w    #8,A7
00004044  D283      7617          add.l     D3,D1
00004046  D081      7618          add.l     D1,D0
00004048  2440      7619          move.l    D0,A2
0000404A  60BE      7620          bra       vsscanf_22
                    7621   vsscanf_24:
0000404C  0C83 0000 7622          cmp.l     #108,D3
00004050  006C      
00004052  6708      7623          beq.s     vsscanf_27
00004054  0C83 0000 7624          cmp.l     #76,D3
00004058  004C      
0000405A  661A      7625          bne.s     vsscanf_25
                    7626   vsscanf_27:
0000405C  2D7C 0000 7627          move.l    #1,-24(A6)
00004060  0001 FFE8 
00004064  206E 000C 7628          move.l    12(A6),A0
00004068  52AE 000C 7629          addq.l    #1,12(A6)
0000406C  1010      7630          move.b    (A0),D0
0000406E  4880      7631          ext.w     D0
00004070  48C0      7632          ext.l     D0
00004072  2600      7633          move.l    D0,D3
00004074  6020      7634          bra.s     vsscanf_28
                    7635   vsscanf_25:
00004076  0C83 0000 7636          cmp.l     #104,D3
0000407A  0068      
0000407C  6618      7637          bne.s     vsscanf_28
0000407E  2D7C 0000 7638          move.l    #1,-20(A6)
00004082  0001 FFEC 
00004086  206E 000C 7639          move.l    12(A6),A0
0000408A  52AE 000C 7640          addq.l    #1,12(A6)
0000408E  1010      7641          move.b    (A0),D0
00004090  4880      7642          ext.w     D0
00004092  48C0      7643          ext.l     D0
00004094  2600      7644          move.l    D0,D3
                    7645   vsscanf_28:
00004096  0C83 0000 7646          cmp.l     #91,D3
0000409A  005B      
0000409C  6600 0036 7647          bne       vsscanf_30
000040A0  4A86      7648          tst.l     D6
000040A2  660A      7649          bne.s     vsscanf_32
000040A4  206E 0010 7650          move.l    16(A6),A0
000040A8  58AE 0010 7651          addq.l    #4,16(A6)
000040AC  2E10      7652          move.l    (A0),D7
                    7653   vsscanf_32:
000040AE  486E FFE4 7654          pea       -28(A6)
000040B2  2F07      7655          move.l    D7,-(A7)
000040B4  2F06      7656          move.l    D6,-(A7)
000040B6  2F0A      7657          move.l    A2,-(A7)
000040B8  2F2E 000C 7658          move.l    12(A6),-(A7)
000040BC  2F05      7659          move.l    D5,-(A7)
000040BE  6100 FCA8 7660          bsr       @vsscanf_scanselect
000040C2  DEFC 0018 7661          add.w     #24,A7
000040C6  2D40 000C 7662          move.l    D0,12(A6)
000040CA  4A86      7663          tst.l     D6
000040CC  6602      7664          bne.s     vsscanf_34
000040CE  5284      7665          addq.l    #1,D4
                    7666   vsscanf_34:
000040D0  6000 0418 7667          bra       vsscanf_139
                    7668   vsscanf_30:
000040D4  0C83 0000 7669          cmp.l     #110,D3
000040D8  006E      
000040DA  661A      7670          bne.s     vsscanf_36
000040DC  4A86      7671          tst.l     D6
000040DE  6612      7672          bne.s     vsscanf_38
000040E0  206E 0010 7673          move.l    16(A6),A0
000040E4  58AE 0010 7674          addq.l    #4,16(A6)
000040E8  2E10      7675          move.l    (A0),D7
000040EA  2047      7676          move.l    D7,A0
000040EC  20AE FFE4 7677          move.l    -28(A6),(A0)
000040F0  5284      7678          addq.l    #1,D4
                    7679   vsscanf_38:
000040F2  6000 03F6 7680          bra       vsscanf_139
                    7681   vsscanf_36:
000040F6  0C83 0000 7682          cmp.l     #115,D3
000040FA  0073      
000040FC  6600 00AC 7683          bne       vsscanf_40
00004100  486E FFE4 7684          pea       -28(A6)
00004104  2F05      7685          move.l    D5,-(A7)
00004106  6100 FC2A 7686          bsr       @vsscanf_scanspace
0000410A  504F      7687          addq.w    #8,A7
0000410C  2400      7688          move.l    D0,D2
0000410E  4A86      7689          tst.l     D6
00004110  660A      7690          bne.s     vsscanf_42
00004112  206E 0010 7691          move.l    16(A6),A0
00004116  58AE 0010 7692          addq.l    #4,16(A6)
0000411A  2E10      7693          move.l    (A0),D7
                    7694   vsscanf_42:
0000411C  52AE FFE4 7695          addq.l    #1,-28(A6)
                    7696   vsscanf_44:
00004120  200A      7697          move.l    A2,D0
00004122  534A      7698          subq.w    #1,A2
00004124  4A80      7699          tst.l     D0
00004126  6700 0038 7700          beq       vsscanf_46
0000412A  2042      7701          move.l    D2,A0
0000412C  43F9 0000 7702          lea       __ctype,A1
00004130  6730      
00004132  1030 9801 7703          move.b    1(A0,A1.L),D0
00004136  C03C 0010 7704          and.b     #16,D0
0000413A  6624      7705          bne.s     vsscanf_46
0000413C  0C82 FFFF 7706          cmp.l     #-1,D2
00004140  FFFF      
00004142  671C      7707          beq.s     vsscanf_46
00004144  387C 0001 7708          move.w    #1,A4
00004148  4A86      7709          tst.l     D6
0000414A  6606      7710          bne.s     vsscanf_47
0000414C  2047      7711          move.l    D7,A0
0000414E  5287      7712          addq.l    #1,D7
00004150  1082      7713          move.b    D2,(A0)
                    7714   vsscanf_47:
00004152  2F05      7715          move.l    D5,-(A7)
00004154  4E93      7716          jsr       (A3)
00004156  584F      7717          addq.w    #4,A7
00004158  2400      7718          move.l    D0,D2
0000415A  52AE FFE4 7719          addq.l    #1,-28(A6)
0000415E  60C0      7720          bra       vsscanf_44
                    7721   vsscanf_46:
00004160  4A86      7722          tst.l     D6
00004162  660A      7723          bne.s     vsscanf_51
00004164  2047      7724          move.l    D7,A0
00004166  4210      7725          clr.b     (A0)
00004168  200C      7726          move.l    A4,D0
0000416A  6702      7727          beq.s     vsscanf_51
0000416C  5284      7728          addq.l    #1,D4
                    7729   vsscanf_51:
0000416E  0C82 FFFF 7730          cmp.l     #-1,D2
00004172  FFFF      
00004174  6708      7731          beq.s     vsscanf_55
00004176  4A86      7732          tst.l     D6
00004178  661E      7733          bne.s     vsscanf_53
0000417A  200C      7734          move.l    A4,D0
0000417C  661A      7735          bne.s     vsscanf_53
                    7736   vsscanf_55:
0000417E  4A84      7737          tst.l     D4
00004180  6704      7738          beq.s     vsscanf_56
00004182  2004      7739          move.l    D4,D0
00004184  600E      7740          bra.s     vsscanf_59
                    7741   vsscanf_56:
00004186  0C82 FFFF 7742          cmp.l     #-1,D2
0000418A  FFFF      
0000418C  6604      7743          bne.s     vsscanf_58
0000418E  70FF      7744          moveq     #-1,D0
00004190  6002      7745          bra.s     vsscanf_59
                    7746   vsscanf_58:
00004192  2004      7747          move.l    D4,D0
                    7748   vsscanf_59:
00004194  6000 035A 7749          bra       vsscanf_15
                    7750   vsscanf_53:
00004198  53AE FFE4 7751          subq.l    #1,-28(A6)
0000419C  2F02      7752          move.l    D2,-(A7)
0000419E  2F05      7753          move.l    D5,-(A7)
000041A0  6100 FB2E 7754          bsr       @vsscanf_scanputback
000041A4  504F      7755          addq.w    #8,A7
000041A6  6000 0342 7756          bra       vsscanf_139
                    7757   vsscanf_40:
000041AA  0C83 0000 7758          cmp.l     #99,D3
000041AE  0063      
000041B0  6600 008E 7759          bne       vsscanf_60
000041B4  4A86      7760          tst.l     D6
000041B6  660A      7761          bne.s     vsscanf_62
000041B8  206E 0010 7762          move.l    16(A6),A0
000041BC  58AE 0010 7763          addq.l    #4,16(A6)
000041C0  2E10      7764          move.l    (A0),D7
                    7765   vsscanf_62:
000041C2  2F05      7766          move.l    D5,-(A7)
000041C4  4E93      7767          jsr       (A3)
000041C6  584F      7768          addq.w    #4,A7
000041C8  2400      7769          move.l    D0,D2
000041CA  52AE FFE4 7770          addq.l    #1,-28(A6)
000041CE  200A      7771          move.l    A2,D0
000041D0  0C80 0000 7772          cmp.l     #32767,D0
000041D4  7FFF      
000041D6  6604      7773          bne.s     vsscanf_64
000041D8  347C 0001 7774          move.w    #1,A2
                    7775   vsscanf_64:
000041DC  0C82 FFFF 7776          cmp.l     #-1,D2
000041E0  FFFF      
000041E2  6606      7777          bne.s     vsscanf_66
000041E4  4A86      7778          tst.l     D6
000041E6  6602      7779          bne.s     vsscanf_66
000041E8  5384      7780          subq.l    #1,D4
                    7781   vsscanf_66:
000041EA  200A      7782          move.l    A2,D0
000041EC  534A      7783          subq.w    #1,A2
000041EE  4A80      7784          tst.l     D0
000041F0  6720      7785          beq.s     vsscanf_70
000041F2  0C82 FFFF 7786          cmp.l     #-1,D2
000041F6  FFFF      
000041F8  6718      7787          beq.s     vsscanf_70
000041FA  4A86      7788          tst.l     D6
000041FC  6606      7789          bne.s     vsscanf_71
000041FE  2047      7790          move.l    D7,A0
00004200  5287      7791          addq.l    #1,D7
00004202  1082      7792          move.b    D2,(A0)
                    7793   vsscanf_71:
00004204  2F05      7794          move.l    D5,-(A7)
00004206  4E93      7795          jsr       (A3)
00004208  584F      7796          addq.w    #4,A7
0000420A  2400      7797          move.l    D0,D2
0000420C  52AE FFE4 7798          addq.l    #1,-28(A6)
00004210  60D8      7799          bra       vsscanf_66
                    7800   vsscanf_70:
00004212  0C82 FFFF 7801          cmp.l     #-1,D2
00004216  FFFF      
00004218  660E      7802          bne.s     vsscanf_73
0000421A  4A84      7803          tst.l     D4
0000421C  6704      7804          beq.s     vsscanf_75
0000421E  2004      7805          move.l    D4,D0
00004220  6002      7806          bra.s     vsscanf_76
                    7807   vsscanf_75:
00004222  70FF      7808          moveq     #-1,D0
                    7809   vsscanf_76:
00004224  6000 02CA 7810          bra       vsscanf_15
                    7811   vsscanf_73:
00004228  4A86      7812          tst.l     D6
0000422A  6602      7813          bne.s     vsscanf_77
0000422C  5284      7814          addq.l    #1,D4
                    7815   vsscanf_77:
0000422E  53AE FFE4 7816          subq.l    #1,-28(A6)
00004232  2F02      7817          move.l    D2,-(A7)
00004234  2F05      7818          move.l    D5,-(A7)
00004236  6100 FA98 7819          bsr       @vsscanf_scanputback
0000423A  504F      7820          addq.w    #8,A7
0000423C  6000 02AC 7821          bra       vsscanf_139
                    7822   vsscanf_60:
00004240  0C83 0000 7823          cmp.l     #105,D3
00004244  0069      
00004246  6600 0060 7824          bne       vsscanf_82
0000424A  486E FFE4 7825          pea       -28(A6)
0000424E  2F05      7826          move.l    D5,-(A7)
00004250  6100 FAE0 7827          bsr       @vsscanf_scanspace
00004254  504F      7828          addq.w    #8,A7
00004256  2400      7829          move.l    D0,D2
00004258  0C82 0000 7830          cmp.l     #48,D2
0000425C  0030      
0000425E  6600 0038 7831          bne       vsscanf_81
00004262  387C 0001 7832          move.w    #1,A4
00004266  2F05      7833          move.l    D5,-(A7)
00004268  4E93      7834          jsr       (A3)
0000426A  584F      7835          addq.w    #4,A7
0000426C  2400      7836          move.l    D0,D2
0000426E  2F02      7837          move.l    D2,-(A7)
00004270  6100 F936 7838          bsr       _tolower
00004274  584F      7839          addq.w    #4,A7
00004276  0C80 0000 7840          cmp.l     #120,D0
0000427A  0078      
0000427C  6604      7841          bne.s     vsscanf_83
0000427E  7678      7842          moveq     #120,D3
00004280  6010      7843          bra.s     vsscanf_84
                    7844   vsscanf_83:
00004282  53AE FFE4 7845          subq.l    #1,-28(A6)
00004286  2F02      7846          move.l    D2,-(A7)
00004288  2F05      7847          move.l    D5,-(A7)
0000428A  6100 FA44 7848          bsr       @vsscanf_scanputback
0000428E  504F      7849          addq.w    #8,A7
00004290  766F      7850          moveq     #111,D3
                    7851   vsscanf_84:
00004292  52AE FFE4 7852          addq.l    #1,-28(A6)
00004296  6010      7853          bra.s     vsscanf_82
                    7854   vsscanf_81:
00004298  53AE FFE4 7855          subq.l    #1,-28(A6)
0000429C  2F02      7856          move.l    D2,-(A7)
0000429E  2F05      7857          move.l    D5,-(A7)
000042A0  6100 FA2E 7858          bsr       @vsscanf_scanputback
000042A4  504F      7859          addq.w    #8,A7
000042A6  7664      7860          moveq     #100,D3
                    7861   vsscanf_82:
000042A8  0C83 0000 7862          cmp.l     #100,D3
000042AC  0064      
000042AE  671A      7863          beq.s     vsscanf_87
000042B0  0C83 0000 7864          cmp.l     #117,D3
000042B4  0075      
000042B6  6712      7865          beq.s     vsscanf_87
000042B8  0C83 0000 7866          cmp.l     #120,D3
000042BC  0078      
000042BE  670A      7867          beq.s     vsscanf_87
000042C0  0C83 0000 7868          cmp.l     #111,D3
000042C4  006F      
000042C6  6600 01A4 7869          bne       vsscanf_85
                    7870   vsscanf_87:
000042CA  486E FFE4 7871          pea       -28(A6)
000042CE  2F05      7872          move.l    D5,-(A7)
000042D0  6100 FA60 7873          bsr       @vsscanf_scanspace
000042D4  504F      7874          addq.w    #8,A7
000042D6  2400      7875          move.l    D0,D2
000042D8  2D7C 0000 7876          move.l    #10,-4(A6)
000042DC  000A FFFC 
000042E0  0C83 0000 7877          cmp.l     #120,D3
000042E4  0078      
000042E6  6608      7878          bne.s     vsscanf_88
000042E8  2D7C 0000 7879          move.l    #16,-4(A6)
000042EC  0010 FFFC 
                    7880   vsscanf_88:
000042F0  0C83 0000 7881          cmp.l     #111,D3
000042F4  006F      
000042F6  6608      7882          bne.s     vsscanf_90
000042F8  2D7C 0000 7883          move.l    #8,-4(A6)
000042FC  0008 FFFC 
                    7884   vsscanf_90:
00004300  4A86      7885          tst.l     D6
00004302  660A      7886          bne.s     vsscanf_92
00004304  206E 0010 7887          move.l    16(A6),A0
00004308  58AE 0010 7888          addq.l    #4,16(A6)
0000430C  2E10      7889          move.l    (A0),D7
                    7890   vsscanf_92:
0000430E  42AE FFE0 7891          clr.l     -32(A6)
00004312  52AE FFE4 7892          addq.l    #1,-28(A6)
00004316  0C83 0000 7893          cmp.l     #117,D3
0000431A  0075      
0000431C  6720      7894          beq.s     vsscanf_94
0000431E  0C82 0000 7895          cmp.l     #45,D2
00004322  002D      
00004324  6618      7896          bne.s     vsscanf_94
00004326  2F05      7897          move.l    D5,-(A7)
00004328  4E93      7898          jsr       (A3)
0000432A  584F      7899          addq.w    #4,A7
0000432C  2400      7900          move.l    D0,D2
0000432E  52AE FFE4 7901          addq.l    #1,-28(A6)
00004332  2D7C 0000 7902          move.l    #1,-32(A6)
00004336  0001 FFE0 
0000433A  387C 0001 7903          move.w    #1,A4
                    7904   vsscanf_94:
0000433E  3A7C 0000 7905          move.w    #0,A5
00004342  0C82 FFFF 7906          cmp.l     #-1,D2
00004346  FFFF      
00004348  660E      7907          bne.s     vsscanf_96
0000434A  4A84      7908          tst.l     D4
0000434C  6704      7909          beq.s     vsscanf_98
0000434E  2004      7910          move.l    D4,D0
00004350  6002      7911          bra.s     vsscanf_99
                    7912   vsscanf_98:
00004352  70FF      7913          moveq     #-1,D0
                    7914   vsscanf_99:
00004354  6000 019A 7915          bra       vsscanf_15
                    7916   vsscanf_96:
00004358  200A      7917          move.l    A2,D0
0000435A  534A      7918          subq.w    #1,A2
0000435C  4A80      7919          tst.l     D0
0000435E  6700 0090 7920          beq       vsscanf_102
00004362  0C83 0000 7921          cmp.l     #120,D3
00004366  0078      
00004368  6620      7922          bne.s     vsscanf_104
0000436A  2F02      7923          move.l    D2,-(A7)
0000436C  6100 F8C8 7924          bsr       _toupper
00004370  584F      7925          addq.w    #4,A7
00004372  0C80 0000 7926          cmp.l     #65,D0
00004376  0041      
00004378  6D10      7927          blt.s     vsscanf_104
0000437A  2F02      7928          move.l    D2,-(A7)
0000437C  6100 F8B8 7929          bsr       _toupper
00004380  584F      7930          addq.w    #4,A7
00004382  0C80 0000 7931          cmp.l     #70,D0
00004386  0046      
00004388  6F14      7932          ble.s     vsscanf_103
                    7933   vsscanf_104:
0000438A  2042      7934          move.l    D2,A0
0000438C  43F9 0000 7935          lea       __ctype,A1
00004390  6730      
00004392  1030 9801 7936          move.b    1(A0,A1.L),D0
00004396  C03C 0004 7937          and.b     #4,D0
0000439A  6700 0054 7938          beq       vsscanf_102
                    7939   vsscanf_103:
0000439E  2042      7940          move.l    D2,A0
000043A0  43F9 0000 7941          lea       __ctype,A1
000043A4  6730      
000043A6  1030 9801 7942          move.b    1(A0,A1.L),D0
000043AA  C03C 0004 7943          and.b     #4,D0
000043AE  6614      7944          bne.s     vsscanf_105
000043B0  70F9      7945          moveq     #-7,D0
000043B2  2F00      7946          move.l    D0,-(A7)
000043B4  2F02      7947          move.l    D2,-(A7)
000043B6  6100 F87E 7948          bsr       _toupper
000043BA  584F      7949          addq.w    #4,A7
000043BC  2200      7950          move.l    D0,D1
000043BE  201F      7951          move.l    (A7)+,D0
000043C0  D081      7952          add.l     D1,D0
000043C2  2400      7953          move.l    D0,D2
                    7954   vsscanf_105:
000043C4  2F0D      7955          move.l    A5,-(A7)
000043C6  2F2E FFFC 7956          move.l    -4(A6),-(A7)
000043CA  6100 0852 7957          bsr       LMUL
000043CE  2017      7958          move.l    (A7),D0
000043D0  504F      7959          addq.w    #8,A7
000043D2  D082      7960          add.l     D2,D0
000043D4  0480 0000 7961          sub.l     #48,D0
000043D8  0030      
000043DA  2A40      7962          move.l    D0,A5
000043DC  2F05      7963          move.l    D5,-(A7)
000043DE  4E93      7964          jsr       (A3)
000043E0  584F      7965          addq.w    #4,A7
000043E2  2400      7966          move.l    D0,D2
000043E4  52AE FFE4 7967          addq.l    #1,-28(A6)
000043E8  387C 0001 7968          move.w    #1,A4
000043EC  6000 FF6A 7969          bra       vsscanf_96
                    7970   vsscanf_102:
000043F0  0C82 FFFF 7971          cmp.l     #-1,D2
000043F4  FFFF      
000043F6  671A      7972          beq.s     vsscanf_107
000043F8  2F02      7973          move.l    D2,-(A7)
000043FA  2F05      7974          move.l    D5,-(A7)
000043FC  6100 F8D2 7975          bsr       @vsscanf_scanputback
00004400  504F      7976          addq.w    #8,A7
00004402  53AE FFE4 7977          subq.l    #1,-28(A6)
00004406  200C      7978          move.l    A4,D0
00004408  6606      7979          bne.s     vsscanf_109
0000440A  2004      7980          move.l    D4,D0
0000440C  6000 00E2 7981          bra       vsscanf_15
                    7982   vsscanf_109:
00004410  6012      7983          bra.s     vsscanf_111
                    7984   vsscanf_107:
00004412  200C      7985          move.l    A4,D0
00004414  660E      7986          bne.s     vsscanf_111
00004416  4A84      7987          tst.l     D4
00004418  6704      7988          beq.s     vsscanf_113
0000441A  2004      7989          move.l    D4,D0
0000441C  6002      7990          bra.s     vsscanf_114
                    7991   vsscanf_113:
0000441E  70FF      7992          moveq     #-1,D0
                    7993   vsscanf_114:
00004420  6000 00CE 7994          bra       vsscanf_15
                    7995   vsscanf_111:
00004424  4AAE FFE0 7996          tst.l     -32(A6)
00004428  6706      7997          beq.s     vsscanf_115
0000442A  200D      7998          move.l    A5,D0
0000442C  4480      7999          neg.l     D0
0000442E  2A40      8000          move.l    D0,A5
                    8001   vsscanf_115:
00004430  4A86      8002          tst.l     D6
00004432  661E      8003          bne.s     vsscanf_117
00004434  4AAE FFE8 8004          tst.l     -24(A6)
00004438  6706      8005          beq.s     vsscanf_119
0000443A  2047      8006          move.l    D7,A0
0000443C  208D      8007          move.l    A5,(A0)
0000443E  6010      8008          bra.s     vsscanf_122
                    8009   vsscanf_119:
00004440  4AAE FFEC 8010          tst.l     -20(A6)
00004444  6706      8011          beq.s     vsscanf_121
00004446  2047      8012          move.l    D7,A0
00004448  308D      8013          move.w    A5,(A0)
0000444A  6004      8014          bra.s     vsscanf_122
                    8015   vsscanf_121:
0000444C  2047      8016          move.l    D7,A0
0000444E  208D      8017          move.l    A5,(A0)
                    8018   vsscanf_122:
00004450  5284      8019          addq.l    #1,D4
                    8020   vsscanf_117:
00004452  0C82 FFFF 8021          cmp.l     #-1,D2
00004456  FFFF      
00004458  660E      8022          bne.s     vsscanf_123
0000445A  4A84      8023          tst.l     D4
0000445C  6704      8024          beq.s     vsscanf_125
0000445E  2004      8025          move.l    D4,D0
00004460  6002      8026          bra.s     vsscanf_126
                    8027   vsscanf_125:
00004462  70FF      8028          moveq     #-1,D0
                    8029   vsscanf_126:
00004464  6000 008A 8030          bra       vsscanf_15
                    8031   vsscanf_123:
00004468  6000 0080 8032          bra       vsscanf_139
                    8033   vsscanf_85:
0000446C  0C83 0000 8034          cmp.l     #37,D3
00004470  0025      
00004472  6600 0040 8035          bne       vsscanf_127
00004476  2F05      8036          move.l    D5,-(A7)
00004478  4E93      8037          jsr       (A3)
0000447A  584F      8038          addq.w    #4,A7
0000447C  2400      8039          move.l    D0,D2
0000447E  0C82 FFFF 8040          cmp.l     #-1,D2
00004482  FFFF      
00004484  660E      8041          bne.s     vsscanf_129
00004486  4A84      8042          tst.l     D4
00004488  6704      8043          beq.s     vsscanf_131
0000448A  2004      8044          move.l    D4,D0
0000448C  6002      8045          bra.s     vsscanf_132
                    8046   vsscanf_131:
0000448E  70FF      8047          moveq     #-1,D0
                    8048   vsscanf_132:
00004490  6000 005E 8049          bra       vsscanf_15
                    8050   vsscanf_129:
00004494  52AE FFE4 8051          addq.l    #1,-28(A6)
00004498  B483      8052          cmp.l     D3,D2
0000449A  6714      8053          beq.s     vsscanf_133
0000449C  2F02      8054          move.l    D2,-(A7)
0000449E  2F05      8055          move.l    D5,-(A7)
000044A0  6100 F82E 8056          bsr       @vsscanf_scanputback
000044A4  504F      8057          addq.w    #8,A7
000044A6  53AE FFE4 8058          subq.l    #1,-28(A6)
000044AA  2004      8059          move.l    D4,D0
000044AC  6000 0042 8060          bra       vsscanf_15
                    8061   vsscanf_133:
000044B0  6000 0038 8062          bra       vsscanf_139
                    8063   vsscanf_127:
000044B4  2F05      8064          move.l    D5,-(A7)
000044B6  4E93      8065          jsr       (A3)
000044B8  584F      8066          addq.w    #4,A7
000044BA  2400      8067          move.l    D0,D2
000044BC  52AE FFE4 8068          addq.l    #1,-28(A6)
000044C0  0C82 FFFF 8069          cmp.l     #-1,D2
000044C4  FFFF      
000044C6  660C      8070          bne.s     vsscanf_135
000044C8  4A84      8071          tst.l     D4
000044CA  6704      8072          beq.s     vsscanf_137
000044CC  2004      8073          move.l    D4,D0
000044CE  6002      8074          bra.s     vsscanf_138
                    8075   vsscanf_137:
000044D0  70FF      8076          moveq     #-1,D0
                    8077   vsscanf_138:
000044D2  601C      8078          bra.s     vsscanf_15
                    8079   vsscanf_135:
000044D4  B483      8080          cmp.l     D3,D2
000044D6  6712      8081          beq.s     vsscanf_139
000044D8  2F02      8082          move.l    D2,-(A7)
000044DA  2F05      8083          move.l    D5,-(A7)
000044DC  6100 F7F2 8084          bsr       @vsscanf_scanputback
000044E0  504F      8085          addq.w    #8,A7
000044E2  53AE FFE4 8086          subq.l    #1,-28(A6)
000044E6  2004      8087          move.l    D4,D0
000044E8  6006      8088          bra.s     vsscanf_15
                    8089   vsscanf_139:
000044EA  6000 FA44 8090          bra       vsscanf_3
                    8091   vsscanf_5:
000044EE  2004      8092          move.l    D4,D0
                    8093   vsscanf_15:
000044F0  4CDF 3CFC 8094          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
000044F4  4E5E      8095          unlk      A6
000044F6  4E75      8096          rts
                    8097   @vsprintf_copy:
000044F8  4E56 0000 8098          link      A6,#0
000044FC  206E 0008 8099          move.l    8(A6),A0
00004500  4A90      8100          tst.l     (A0)
00004502  6710      8101          beq.s     @vsprintf_copy_1
00004504  202E 000C 8102          move.l    12(A6),D0
00004508  206E 0008 8103          move.l    8(A6),A0
0000450C  2250      8104          move.l    (A0),A1
0000450E  5290      8105          addq.l    #1,(A0)
00004510  1280      8106          move.b    D0,(A1)
00004512  600A      8107          bra.s     @vsprintf_copy_2
                    8108   @vsprintf_copy_1:
00004514  2F2E 000C 8109          move.l    12(A6),-(A7)
00004518  6100 F622 8110          bsr       _putch
0000451C  584F      8111          addq.w    #4,A7
                    8112   @vsprintf_copy_2:
0000451E  4E5E      8113          unlk      A6
00004520  4E75      8114          rts
                    8115   @vsprintf_getval:
00004522  4E56 0000 8116          link      A6,#0
00004526  48E7 3000 8117          movem.l   D2/D3,-(A7)
0000452A  242E 0008 8118          move.l    8(A6),D2
0000452E  4283      8119          clr.l     D3
00004530  2042      8120          move.l    D2,A0
00004532  2050      8121          move.l    (A0),A0
00004534  1010      8122          move.b    (A0),D0
00004536  4880      8123          ext.w     D0
00004538  48C0      8124          ext.l     D0
0000453A  0C80 0000 8125          cmp.l     #42,D0
0000453E  002A      
00004540  6612      8126          bne.s     @vsprintf_getval_1
00004542  206E 000C 8127          move.l    12(A6),A0
00004546  2250      8128          move.l    (A0),A1
00004548  5890      8129          addq.l    #4,(A0)
0000454A  2611      8130          move.l    (A1),D3
0000454C  2042      8131          move.l    D2,A0
0000454E  5290      8132          addq.l    #1,(A0)
00004550  6000 004E 8133          bra       @vsprintf_getval_5
                    8134   @vsprintf_getval_1:
00004554  2042      8135          move.l    D2,A0
00004556  2050      8136          move.l    (A0),A0
00004558  1010      8137          move.b    (A0),D0
0000455A  4880      8138          ext.w     D0
0000455C  48C0      8139          ext.l     D0
0000455E  0C80 0000 8140          cmp.l     #48,D0
00004562  0030      
00004564  6D00 003A 8141          blt       @vsprintf_getval_5
00004568  2042      8142          move.l    D2,A0
0000456A  2050      8143          move.l    (A0),A0
0000456C  1010      8144          move.b    (A0),D0
0000456E  4880      8145          ext.w     D0
00004570  48C0      8146          ext.l     D0
00004572  0C80 0000 8147          cmp.l     #57,D0
00004576  0039      
00004578  6E26      8148          bgt.s     @vsprintf_getval_5
0000457A  2F03      8149          move.l    D3,-(A7)
0000457C  4878 000A 8150          pea       10
00004580  6100 069C 8151          bsr       LMUL
00004584  2017      8152          move.l    (A7),D0
00004586  504F      8153          addq.w    #8,A7
00004588  2042      8154          move.l    D2,A0
0000458A  2250      8155          move.l    (A0),A1
0000458C  5290      8156          addq.l    #1,(A0)
0000458E  1211      8157          move.b    (A1),D1
00004590  4881      8158          ext.w     D1
00004592  48C1      8159          ext.l     D1
00004594  D081      8160          add.l     D1,D0
00004596  0480 0000 8161          sub.l     #48,D0
0000459A  0030      
0000459C  2600      8162          move.l    D0,D3
0000459E  60B4      8163          bra       @vsprintf_getval_1
                    8164   @vsprintf_getval_5:
000045A0  2003      8165          move.l    D3,D0
000045A2  4CDF 000C 8166          movem.l   (A7)+,D2/D3
000045A6  4E5E      8167          unlk      A6
000045A8  4E75      8168          rts
                    8169   _vsprintf:
000045AA  4E56 FFCC 8170          link      A6,#-52
000045AE  48E7 3F3C 8171          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
000045B2  45EE 0008 8172          lea       8(A6),A2
000045B6  47F8 44F8 8173          lea       @vsprintf_copy,A3
000045BA  49F9 0000 8174          lea       _ultoa,A4
000045BE  4E28      
000045C0  4286      8175          clr.l     D6
                    8176   vsprintf_1:
000045C2  206E 000C 8177          move.l    12(A6),A0
000045C6  4A10      8178          tst.b     (A0)
000045C8  6700 0624 8179          beq       vsprintf_3
000045CC  206E 000C 8180          move.l    12(A6),A0
000045D0  1010      8181          move.b    (A0),D0
000045D2  4880      8182          ext.w     D0
000045D4  48C0      8183          ext.l     D0
000045D6  0C80 0000 8184          cmp.l     #37,D0
000045DA  0025      
000045DC  671C      8185          beq.s     vsprintf_4
000045DE  206E 000C 8186          move.l    12(A6),A0
000045E2  52AE 000C 8187          addq.l    #1,12(A6)
000045E6  1210      8188          move.b    (A0),D1
000045E8  4881      8189          ext.w     D1
000045EA  48C1      8190          ext.l     D1
000045EC  2F01      8191          move.l    D1,-(A7)
000045EE  2F0A      8192          move.l    A2,-(A7)
000045F0  4E93      8193          jsr       (A3)
000045F2  504F      8194          addq.w    #8,A7
000045F4  5286      8195          addq.l    #1,D6
000045F6  6000 05F2 8196          bra       vsprintf_2
                    8197   vsprintf_4:
000045FA  52AE 000C 8198          addq.l    #1,12(A6)
000045FE  422E FFD3 8199          clr.b     -45(A6)
00004602  422E FFD2 8200          clr.b     -46(A6)
00004606  422E FFD0 8201          clr.b     -48(A6)
0000460A  422E FFCF 8202          clr.b     -49(A6)
0000460E  422E FFCE 8203          clr.b     -50(A6)
00004612  422E FFCD 8204          clr.b     -51(A6)
00004616  42AE FFFC 8205          clr.l     -4(A6)
0000461A  7AFF      8206          moveq     #-1,D5
0000461C  41EE FFDC 8207          lea       -36(A6),A0
00004620  2608      8208          move.l    A0,D3
00004622  2408      8209          move.l    A0,D2
                    8210   vsprintf_6:
00004624  206E 000C 8211          move.l    12(A6),A0
00004628  1010      8212          move.b    (A0),D0
0000462A  4880      8213          ext.w     D0
0000462C  48C0      8214          ext.l     D0
0000462E  0C80 0000 8215          cmp.l     #43,D0
00004632  002B      
00004634  6730      8216          beq.s     vsprintf_12
00004636  6E18      8217          bgt.s     vsprintf_15
00004638  0C80 0000 8218          cmp.l     #35,D0
0000463C  0023      
0000463E  6700 003E 8219          beq       vsprintf_14
00004642  6E00 0046 8220          bgt       vsprintf_9
00004646  0C80 0000 8221          cmp.l     #32,D0
0000464A  0020      
0000464C  6724      8222          beq.s     vsprintf_13
0000464E  603A      8223          bra.s     vsprintf_9
                    8224   vsprintf_15:
00004650  0C80 0000 8225          cmp.l     #45,D0
00004654  002D      
00004656  6702      8226          beq.s     vsprintf_11
00004658  6030      8227          bra.s     vsprintf_9
                    8228   vsprintf_11:
0000465A  1D7C 0001 8229          move.b    #1,-51(A6)
0000465E  FFCD      
00004660  52AE 000C 8230          addq.l    #1,12(A6)
00004664  6026      8231          bra.s     vsprintf_7
                    8232   vsprintf_12:
00004666  1D7C 0001 8233          move.b    #1,-50(A6)
0000466A  FFCE      
0000466C  52AE 000C 8234          addq.l    #1,12(A6)
00004670  601A      8235          bra.s     vsprintf_7
                    8236   vsprintf_13:
00004672  1D7C 0001 8237          move.b    #1,-49(A6)
00004676  FFCF      
00004678  52AE 000C 8238          addq.l    #1,12(A6)
0000467C  600E      8239          bra.s     vsprintf_7
                    8240   vsprintf_14:
0000467E  1D7C 0001 8241          move.b    #1,-48(A6)
00004682  FFD0      
00004684  52AE 000C 8242          addq.l    #1,12(A6)
00004688  6002      8243          bra.s     vsprintf_7
                    8244   vsprintf_9:
0000468A  6002      8245          bra.s     vsprintf_8
                    8246   vsprintf_7:
0000468C  6096      8247          bra       vsprintf_6
                    8248   vsprintf_8:
0000468E  206E 000C 8249          move.l    12(A6),A0
00004692  1010      8250          move.b    (A0),D0
00004694  4880      8251          ext.w     D0
00004696  48C0      8252          ext.l     D0
00004698  0C80 0000 8253          cmp.l     #48,D0
0000469C  0030      
0000469E  660A      8254          bne.s     vsprintf_16
000046A0  52AE 000C 8255          addq.l    #1,12(A6)
000046A4  1D7C 0001 8256          move.b    #1,-46(A6)
000046A8  FFD2      
                    8257   vsprintf_16:
000046AA  486E 0010 8258          pea       16(A6)
000046AE  486E 000C 8259          pea       12(A6)
000046B2  6100 FE6E 8260          bsr       @vsprintf_getval
000046B6  504F      8261          addq.w    #8,A7
000046B8  2A40      8262          move.l    D0,A5
000046BA  206E 000C 8263          move.l    12(A6),A0
000046BE  1010      8264          move.b    (A0),D0
000046C0  4880      8265          ext.w     D0
000046C2  48C0      8266          ext.l     D0
000046C4  0C80 0000 8267          cmp.l     #46,D0
000046C8  002E      
000046CA  6614      8268          bne.s     vsprintf_18
000046CC  52AE 000C 8269          addq.l    #1,12(A6)
000046D0  486E 0010 8270          pea       16(A6)
000046D4  486E 000C 8271          pea       12(A6)
000046D8  6100 FE48 8272          bsr       @vsprintf_getval
000046DC  504F      8273          addq.w    #8,A7
000046DE  2A00      8274          move.l    D0,D5
                    8275   vsprintf_18:
000046E0  206E 000C 8276          move.l    12(A6),A0
000046E4  1010      8277          move.b    (A0),D0
000046E6  4880      8278          ext.w     D0
000046E8  48C0      8279          ext.l     D0
000046EA  0C80 0000 8280          cmp.l     #108,D0
000046EE  006C      
000046F0  660A      8281          bne.s     vsprintf_20
000046F2  52AE 000C 8282          addq.l    #1,12(A6)
000046F6  1D7C 0001 8283          move.b    #1,-45(A6)
000046FA  FFD3      
                    8284   vsprintf_20:
000046FC  206E 000C 8285          move.l    12(A6),A0
00004700  1010      8286          move.b    (A0),D0
00004702  4880      8287          ext.w     D0
00004704  48C0      8288          ext.l     D0
00004706  0C80 0000 8289          cmp.l     #111,D0
0000470A  006F      
0000470C  6700 00D4 8290          beq       vsprintf_27
00004710  6E34      8291          bgt.s     vsprintf_33
00004712  0C80 0000 8292          cmp.l     #100,D0
00004716  0064      
00004718  6700 0054 8293          beq       vsprintf_24
0000471C  6E1C      8294          bgt.s     vsprintf_34
0000471E  0C80 0000 8295          cmp.l     #99,D0
00004722  0063      
00004724  6700 012C 8296          beq       vsprintf_30
00004728  6E00 016A 8297          bgt       vsprintf_22
0000472C  0C80 0000 8298          cmp.l     #88,D0
00004730  0058      
00004732  6700 00E6 8299          beq       vsprintf_28
00004736  6000 015C 8300          bra       vsprintf_22
                    8301   vsprintf_34:
0000473A  0C80 0000 8302          cmp.l     #105,D0
0000473E  0069      
00004740  672C      8303          beq.s     vsprintf_24
00004742  6000 0150 8304          bra       vsprintf_22
                    8305   vsprintf_33:
00004746  0C80 0000 8306          cmp.l     #117,D0
0000474A  0075      
0000474C  6700 005C 8307          beq       vsprintf_26
00004750  6E0E      8308          bgt.s     vsprintf_35
00004752  0C80 0000 8309          cmp.l     #115,D0
00004756  0073      
00004758  6700 011C 8310          beq       vsprintf_31
0000475C  6000 0136 8311          bra       vsprintf_22
                    8312   vsprintf_35:
00004760  0C80 0000 8313          cmp.l     #120,D0
00004764  0078      
00004766  6700 00B2 8314          beq       vsprintf_28
0000476A  6000 0128 8315          bra       vsprintf_22
                    8316   vsprintf_24:
0000476E  4A2E FFD3 8317          tst.b     -45(A6)
00004772  671A      8318          beq.s     vsprintf_36
00004774  4878 000A 8319          pea       10
00004778  2F03      8320          move.l    D3,-(A7)
0000477A  206E 0010 8321          move.l    16(A6),A0
0000477E  58AE 0010 8322          addq.l    #4,16(A6)
00004782  2F10      8323          move.l    (A0),-(A7)
00004784  6100 061E 8324          bsr       _ltoa
00004788  DEFC 000C 8325          add.w     #12,A7
0000478C  6018      8326          bra.s     vsprintf_37
                    8327   vsprintf_36:
0000478E  4878 000A 8328          pea       10
00004792  2F03      8329          move.l    D3,-(A7)
00004794  206E 0010 8330          move.l    16(A6),A0
00004798  58AE 0010 8331          addq.l    #4,16(A6)
0000479C  2F10      8332          move.l    (A0),-(A7)
0000479E  6100 0604 8333          bsr       _ltoa
000047A2  DEFC 000C 8334          add.w     #12,A7
                    8335   vsprintf_37:
000047A6  6000 00FA 8336          bra       vsprintf_23
                    8337   vsprintf_26:
000047AA  4A2E FFD3 8338          tst.b     -45(A6)
000047AE  6718      8339          beq.s     vsprintf_38
000047B0  4878 000A 8340          pea       10
000047B4  2F03      8341          move.l    D3,-(A7)
000047B6  206E 0010 8342          move.l    16(A6),A0
000047BA  58AE 0010 8343          addq.l    #4,16(A6)
000047BE  2F10      8344          move.l    (A0),-(A7)
000047C0  4E94      8345          jsr       (A4)
000047C2  DEFC 000C 8346          add.w     #12,A7
000047C6  6016      8347          bra.s     vsprintf_39
                    8348   vsprintf_38:
000047C8  4878 000A 8349          pea       10
000047CC  2F03      8350          move.l    D3,-(A7)
000047CE  206E 0010 8351          move.l    16(A6),A0
000047D2  58AE 0010 8352          addq.l    #4,16(A6)
000047D6  2F10      8353          move.l    (A0),-(A7)
000047D8  4E94      8354          jsr       (A4)
000047DA  DEFC 000C 8355          add.w     #12,A7
                    8356   vsprintf_39:
000047DE  6000 00C2 8357          bra       vsprintf_23
                    8358   vsprintf_27:
000047E2  4A2E FFD3 8359          tst.b     -45(A6)
000047E6  6718      8360          beq.s     vsprintf_40
000047E8  4878 0008 8361          pea       8
000047EC  2F03      8362          move.l    D3,-(A7)
000047EE  206E 0010 8363          move.l    16(A6),A0
000047F2  58AE 0010 8364          addq.l    #4,16(A6)
000047F6  2F10      8365          move.l    (A0),-(A7)
000047F8  4E94      8366          jsr       (A4)
000047FA  DEFC 000C 8367          add.w     #12,A7
000047FE  6016      8368          bra.s     vsprintf_41
                    8369   vsprintf_40:
00004800  4878 0008 8370          pea       8
00004804  2F03      8371          move.l    D3,-(A7)
00004806  206E 0010 8372          move.l    16(A6),A0
0000480A  58AE 0010 8373          addq.l    #4,16(A6)
0000480E  2F10      8374          move.l    (A0),-(A7)
00004810  4E94      8375          jsr       (A4)
00004812  DEFC 000C 8376          add.w     #12,A7
                    8377   vsprintf_41:
00004816  6000 008A 8378          bra       vsprintf_23
                    8379   vsprintf_28:
0000481A  4A2E FFD3 8380          tst.b     -45(A6)
0000481E  6718      8381          beq.s     vsprintf_42
00004820  4878 0010 8382          pea       16
00004824  2F03      8383          move.l    D3,-(A7)
00004826  206E 0010 8384          move.l    16(A6),A0
0000482A  58AE 0010 8385          addq.l    #4,16(A6)
0000482E  2F10      8386          move.l    (A0),-(A7)
00004830  4E94      8387          jsr       (A4)
00004832  DEFC 000C 8388          add.w     #12,A7
00004836  6016      8389          bra.s     vsprintf_43
                    8390   vsprintf_42:
00004838  4878 0010 8391          pea       16
0000483C  2F03      8392          move.l    D3,-(A7)
0000483E  206E 0010 8393          move.l    16(A6),A0
00004842  58AE 0010 8394          addq.l    #4,16(A6)
00004846  2F10      8395          move.l    (A0),-(A7)
00004848  4E94      8396          jsr       (A4)
0000484A  DEFC 000C 8397          add.w     #12,A7
                    8398   vsprintf_43:
0000484E  6000 0052 8399          bra       vsprintf_23
                    8400   vsprintf_30:
00004852  206E 0010 8401          move.l    16(A6),A0
00004856  58AE 0010 8402          addq.l    #4,16(A6)
0000485A  2010      8403          move.l    (A0),D0
0000485C  2042      8404          move.l    D2,A0
0000485E  5282      8405          addq.l    #1,D2
00004860  1080      8406          move.b    D0,(A0)
00004862  2042      8407          move.l    D2,A0
00004864  4210      8408          clr.b     (A0)
00004866  200D      8409          move.l    A5,D0
00004868  6704      8410          beq.s     vsprintf_44
0000486A  200D      8411          move.l    A5,D0
0000486C  6002      8412          bra.s     vsprintf_45
                    8413   vsprintf_44:
0000486E  7001      8414          moveq     #1,D0
                    8415   vsprintf_45:
00004870  2A00      8416          move.l    D0,D5
00004872  6000 002E 8417          bra       vsprintf_23
                    8418   vsprintf_31:
00004876  206E 0010 8419          move.l    16(A6),A0
0000487A  58AE 0010 8420          addq.l    #4,16(A6)
0000487E  2610      8421          move.l    (A0),D3
00004880  0C85 FFFF 8422          cmp.l     #-1,D5
00004884  FFFF      
00004886  660A      8423          bne.s     vsprintf_46
00004888  2F03      8424          move.l    D3,-(A7)
0000488A  6100 05FE 8425          bsr       _strlen
0000488E  584F      8426          addq.w    #4,A7
00004890  2A00      8427          move.l    D0,D5
                    8428   vsprintf_46:
00004892  600E      8429          bra.s     vsprintf_23
                    8430   vsprintf_22:
00004894  206E 000C 8431          move.l    12(A6),A0
00004898  2242      8432          move.l    D2,A1
0000489A  5282      8433          addq.l    #1,D2
0000489C  1290      8434          move.b    (A0),(A1)
0000489E  2042      8435          move.l    D2,A0
000048A0  4210      8436          clr.b     (A0)
                    8437   vsprintf_23:
000048A2  2F03      8438          move.l    D3,-(A7)
000048A4  6100 05E4 8439          bsr       _strlen
000048A8  584F      8440          addq.w    #4,A7
000048AA  1800      8441          move.b    D0,D4
000048AC  206E 000C 8442          move.l    12(A6),A0
000048B0  1010      8443          move.b    (A0),D0
000048B2  4880      8444          ext.w     D0
000048B4  48C0      8445          ext.l     D0
000048B6  0C80 0000 8446          cmp.l     #115,D0
000048BA  0073      
000048BC  6618      8447          bne.s     vsprintf_48
000048BE  0C85 0000 8448          cmp.l     #0,D5
000048C2  0000      
000048C4  6D10      8449          blt.s     vsprintf_48
000048C6  4884      8450          ext.w     D4
000048C8  48C4      8451          ext.l     D4
000048CA  B885      8452          cmp.l     D5,D4
000048CC  6F04      8453          ble.s     vsprintf_50
000048CE  1005      8454          move.b    D5,D0
000048D0  6002      8455          bra.s     vsprintf_51
                    8456   vsprintf_50:
000048D2  1004      8457          move.b    D4,D0
                    8458   vsprintf_51:
000048D4  1800      8459          move.b    D0,D4
                    8460   vsprintf_48:
000048D6  206E 000C 8461          move.l    12(A6),A0
000048DA  1010      8462          move.b    (A0),D0
000048DC  4880      8463          ext.w     D0
000048DE  48C0      8464          ext.l     D0
000048E0  0C80 0000 8465          cmp.l     #88,D0
000048E4  0058      
000048E6  6600 0026 8466          bne       vsprintf_56
000048EA  41EE FFDC 8467          lea       -36(A6),A0
000048EE  2408      8468          move.l    A0,D2
                    8469   vsprintf_54:
000048F0  2042      8470          move.l    D2,A0
000048F2  4A10      8471          tst.b     (A0)
000048F4  6718      8472          beq.s     vsprintf_56
000048F6  2042      8473          move.l    D2,A0
000048F8  1210      8474          move.b    (A0),D1
000048FA  4881      8475          ext.w     D1
000048FC  48C1      8476          ext.l     D1
000048FE  2F01      8477          move.l    D1,-(A7)
00004900  6100 F334 8478          bsr       _toupper
00004904  584F      8479          addq.w    #4,A7
00004906  2042      8480          move.l    D2,A0
00004908  1080      8481          move.b    D0,(A0)
0000490A  5282      8482          addq.l    #1,D2
0000490C  60E2      8483          bra       vsprintf_54
                    8484   vsprintf_56:
0000490E  7E00      8485          moveq     #0,D7
00004910  41EE FFD4 8486          lea       -44(A6),A0
00004914  2408      8487          move.l    A0,D2
00004916  206E 000C 8488          move.l    12(A6),A0
0000491A  1010      8489          move.b    (A0),D0
0000491C  4880      8490          ext.w     D0
0000491E  48C0      8491          ext.l     D0
00004920  0C80 0000 8492          cmp.l     #100,D0
00004924  0064      
00004926  6714      8493          beq.s     vsprintf_59
00004928  206E 000C 8494          move.l    12(A6),A0
0000492C  1010      8495          move.b    (A0),D0
0000492E  4880      8496          ext.w     D0
00004930  48C0      8497          ext.l     D0
00004932  0C80 0000 8498          cmp.l     #105,D0
00004936  0069      
00004938  6600 0076 8499          bne       vsprintf_65
                    8500   vsprintf_59:
0000493C  4A2E FFCE 8501          tst.b     -50(A6)
00004940  6612      8502          bne.s     vsprintf_62
00004942  2043      8503          move.l    D3,A0
00004944  1010      8504          move.b    (A0),D0
00004946  4880      8505          ext.w     D0
00004948  48C0      8506          ext.l     D0
0000494A  0C80 0000 8507          cmp.l     #45,D0
0000494E  002D      
00004950  6600 002E 8508          bne       vsprintf_60
                    8509   vsprintf_62:
00004954  2043      8510          move.l    D3,A0
00004956  1010      8511          move.b    (A0),D0
00004958  4880      8512          ext.w     D0
0000495A  48C0      8513          ext.l     D0
0000495C  0C80 0000 8514          cmp.l     #45,D0
00004960  002D      
00004962  660E      8515          bne.s     vsprintf_63
00004964  2043      8516          move.l    D3,A0
00004966  5283      8517          addq.l    #1,D3
00004968  2242      8518          move.l    D2,A1
0000496A  5282      8519          addq.l    #1,D2
0000496C  1290      8520          move.b    (A0),(A1)
0000496E  5304      8521          subq.b    #1,D4
00004970  6008      8522          bra.s     vsprintf_64
                    8523   vsprintf_63:
00004972  2042      8524          move.l    D2,A0
00004974  5282      8525          addq.l    #1,D2
00004976  10BC 002B 8526          move.b    #43,(A0)
                    8527   vsprintf_64:
0000497A  5287      8528          addq.l    #1,D7
0000497C  6000 0032 8529          bra       vsprintf_65
                    8530   vsprintf_60:
00004980  4A2E FFCF 8531          tst.b     -49(A6)
00004984  6700 002A 8532          beq       vsprintf_65
00004988  2043      8533          move.l    D3,A0
0000498A  1010      8534          move.b    (A0),D0
0000498C  4880      8535          ext.w     D0
0000498E  48C0      8536          ext.l     D0
00004990  0C80 0000 8537          cmp.l     #45,D0
00004994  002D      
00004996  660E      8538          bne.s     vsprintf_67
00004998  2043      8539          move.l    D3,A0
0000499A  5283      8540          addq.l    #1,D3
0000499C  2242      8541          move.l    D2,A1
0000499E  5282      8542          addq.l    #1,D2
000049A0  1290      8543          move.b    (A0),(A1)
000049A2  5304      8544          subq.b    #1,D4
000049A4  6008      8545          bra.s     vsprintf_68
                    8546   vsprintf_67:
000049A6  2042      8547          move.l    D2,A0
000049A8  5282      8548          addq.l    #1,D2
000049AA  10BC 0020 8549          move.b    #32,(A0)
                    8550   vsprintf_68:
000049AE  5287      8551          addq.l    #1,D7
                    8552   vsprintf_65:
000049B0  4A2E FFD0 8553          tst.b     -48(A6)
000049B4  6700 0066 8554          beq       vsprintf_77
000049B8  206E 000C 8555          move.l    12(A6),A0
000049BC  1010      8556          move.b    (A0),D0
000049BE  4880      8557          ext.w     D0
000049C0  48C0      8558          ext.l     D0
000049C2  0C80 0000 8559          cmp.l     #111,D0
000049C6  006F      
000049C8  671A      8560          beq.s     vsprintf_73
000049CA  6E0C      8561          bgt.s     vsprintf_76
000049CC  0C80 0000 8562          cmp.l     #88,D0
000049D0  0058      
000049D2  6710      8563          beq.s     vsprintf_73
000049D4  6000 0046 8564          bra       vsprintf_77
                    8565   vsprintf_76:
000049D8  0C80 0000 8566          cmp.l     #120,D0
000049DC  0078      
000049DE  6704      8567          beq.s     vsprintf_73
000049E0  6000 003A 8568          bra       vsprintf_77
                    8569   vsprintf_73:
000049E4  2042      8570          move.l    D2,A0
000049E6  5282      8571          addq.l    #1,D2
000049E8  10BC 0030 8572          move.b    #48,(A0)
000049EC  5287      8573          addq.l    #1,D7
000049EE  206E 000C 8574          move.l    12(A6),A0
000049F2  1010      8575          move.b    (A0),D0
000049F4  4880      8576          ext.w     D0
000049F6  48C0      8577          ext.l     D0
000049F8  0C80 0000 8578          cmp.l     #120,D0
000049FC  0078      
000049FE  6712      8579          beq.s     vsprintf_79
00004A00  206E 000C 8580          move.l    12(A6),A0
00004A04  1010      8581          move.b    (A0),D0
00004A06  4880      8582          ext.w     D0
00004A08  48C0      8583          ext.l     D0
00004A0A  0C80 0000 8584          cmp.l     #88,D0
00004A0E  0058      
00004A10  660A      8585          bne.s     vsprintf_77
                    8586   vsprintf_79:
00004A12  2042      8587          move.l    D2,A0
00004A14  5282      8588          addq.l    #1,D2
00004A16  10BC 0078 8589          move.b    #120,(A0)
00004A1A  5287      8590          addq.l    #1,D7
                    8591   vsprintf_77:
00004A1C  2042      8592          move.l    D2,A0
00004A1E  4210      8593          clr.b     (A0)
00004A20  206E 000C 8594          move.l    12(A6),A0
00004A24  1010      8595          move.b    (A0),D0
00004A26  4880      8596          ext.w     D0
00004A28  48C0      8597          ext.l     D0
00004A2A  0C80 0000 8598          cmp.l     #105,D0
00004A2E  0069      
00004A30  6700 0076 8599          beq       vsprintf_82
00004A34  6E42      8600          bgt.s     vsprintf_93
00004A36  0C80 0000 8601          cmp.l     #99,D0
00004A3A  0063      
00004A3C  6700 0084 8602          beq       vsprintf_96
00004A40  6E1C      8603          bgt.s     vsprintf_94
00004A42  0C80 0000 8604          cmp.l     #88,D0
00004A46  0058      
00004A48  6700 005E 8605          beq       vsprintf_82
00004A4C  6E00 0184 8606          bgt       vsprintf_80
00004A50  0C80 0000 8607          cmp.l     #69,D0
00004A54  0045      
00004A56  6700 0050 8608          beq       vsprintf_82
00004A5A  6000 0176 8609          bra       vsprintf_80
                    8610   vsprintf_94:
00004A5E  0C80 0000 8611          cmp.l     #101,D0
00004A62  0065      
00004A64  6700 0042 8612          beq       vsprintf_82
00004A68  6E00 0168 8613          bgt       vsprintf_80
00004A6C  0C80 0000 8614          cmp.l     #100,D0
00004A70  0064      
00004A72  6734      8615          beq.s     vsprintf_82
00004A74  6000 015C 8616          bra       vsprintf_80
                    8617   vsprintf_93:
00004A78  0C80 0000 8618          cmp.l     #117,D0
00004A7C  0075      
00004A7E  6728      8619          beq.s     vsprintf_82
00004A80  6E1A      8620          bgt.s     vsprintf_95
00004A82  0C80 0000 8621          cmp.l     #115,D0
00004A86  0073      
00004A88  6700 0038 8622          beq       vsprintf_96
00004A8C  6E00 0144 8623          bgt       vsprintf_80
00004A90  0C80 0000 8624          cmp.l     #111,D0
00004A94  006F      
00004A96  6710      8625          beq.s     vsprintf_82
00004A98  6000 0138 8626          bra       vsprintf_80
                    8627   vsprintf_95:
00004A9C  0C80 0000 8628          cmp.l     #120,D0
00004AA0  0078      
00004AA2  6704      8629          beq.s     vsprintf_82
00004AA4  6000 012C 8630          bra       vsprintf_80
                    8631   vsprintf_82:
00004AA8  4A2E FFD2 8632          tst.b     -46(A6)
00004AAC  6714      8633          beq.s     vsprintf_96
00004AAE  4A2E FFCD 8634          tst.b     -51(A6)
00004AB2  660E      8635          bne.s     vsprintf_96
00004AB4  200D      8636          move.l    A5,D0
00004AB6  9087      8637          sub.l     D7,D0
00004AB8  4884      8638          ext.w     D4
00004ABA  48C4      8639          ext.l     D4
00004ABC  9084      8640          sub.l     D4,D0
00004ABE  2D40 FFFC 8641          move.l    D0,-4(A6)
                    8642   vsprintf_96:
00004AC2  202E FFFC 8643          move.l    -4(A6),D0
00004AC6  0C80 0000 8644          cmp.l     #0,D0
00004ACA  0000      
00004ACC  6C04      8645          bge.s     vsprintf_98
00004ACE  42AE FFFC 8646          clr.l     -4(A6)
                    8647   vsprintf_98:
00004AD2  4A2E FFCD 8648          tst.b     -51(A6)
00004AD6  6600 0030 8649          bne       vsprintf_104
00004ADA  4884      8650          ext.w     D4
00004ADC  48C4      8651          ext.l     D4
00004ADE  2004      8652          move.l    D4,D0
00004AE0  D0AE FFFC 8653          add.l     -4(A6),D0
00004AE4  D087      8654          add.l     D7,D0
00004AE6  1D40 FFD1 8655          move.b    D0,-47(A6)
                    8656   vsprintf_102:
00004AEA  102E FFD1 8657          move.b    -47(A6),D0
00004AEE  4880      8658          ext.w     D0
00004AF0  48C0      8659          ext.l     D0
00004AF2  220D      8660          move.l    A5,D1
00004AF4  534D      8661          subq.w    #1,A5
00004AF6  B081      8662          cmp.l     D1,D0
00004AF8  6C0E      8663          bge.s     vsprintf_104
00004AFA  4878 0020 8664          pea       32
00004AFE  2F0A      8665          move.l    A2,-(A7)
00004B00  4E93      8666          jsr       (A3)
00004B02  504F      8667          addq.w    #8,A7
00004B04  5286      8668          addq.l    #1,D6
00004B06  60E2      8669          bra       vsprintf_102
                    8670   vsprintf_104:
00004B08  41EE FFD4 8671          lea       -44(A6),A0
00004B0C  2408      8672          move.l    A0,D2
                    8673   vsprintf_105:
00004B0E  2042      8674          move.l    D2,A0
00004B10  4A10      8675          tst.b     (A0)
00004B12  6716      8676          beq.s     vsprintf_107
00004B14  2042      8677          move.l    D2,A0
00004B16  5282      8678          addq.l    #1,D2
00004B18  1210      8679          move.b    (A0),D1
00004B1A  4881      8680          ext.w     D1
00004B1C  48C1      8681          ext.l     D1
00004B1E  2F01      8682          move.l    D1,-(A7)
00004B20  2F0A      8683          move.l    A2,-(A7)
00004B22  4E93      8684          jsr       (A3)
00004B24  504F      8685          addq.w    #8,A7
00004B26  5286      8686          addq.l    #1,D6
00004B28  60E4      8687          bra       vsprintf_105
                    8688   vsprintf_107:
00004B2A  202E FFFC 8689          move.l    -4(A6),D0
00004B2E  1D40 FFD1 8690          move.b    D0,-47(A6)
                    8691   vsprintf_108:
00004B32  102E FFD1 8692          move.b    -47(A6),D0
00004B36  532E FFD1 8693          subq.b    #1,-47(A6)
00004B3A  4A00      8694          tst.b     D0
00004B3C  670E      8695          beq.s     vsprintf_110
00004B3E  4878 0030 8696          pea       48
00004B42  2F0A      8697          move.l    A2,-(A7)
00004B44  4E93      8698          jsr       (A3)
00004B46  504F      8699          addq.w    #8,A7
00004B48  5286      8700          addq.l    #1,D6
00004B4A  60E6      8701          bra       vsprintf_108
                    8702   vsprintf_110:
00004B4C  2043      8703          move.l    D3,A0
00004B4E  4A10      8704          tst.b     (A0)
00004B50  6700 0048 8705          beq       vsprintf_113
00004B54  206E 000C 8706          move.l    12(A6),A0
00004B58  1010      8707          move.b    (A0),D0
00004B5A  4880      8708          ext.w     D0
00004B5C  48C0      8709          ext.l     D0
00004B5E  0C80 0000 8710          cmp.l     #115,D0
00004B62  0073      
00004B64  670C      8711          beq.s     vsprintf_116
00004B66  6E18      8712          bgt.s     vsprintf_119
00004B68  0C80 0000 8713          cmp.l     #99,D0
00004B6C  0063      
00004B6E  6702      8714          beq.s     vsprintf_116
00004B70  600E      8715          bra.s     vsprintf_119
                    8716   vsprintf_116:
00004B72  2005      8717          move.l    D5,D0
00004B74  5385      8718          subq.l    #1,D5
00004B76  0C80 0000 8719          cmp.l     #0,D0
00004B7A  0000      
00004B7C  6E02      8720          bgt.s     vsprintf_119
00004B7E  6016      8721          bra.s     vsprintf_115
                    8722   vsprintf_119:
00004B80  2043      8723          move.l    D3,A0
00004B82  5283      8724          addq.l    #1,D3
00004B84  1210      8725          move.b    (A0),D1
00004B86  4881      8726          ext.w     D1
00004B88  48C1      8727          ext.l     D1
00004B8A  2F01      8728          move.l    D1,-(A7)
00004B8C  2F0A      8729          move.l    A2,-(A7)
00004B8E  4E93      8730          jsr       (A3)
00004B90  504F      8731          addq.w    #8,A7
00004B92  5286      8732          addq.l    #1,D6
00004B94  6002      8733          bra.s     vsprintf_112
                    8734   vsprintf_115:
00004B96  6002      8735          bra.s     vsprintf_113
                    8736   vsprintf_112:
00004B98  60B2      8737          bra       vsprintf_110
                    8738   vsprintf_113:
00004B9A  4A2E FFCD 8739          tst.b     -51(A6)
00004B9E  6700 0030 8740          beq       vsprintf_125
00004BA2  4884      8741          ext.w     D4
00004BA4  48C4      8742          ext.l     D4
00004BA6  2004      8743          move.l    D4,D0
00004BA8  D0AE FFFC 8744          add.l     -4(A6),D0
00004BAC  D087      8745          add.l     D7,D0
00004BAE  1D40 FFD1 8746          move.b    D0,-47(A6)
                    8747   vsprintf_123:
00004BB2  102E FFD1 8748          move.b    -47(A6),D0
00004BB6  4880      8749          ext.w     D0
00004BB8  48C0      8750          ext.l     D0
00004BBA  220D      8751          move.l    A5,D1
00004BBC  534D      8752          subq.w    #1,A5
00004BBE  B081      8753          cmp.l     D1,D0
00004BC0  6C0E      8754          bge.s     vsprintf_125
00004BC2  4878 0020 8755          pea       32
00004BC6  2F0A      8756          move.l    A2,-(A7)
00004BC8  4E93      8757          jsr       (A3)
00004BCA  504F      8758          addq.w    #8,A7
00004BCC  5386      8759          subq.l    #1,D6
00004BCE  60E2      8760          bra       vsprintf_123
                    8761   vsprintf_125:
00004BD0  6014      8762          bra.s     vsprintf_81
                    8763   vsprintf_80:
00004BD2  206E 000C 8764          move.l    12(A6),A0
00004BD6  1210      8765          move.b    (A0),D1
00004BD8  4881      8766          ext.w     D1
00004BDA  48C1      8767          ext.l     D1
00004BDC  2F01      8768          move.l    D1,-(A7)
00004BDE  2F0A      8769          move.l    A2,-(A7)
00004BE0  4E93      8770          jsr       (A3)
00004BE2  504F      8771          addq.w    #8,A7
00004BE4  5286      8772          addq.l    #1,D6
                    8773   vsprintf_81:
00004BE6  52AE 000C 8774          addq.l    #1,12(A6)
                    8775   vsprintf_2:
00004BEA  6000 F9D6 8776          bra       vsprintf_1
                    8777   vsprintf_3:
00004BEE  4A92      8778          tst.l     (A2)
00004BF0  6710      8779          beq.s     vsprintf_126
00004BF2  4201      8780          clr.b     D1
00004BF4  C2BC 0000 8781          and.l     #255,D1
00004BF8  00FF      
00004BFA  2F01      8782          move.l    D1,-(A7)
00004BFC  2F0A      8783          move.l    A2,-(A7)
00004BFE  4E93      8784          jsr       (A3)
00004C00  504F      8785          addq.w    #8,A7
                    8786   vsprintf_126:
00004C02  2006      8787          move.l    D6,D0
00004C04  4CDF 3CFC 8788          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
00004C08  4E5E      8789          unlk      A6
00004C0A  4E75      8790          rts
                    8791   ULMUL:
00004C0C  4E56 0000 8792          link    A6,#0
00004C10  48E7 C000 8793          movem.l D0/D1,-(A7)
00004C14  222E 0008 8794          move.l  8(A6),D1
00004C18  202E 000C 8795          move.l  12(A6),D0
00004C1C  602C      8796          bra.s   lmul_3
                    8797   LMUL:
00004C1E  4E56 0000 8798          link    A6,#0
00004C22  48E7 C000 8799          movem.l D0/D1,-(A7)
00004C26  222E 0008 8800          move.l  8(A6),D1
00004C2A  202E 000C 8801          move.l  12(A6),D0
00004C2E  4A80      8802          tst.l   D0
00004C30  6A0A      8803          bpl.s   lmul_1
00004C32  4480      8804          neg.l   D0
00004C34  4A81      8805          tst.l   D1
00004C36  6A0A      8806          bpl.s   lmul_2
00004C38  4481      8807          neg.l   D1
00004C3A  600E      8808          bra.s   lmul_3
                    8809   lmul_1:
00004C3C  4A81      8810          tst.l   D1
00004C3E  6A0A      8811          bpl.s   lmul_3
00004C40  4481      8812          neg.l   D1
                    8813   lmul_2:
00004C42  6114      8814          bsr.s   domul
00004C44  4481      8815          neg.l   D1
00004C46  4080      8816          negx.l  D0
00004C48  6002      8817          bra.s   lmul_4
                    8818   lmul_3:
00004C4A  610C      8819          bsr.s   domul
                    8820   lmul_4:
00004C4C  2D41 0008 8821          move.l  D1,8(A6)
00004C50  4CDF 0003 8822          movem.l (A7)+,D0/D1
00004C54  4E5E      8823          unlk    A6
00004C56  4E75      8824          rts
                    8825   domul:
00004C58  0C81 0000 8826          cmpi.l  #$FFFF,D1
00004C5C  FFFF      
00004C5E  620C      8827          bhi.s   domul_1
00004C60  0C80 0000 8828          cmpi.l  #$FFFF,D0
00004C64  FFFF      
00004C66  620E      8829          bhi.s   domul_2
00004C68  C2C0      8830          mulu    D0,D1
00004C6A  4E75      8831          rts
                    8832   domul_1:
00004C6C  0C80 0000 8833          cmpi.l  #$FFFF,D0
00004C70  FFFF      
00004C72  6218      8834          bhi.s   domul_4
00004C74  6002      8835          bra.s   domul_3
                    8836   domul_2
00004C76  C141      8837          exg     D0,D1
                    8838   domul_3:
00004C78  2F02      8839          move.l  D2,-(A7)
00004C7A  2401      8840          move.l  D1,D2
00004C7C  4842      8841          swap    D2
00004C7E  C2C0      8842          mulu    D0,D1
00004C80  C4C0      8843          mulu    D0,D2
00004C82  4842      8844          swap    D2
00004C84  4242      8845          clr.w   D2
00004C86  D282      8846          add.l   D2,D1
00004C88  241F      8847          move.l  (A7)+,D2
00004C8A  4E75      8848          rts
                    8849   domul_4:
00004C8C  48E7 3000 8850          movem.l D2/D3,-(A7)
00004C90  2401      8851          move.l  D1,D2
00004C92  2601      8852          move.l  D1,D3
00004C94  C2C0      8853          mulu    D0,D1
00004C96  4842      8854          swap    D2
00004C98  C4C0      8855          mulu    D0,D2
00004C9A  4840      8856          swap    D0
00004C9C  C6C0      8857          mulu    D0,D3
00004C9E  D483      8858          add.l   D3,D2
00004CA0  4842      8859          swap    D2
00004CA2  4242      8860          clr.w   D2
00004CA4  D282      8861          add.l   D2,D1
00004CA6  4CDF 000C 8862          movem.l (A7)+,D2/D3
00004CAA  4E75      8863          rts
                    8864   _gets:
00004CAC  4E56 0000 8865          link      A6,#0
00004CB0  48E7 3820 8866          movem.l   D2/D3/D4/A2,-(A7)
00004CB4  45F8 3B3C 8867          lea       _putch,A2
00004CB8  282E 0008 8868          move.l    8(A6),D4
00004CBC  2404      8869          move.l    D4,D2
                    8870   gets_1:
00004CBE  6100 EEAC 8871          bsr       _getch
00004CC2  2600      8872          move.l    D0,D3
00004CC4  0C80 0000 8873          cmp.l     #10,D0
00004CC8  000A      
00004CCA  6700 003C 8874          beq       gets_3
00004CCE  0C83 0000 8875          cmp.l     #8,D3
00004CD2  0008      
00004CD4  6712      8876          beq.s     gets_4
00004CD6  2042      8877          move.l    D2,A0
00004CD8  5282      8878          addq.l    #1,D2
00004CDA  1083      8879          move.b    D3,(A0)
00004CDC  4883      8880          ext.w     D3
00004CDE  48C3      8881          ext.l     D3
00004CE0  2F03      8882          move.l    D3,-(A7)
00004CE2  4E92      8883          jsr       (A2)
00004CE4  584F      8884          addq.w    #4,A7
00004CE6  601E      8885          bra.s     gets_6
                    8886   gets_4:
00004CE8  B484      8887          cmp.l     D4,D2
00004CEA  631A      8888          bls.s     gets_6
00004CEC  4878 0008 8889          pea       8
00004CF0  4E92      8890          jsr       (A2)
00004CF2  584F      8891          addq.w    #4,A7
00004CF4  4878 0020 8892          pea       32
00004CF8  4E92      8893          jsr       (A2)
00004CFA  584F      8894          addq.w    #4,A7
00004CFC  4878 0008 8895          pea       8
00004D00  4E92      8896          jsr       (A2)
00004D02  584F      8897          addq.w    #4,A7
00004D04  5382      8898          subq.l    #1,D2
                    8899   gets_6:
00004D06  60B6      8900          bra       gets_1
                    8901   gets_3:
00004D08  4878 000A 8902          pea       10
00004D0C  4E92      8903          jsr       (A2)
00004D0E  584F      8904          addq.w    #4,A7
00004D10  2042      8905          move.l    D2,A0
00004D12  4210      8906          clr.b     (A0)
00004D14  2004      8907          move.l    D4,D0
00004D16  4CDF 041C 8908          movem.l   (A7)+,D2/D3/D4/A2
00004D1A  4E5E      8909          unlk      A6
00004D1C  4E75      8910          rts
                    8911   _ungetch:
00004D1E  4E56 0000 8912          link      A6,#0
00004D22  23EE 0008 8913          move.l    8(A6),__ungetbuf
00004D26  0B00 00C0 
00004D2A  202E 0008 8914          move.l    8(A6),D0
00004D2E  4E5E      8915          unlk      A6
00004D30  4E75      8916          rts
                    8917   @itoa_convert:
00004D32  4E56 0000 8918          link      A6,#0
00004D36  48E7 3C00 8919          movem.l   D2/D3/D4/D5,-(A7)
00004D3A  242E 0008 8920          move.l    8(A6),D2
00004D3E  262E 0010 8921          move.l    16(A6),D3
00004D42  2A2E 000C 8922          move.l    12(A6),D5
00004D46  2F05      8923          move.l    D5,-(A7)
00004D48  2F03      8924          move.l    D3,-(A7)
00004D4A  6100 ED12 8925          bsr       ULDIV
00004D4E  202F 0004 8926          move.l    4(A7),D0
00004D52  504F      8927          addq.w    #8,A7
00004D54  2800      8928          move.l    D0,D4
00004D56  BA83      8929          cmp.l     D3,D5
00004D58  651A      8930          blo.s     @itoa_convert_1
00004D5A  2F03      8931          move.l    D3,-(A7)
00004D5C  2F05      8932          move.l    D5,-(A7)
00004D5E  2F03      8933          move.l    D3,-(A7)
00004D60  6100 ECFC 8934          bsr       ULDIV
00004D64  2217      8935          move.l    (A7),D1
00004D66  504F      8936          addq.w    #8,A7
00004D68  2F01      8937          move.l    D1,-(A7)
00004D6A  2F02      8938          move.l    D2,-(A7)
00004D6C  61C4      8939          bsr       @itoa_convert
00004D6E  DEFC 000C 8940          add.w     #12,A7
00004D72  2400      8941          move.l    D0,D2
                    8942   @itoa_convert_1:
00004D74  0C84 0000 8943          cmp.l     #9,D4
00004D78  0009      
00004D7A  6E0A      8944          bgt.s     @itoa_convert_3
00004D7C  2004      8945          move.l    D4,D0
00004D7E  0680 0000 8946          add.l     #48,D0
00004D82  0030      
00004D84  600E      8947          bra.s     @itoa_convert_4
                    8948   @itoa_convert_3:
00004D86  2004      8949          move.l    D4,D0
00004D88  0680 0000 8950          add.l     #97,D0
00004D8C  0061      
00004D8E  0480 0000 8951          sub.l     #10,D0
00004D92  000A      
                    8952   @itoa_convert_4:
00004D94  2042      8953          move.l    D2,A0
00004D96  1080      8954          move.b    D0,(A0)
00004D98  2002      8955          move.l    D2,D0
00004D9A  5280      8956          addq.l    #1,D0
00004D9C  4CDF 003C 8957          movem.l   (A7)+,D2/D3/D4/D5
00004DA0  4E5E      8958          unlk      A6
00004DA2  4E75      8959          rts
                    8960   _ltoa:
00004DA4  4E56 0000 8961          link      A6,#0
00004DA8  48E7 3C00 8962          movem.l   D2/D3/D4/D5,-(A7)
00004DAC  242E 0008 8963          move.l    8(A6),D2
00004DB0  262E 000C 8964          move.l    12(A6),D3
00004DB4  2A2E 0010 8965          move.l    16(A6),D5
00004DB8  2803      8966          move.l    D3,D4
00004DBA  0C85 0000 8967          cmp.l     #2,D5
00004DBE  0002      
00004DC0  6D08      8968          blt.s     ltoa_3
00004DC2  0C85 0000 8969          cmp.l     #36,D5
00004DC6  0024      
00004DC8  6F06      8970          ble.s     ltoa_1
                    8971   ltoa_3:
00004DCA  2003      8972          move.l    D3,D0
00004DCC  6000 0052 8973          bra       ltoa_4
                    8974   ltoa_1:
00004DD0  0C85 0000 8975          cmp.l     #10,D5
00004DD4  000A      
00004DD6  6600 0032 8976          bne       ltoa_5
00004DDA  0C82 0000 8977          cmp.l     #0,D2
00004DDE  0000      
00004DE0  6C28      8978          bge.s     ltoa_5
00004DE2  2002      8979          move.l    D2,D0
00004DE4  4480      8980          neg.l     D0
00004DE6  2400      8981          move.l    D0,D2
00004DE8  0C82 0000 8982          cmp.l     #0,D2
00004DEC  0000      
00004DEE  6C12      8983          bge.s     ltoa_7
00004DF0  4879 0000 8984          pea       @itoa_1
00004DF4  6832      
00004DF6  2F03      8985          move.l    D3,-(A7)
00004DF8  6100 EC54 8986          bsr       _strcpy
00004DFC  504F      8987          addq.w    #8,A7
00004DFE  2003      8988          move.l    D3,D0
00004E00  601E      8989          bra.s     ltoa_4
                    8990   ltoa_7:
00004E02  2044      8991          move.l    D4,A0
00004E04  5284      8992          addq.l    #1,D4
00004E06  10BC 002D 8993          move.b    #45,(A0)
                    8994   ltoa_5:
00004E0A  2F05      8995          move.l    D5,-(A7)
00004E0C  2F02      8996          move.l    D2,-(A7)
00004E0E  2F04      8997          move.l    D4,-(A7)
00004E10  6100 FF20 8998          bsr       @itoa_convert
00004E14  DEFC 000C 8999          add.w     #12,A7
00004E18  2800      9000          move.l    D0,D4
00004E1A  2044      9001          move.l    D4,A0
00004E1C  4210      9002          clr.b     (A0)
00004E1E  2003      9003          move.l    D3,D0
                    9004   ltoa_4:
00004E20  4CDF 003C 9005          movem.l   (A7)+,D2/D3/D4/D5
00004E24  4E5E      9006          unlk      A6
00004E26  4E75      9007          rts
                    9008   _ultoa:
00004E28  4E56 0000 9009          link      A6,#0
00004E2C  48E7 3800 9010          movem.l   D2/D3/D4,-(A7)
00004E30  262E 0010 9011          move.l    16(A6),D3
00004E34  282E 000C 9012          move.l    12(A6),D4
00004E38  2404      9013          move.l    D4,D2
00004E3A  0C83 0000 9014          cmp.l     #2,D3
00004E3E  0002      
00004E40  6D08      9015          blt.s     ultoa_3
00004E42  0C83 0000 9016          cmp.l     #36,D3
00004E46  0024      
00004E48  6F04      9017          ble.s     ultoa_1
                    9018   ultoa_3:
00004E4A  2004      9019          move.l    D4,D0
00004E4C  6018      9020          bra.s     ultoa_4
                    9021   ultoa_1:
00004E4E  2F03      9022          move.l    D3,-(A7)
00004E50  2F2E 0008 9023          move.l    8(A6),-(A7)
00004E54  2F02      9024          move.l    D2,-(A7)
00004E56  6100 FEDA 9025          bsr       @itoa_convert
00004E5A  DEFC 000C 9026          add.w     #12,A7
00004E5E  2400      9027          move.l    D0,D2
00004E60  2042      9028          move.l    D2,A0
00004E62  4210      9029          clr.b     (A0)
00004E64  2004      9030          move.l    D4,D0
                    9031   ultoa_4:
00004E66  4CDF 001C 9032          movem.l   (A7)+,D2/D3/D4
00004E6A  4E5E      9033          unlk      A6
00004E6C  4E75      9034          rts
                    9035   _itoa:
00004E6E  4E56 0000 9036          link      A6,#0
00004E72  2F2E 0010 9037          move.l    16(A6),-(A7)
00004E76  2F2E 000C 9038          move.l    12(A6),-(A7)
00004E7A  2F2E 0008 9039          move.l    8(A6),-(A7)
00004E7E  6100 FF24 9040          bsr       _ltoa
00004E82  DEFC 000C 9041          add.w     #12,A7
00004E86  4E5E      9042          unlk      A6
00004E88  4E75      9043          rts
                    9044   _strlen:
00004E8A  206F 0004 9045          move.l    (4,A7),A0
00004E8E  2248      9046          move.l    A0,A1
                    9047   strlen_1:
00004E90  4A19      9048          tst.b     (A1)+
00004E92  66FC      9049          bne       strlen_1
00004E94  2009      9050          move.l    A1,D0
00004E96  9088      9051          sub.l     A0,D0
00004E98  5380      9052          subq.l    #1,D0
00004E9A  4E75      9053          rts
                    9054          section   const
                    9055   
                    9056   @canbus~1_1:
00004E9C  0D0A 0D0A 9057          dc.b      13,10,13,10,45,45,45,45,32,67,65,78,66,85,83
00004EA0  2D2D 2D2D 
00004EA4  2043 414E 
00004EA8  4255 53   
00004EAB  2054 6573 9058          dc.b      32,84,101,115,116,32,45,45,45,45,13,10,0
00004EAF  7420 2D2D 
00004EB3  2D2D 0D0A 
00004EB7  00        
                    9059   @canbus~1_2:
00004EB8  0D0A 00   9060          dc.b      13,10,0
                    9061   @m68kde~1_1:
00004EBC  0D0A 00   9062          dc.b      13,10,0
                    9063   @m68kde~1_2:
00004EC0  0D53 7769 9064          dc.b      13,83,119,105,116,99,104,101,115,32,83,87,91
00004EC4  7463 6865 
00004EC8  7320 5357 
00004ECC  5B        
00004ECD  372D 305D 9065          dc.b      55,45,48,93,32,61,32,0
00004ED1  203D 2000 
                    9066   @m68kde~1_3:
00004ED6  3000      9067          dc.b      48,0
                    9068   @m68kde~1_4:
00004ED8  3100      9069          dc.b      49,0
                    9070   @m68kde~1_5:
00004EDA  0D0A 4475 9071          dc.b      13,10,68,117,109,112,32,77,101,109,111,114,121
00004EDE  6D70 204D 
00004EE2  656D 6F72 
00004EE6  79        
00004EE7  2042 6C6F 9072          dc.b      32,66,108,111,99,107,58,32,60,69,83,67,62,32
00004EEB  636B 3A20 
00004EEF  3C45 5343 
00004EF3  3E20      
00004EF5  746F 2041 9073          dc.b      116,111,32,65,98,111,114,116,44,32,60,83,80
00004EF9  626F 7274 
00004EFD  2C20 3C53 
00004F01  50        
00004F02  4143 453E 9074          dc.b      65,67,69,62,32,116,111,32,67,111,110,116,105
00004F06  2074 6F20 
00004F0A  436F 6E74 
00004F0E  69        
00004F0F  6E75 6500 9075          dc.b      110,117,101,0
                    9076   @m68kde~1_6:
00004F14  0D0A 456E 9077          dc.b      13,10,69,110,116,101,114,32,83,116,97,114,116
00004F18  7465 7220 
00004F1C  5374 6172 
00004F20  74        
00004F21  2041 6464 9078          dc.b      32,65,100,100,114,101,115,115,58,32,0
00004F25  7265 7373 
00004F29  3A20 00   
                    9079   @m68kde~1_7:
00004F2C  0D0A 2530 9080          dc.b      13,10,37,48,56,120,32,0
00004F30  3878 2000 
                    9081   @m68kde~1_8:
00004F34  2530 3258 9082          dc.b      37,48,50,88,0
00004F38  00        
                    9083   @m68kde~1_9:
00004F3A  2020 00   9084          dc.b      32,32,0
                    9085   @m68kde~1_10:
00004F3E  0D0A 4669 9086          dc.b      13,10,70,105,108,108,32,77,101,109,111,114,121
00004F42  6C6C 204D 
00004F46  656D 6F72 
00004F4A  79        
00004F4B  2042 6C6F 9087          dc.b      32,66,108,111,99,107,0
00004F4F  636B 00   
                    9088   @m68kde~1_11:
00004F52  0D0A 456E 9089          dc.b      13,10,69,110,116,101,114,32,69,110,100,32,65
00004F56  7465 7220 
00004F5A  456E 6420 
00004F5E  41        
00004F5F  6464 7265 9090          dc.b      100,100,114,101,115,115,58,32,0
00004F63  7373 3A20 
00004F67  00        
                    9091   @m68kde~1_12:
00004F68  0D0A 456E 9092          dc.b      13,10,69,110,116,101,114,32,70,105,108,108,32
00004F6C  7465 7220 
00004F70  4669 6C6C 
00004F74  20        
00004F75  4461 7461 9093          dc.b      68,97,116,97,58,32,0
00004F79  3A20 00   
                    9094   @m68kde~1_13:
00004F7C  0D0A 4669 9095          dc.b      13,10,70,105,108,108,105,110,103,32,65,100,100
00004F80  6C6C 696E 
00004F84  6720 4164 
00004F88  64        
00004F89  7265 7373 9096          dc.b      114,101,115,115,101,115,32,91,36,37,48,56,88
00004F8D  6573 205B 
00004F91  2425 3038 
00004F95  58        
00004F96  202D 2024 9097          dc.b      32,45,32,36,37,48,56,88,93,32,119,105,116,104
00004F9A  2530 3858 
00004F9E  5D20 7769 
00004FA2  7468      
00004FA4  2024 2530 9098          dc.b      32,36,37,48,50,88,0
00004FA8  3258 00   
                    9099   @m68kde~1_14:
00004FAC  0D0A 5573 9100          dc.b      13,10,85,115,101,32,72,121,112,101,114,84,101
00004FB0  6520 4879 
00004FB4  7065 7254 
00004FB8  65        
00004FB9  726D 696E 9101          dc.b      114,109,105,110,97,108,32,116,111,32,83,101
00004FBD  616C 2074 
00004FC1  6F20 5365 
00004FC5  6E64 2054 9102          dc.b      110,100,32,84,101,120,116,32,70,105,108,101
00004FC9  6578 7420 
00004FCD  4669 6C65 
00004FD1  2028 2E68 9103          dc.b      32,40,46,104,101,120,41,13,10,0
00004FD5  6578 290D 
00004FD9  0A00      
                    9104   @m68kde~1_15:
00004FDC  0D0A 4C6F 9105          dc.b      13,10,76,111,97,100,32,70,97,105,108,101,100
00004FE0  6164 2046 
00004FE4  6169 6C65 
00004FE8  64        
00004FE9  2061 7420 9106          dc.b      32,97,116,32,65,100,100,114,101,115,115,32,61
00004FED  4164 6472 
00004FF1  6573 7320 
00004FF5  3D        
00004FF6  205B 2425 9107          dc.b      32,91,36,37,48,56,88,93,13,10,0
00004FFA  3038 585D 
00004FFE  0D0A 00   
                    9108   @m68kde~1_16:
00005002  0D0A 5375 9109          dc.b      13,10,83,117,99,99,101,115,115,58,32,68,111
00005006  6363 6573 
0000500A  733A 2044 
0000500E  6F        
0000500F  776E 6C6F 9110          dc.b      119,110,108,111,97,100,101,100,32,37,100,32
00005013  6164 6564 
00005017  2025 6420 
0000501B  6279 7465 9111          dc.b      98,121,116,101,115,13,10,0
0000501F  730D 0A00 
                    9112   @m68kde~1_17:
00005024  0D0A 4578 9113          dc.b      13,10,69,120,97,109,105,110,101,32,97,110,100
00005028  616D 696E 
0000502C  6520 616E 
00005030  64        
00005031  2043 6861 9114          dc.b      32,67,104,97,110,103,101,32,77,101,109,111,114
00005035  6E67 6520 
00005039  4D65 6D6F 
0000503D  72        
0000503E  7900      9115          dc.b      121,0
                    9116   @m68kde~1_18:
00005040  0D0A 3C45 9117          dc.b      13,10,60,69,83,67,62,32,116,111,32,83,116,111
00005044  5343 3E20 
00005048  746F 2053 
0000504C  746F      
0000504E  702C 203C 9118          dc.b      112,44,32,60,83,80,65,67,69,62,32,116,111,32
00005052  5350 4143 
00005056  453E 2074 
0000505A  6F20      
0000505C  4164 7661 9119          dc.b      65,100,118,97,110,99,101,44,32,39,45,39,32,116
00005060  6E63 652C 
00005064  2027 2D27 
00005068  2074      
0000506A  6F20 476F 9120          dc.b      111,32,71,111,32,66,97,99,107,44,32,60,68,65
0000506E  2042 6163 
00005072  6B2C 203C 
00005076  4441      
00005078  5441 3E20 9121          dc.b      84,65,62,32,116,111,32,99,104,97,110,103,101
0000507C  746F 2063 
00005080  6861 6E67 
00005084  65        
00005085  00        9122          dc.b      0
                    9123   @m68kde~1_19:
00005086  0D0A 456E 9124          dc.b      13,10,69,110,116,101,114,32,65,100,100,114,101
0000508A  7465 7220 
0000508E  4164 6472 
00005092  65        
00005093  7373 3A20 9125          dc.b      115,115,58,32,0
00005097  00        
                    9126   @m68kde~1_20:
00005098  0D0A 5B25 9127          dc.b      13,10,91,37,48,56,120,93,32,58,32,37,48,50,120
0000509C  3038 785D 
000050A0  203A 2025 
000050A4  3032 78   
000050A7  2020 00   9128          dc.b      32,32,0
                    9129   @m68kde~1_21:
000050AA  0D0A 5761 9130          dc.b      13,10,87,97,114,110,105,110,103,32,67,104,97
000050AE  726E 696E 
000050B2  6720 4368 
000050B6  61        
000050B7  6E67 6520 9131          dc.b      110,103,101,32,70,97,105,108,101,100,58,32,87
000050BB  4661 696C 
000050BF  6564 3A20 
000050C3  57        
000050C4  726F 7465 9132          dc.b      114,111,116,101,32,91,37,48,50,120,93,44,32
000050C8  205B 2530 
000050CC  3278 5D2C 
000050D0  20        
000050D1  5265 6164 9133          dc.b      82,101,97,100,32,91,37,48,50,120,93,0
000050D5  205B 2530 
000050D9  3278 5D00 
                    9134   @m68kde~1_22:
000050DE  0A45 7261 9135          dc.b      10,69,114,97,115,105,110,103,46,46,46,10,0
000050E2  7369 6E67 
000050E6  2E2E 2E0A 
000050EA  00        
                    9136   @m68kde~1_23:
000050EC  0D0A 2050 9137          dc.b      13,10,32,80,114,111,103,114,97,109,109,105,110
000050F0  726F 6772 
000050F4  616D 6D69 
000050F8  6E        
000050F9  6720 436F 9138          dc.b      103,32,67,111,109,112,108,101,116,101,33,0
000050FD  6D70 6C65 
00005101  7465 2100 
                    9139   @m68kde~1_24:
00005106  0D0A 204C 9140          dc.b      13,10,32,76,111,97,100,105,110,103,32,80,114
0000510A  6F61 6469 
0000510E  6E67 2050 
00005112  72        
00005113  6F67 7261 9141          dc.b      111,103,114,97,109,32,70,114,111,109,32,83,80
00005117  6D20 4672 
0000511B  6F6D 2053 
0000511F  50        
00005120  4920 466C 9142          dc.b      73,32,70,108,97,115,104,46,46,46,46,0
00005124  6173 682E 
00005128  2E2E 2E00 
                    9143   @m68kde~1_25:
0000512C  0D0A 2052 9144          dc.b      13,10,32,82,101,97,100,32,68,97,116,97,58,32
00005130  6561 6420 
00005134  4461 7461 
00005138  3A20      
0000513A  2530 3878 9145          dc.b      37,48,56,120,32,10,0
0000513E  200A 00   
                    9146   @m68kde~1_26:
00005142  4949 435F 9147          dc.b      73,73,67,95,67,82,83,82,32,84,114,97,110,115
00005146  4352 5352 
0000514A  2054 7261 
0000514E  6E73      
00005150  6D69 7420 9148          dc.b      109,105,116,32,40,66,105,110,97,114,121,41,58
00005154  2842 696E 
00005158  6172 7929 
0000515C  3A        
0000515D  2000      9149          dc.b      32,0
                    9150   @m68kde~1_27:
00005160  2564 00   9151          dc.b      37,100,0
                    9152   @m68kde~1_28:
00005164  0A00      9153          dc.b      10,0
                    9154   @m68kde~1_29:
00005166  4545 5052 9155          dc.b      69,69,80,82,79,77,32,70,108,97,115,104,32,80
0000516A  4F4D 2046 
0000516E  6C61 7368 
00005172  2050      
00005174  6167 6520 9156          dc.b      97,103,101,32,87,114,105,116,101,58,32,83,116
00005178  5772 6974 
0000517C  653A 2053 
00005180  74        
00005181  6172 7420 9157          dc.b      97,114,116,32,65,100,100,114,101,115,115,58
00005185  4164 6472 
00005189  6573 733A 
0000518D  2030 7825 9158          dc.b      32,48,120,37,120,44,32,110,117,109,98,121,116
00005191  782C 206E 
00005195  756D 6279 
00005199  74        
0000519A  6573 3A20 9159          dc.b      101,115,58,32,37,100,10,0
0000519E  2564 0A00 
                    9160   @m68kde~1_30:
000051A2  0D0A 2042 9161          dc.b      13,10,32,66,108,111,99,107,32,48,32,65,100,100
000051A6  6C6F 636B 
000051AA  2030 2041 
000051AE  6464      
000051B0  7265 7373 9162          dc.b      114,101,115,115,58,32,48,120,37,48,52,88,58
000051B4  3A20 3078 
000051B8  2530 3458 
000051BC  3A        
000051BD  2025 640A 9163          dc.b      32,37,100,10,0
000051C1  00        
                    9164   @m68kde~1_31:
000051C2  0D0A 2045 9165          dc.b      13,10,32,69,120,105,116,105,110,103,32,69,69
000051C6  7869 7469 
000051CA  6E67 2045 
000051CE  45        
000051CF  5052 4F4D 9166          dc.b      80,82,79,77,32,82,101,97,100,32,66,108,111,99
000051D3  2052 6561 
000051D7  6420 426C 
000051DB  6F63      
000051DD  6B20 300A 9167          dc.b      107,32,48,10,0
000051E1  00        
                    9168   @m68kde~1_32:
000051E2  0D0A 2042 9169          dc.b      13,10,32,66,108,111,99,107,32,49,32,65,100,100
000051E6  6C6F 636B 
000051EA  2031 2041 
000051EE  6464      
000051F0  7265 7373 9170          dc.b      114,101,115,115,58,32,48,120,37,48,52,88,58
000051F4  3A20 3078 
000051F8  2530 3458 
000051FC  3A        
000051FD  2025 640A 9171          dc.b      32,37,100,10,0
00005201  00        
                    9172   @m68kde~1_33:
00005202  0D0A 2045 9173          dc.b      13,10,32,69,120,105,116,105,110,103,32,69,69
00005206  7869 7469 
0000520A  6E67 2045 
0000520E  45        
0000520F  5052 4F4D 9174          dc.b      80,82,79,77,32,82,101,97,100,32,66,108,111,99
00005213  2052 6561 
00005217  6420 426C 
0000521B  6F63      
0000521D  6B20 310A 9175          dc.b      107,32,49,10,0
00005221  00        
                    9176   @m68kde~1_34:
00005222  0D0A 2049 9177          dc.b      13,10,32,73,50,67,32,84,101,115,116,10,0
00005226  3243 2054 
0000522A  6573 740A 
0000522E  00        
                    9178   @m68kde~1_35:
00005230  0D0A 496E 9179          dc.b      13,10,73,110,105,116,105,97,108,105,122,105
00005234  6974 6961 
00005238  6C69 7A69 
0000523C  6E67 2049 9180          dc.b      110,103,32,73,50,67,46,46,46,10,0
00005240  3243 2E2E 
00005244  2E0A 00   
                    9181   @m68kde~1_36:
00005248  0D0A 4368 9182          dc.b      13,10,67,104,111,111,115,101,32,111,112,116
0000524C  6F6F 7365 
00005250  206F 7074 
00005254  696F 6E3A 9183          dc.b      105,111,110,58,10,0
00005258  0A00      
                    9184   @m68kde~1_37:
0000525A  3120 5265 9185          dc.b      49,32,82,101,97,100,32,83,105,110,103,108,101
0000525E  6164 2053 
00005262  696E 676C 
00005266  65        
00005267  2042 7974 9186          dc.b      32,66,121,116,101,32,102,114,111,109,32,69,69
0000526B  6520 6672 
0000526F  6F6D 2045 
00005273  45        
00005274  5052 4F4D 9187          dc.b      80,82,79,77,10,0
00005278  0A00      
                    9188   @m68kde~1_38:
0000527A  3220 5772 9189          dc.b      50,32,87,114,105,116,101,32,83,105,110,103,108
0000527E  6974 6520 
00005282  5369 6E67 
00005286  6C        
00005287  6520 4279 9190          dc.b      101,32,66,121,116,101,32,116,111,32,69,69,80
0000528B  7465 2074 
0000528F  6F20 4545 
00005293  50        
00005294  524F 4D0A 9191          dc.b      82,79,77,10,0
00005298  00        
                    9192   @m68kde~1_39:
0000529A  3320 5265 9193          dc.b      51,32,82,101,97,100,32,66,108,111,99,107,32
0000529E  6164 2042 
000052A2  6C6F 636B 
000052A6  20        
000052A7  6F66 2044 9194          dc.b      111,102,32,68,97,116,97,32,102,114,111,109,32
000052AB  6174 6120 
000052AF  6672 6F6D 
000052B3  20        
000052B4  4545 5052 9195          dc.b      69,69,80,82,79,77,10,0
000052B8  4F4D 0A00 
                    9196   @m68kde~1_40:
000052BC  3420 5772 9197          dc.b      52,32,87,114,105,116,101,32,66,108,111,99,107
000052C0  6974 6520 
000052C4  426C 6F63 
000052C8  6B        
000052C9  206F 6620 9198          dc.b      32,111,102,32,68,97,116,97,32,116,111,32,69
000052CD  4461 7461 
000052D1  2074 6F20 
000052D5  45        
000052D6  4550 524F 9199          dc.b      69,80,82,79,77,10,0
000052DA  4D0A 00   
                    9200   @m68kde~1_41:
000052DE  0D0A 5265 9201          dc.b      13,10,82,101,97,100,32,83,105,110,103,108,101
000052E2  6164 2053 
000052E6  696E 676C 
000052EA  65        
000052EB  2042 7974 9202          dc.b      32,66,121,116,101,10,0
000052EF  650A 00   
                    9203   @m68kde~1_42:
000052F2  456E 7465 9204          dc.b      69,110,116,101,114,32,97,100,100,114,101,115
000052F6  7220 6164 
000052FA  6472 6573 
000052FE  7320 2868 9205          dc.b      115,32,40,104,101,120,41,58,32,48,120,0
00005302  6578 293A 
00005306  2030 7800 
                    9206   @m68kde~1_43:
0000530A  0D0A 5265 9207          dc.b      13,10,82,101,97,100,32,102,114,111,109,32,97
0000530E  6164 2066 
00005312  726F 6D20 
00005316  61        
00005317  6464 7265 9208          dc.b      100,100,114,101,115,115,32,48,120,37,88,58,32
0000531B  7373 2030 
0000531F  7825 583A 
00005323  20        
00005324  3078 2530 9209          dc.b      48,120,37,48,50,88,10,0
00005328  3258 0A00 
                    9210   @m68kde~1_44:
0000532C  0D0A 5772 9211          dc.b      13,10,87,114,105,116,101,32,83,105,110,103,108
00005330  6974 6520 
00005334  5369 6E67 
00005338  6C        
00005339  6520 4279 9212          dc.b      101,32,66,121,116,101,10,0
0000533D  7465 0A00 
                    9213   @m68kde~1_45:
00005342  0D0A 456E 9214          dc.b      13,10,69,110,116,101,114,32,97,100,100,114,101
00005346  7465 7220 
0000534A  6164 6472 
0000534E  65        
0000534F  7373 2028 9215          dc.b      115,115,32,40,104,101,120,41,58,32,48,120,0
00005353  6865 7829 
00005357  3A20 3078 
0000535B  00        
                    9216   @m68kde~1_46:
0000535C  0A45 6E74 9217          dc.b      10,69,110,116,101,114,32,119,104,105,99,104
00005360  6572 2077 
00005364  6869 6368 
00005368  2064 6174 9218          dc.b      32,100,97,116,97,32,112,97,116,116,101,114,110
0000536C  6120 7061 
00005370  7474 6572 
00005374  6E        
00005375  2079 6F75 9219          dc.b      32,121,111,117,32,119,97,110,116,32,116,111
00005379  2077 616E 
0000537D  7420 746F 
00005381  2077 7269 9220          dc.b      32,119,114,105,116,101,32,105,110,116,111,32
00005385  7465 2069 
00005389  6E74 6F20 
0000538D  6D65 6D6F 9221          dc.b      109,101,109,111,114,121,58,10,0
00005391  7279 3A0A 
00005395  00        
                    9222   @m68kde~1_47:
00005396  2030 3A20 9223          dc.b      32,48,58,32,48,120,48,48,10,32,49,58,32,48,120
0000539A  3078 3030 
0000539E  0A20 313A 
000053A2  2030 78   
000053A5  4232 0A20 9224          dc.b      66,50,10,32,50,58,32,48,120,67,51,10,32,51,58
000053A9  323A 2030 
000053AD  7843 330A 
000053B1  2033 3A   
000053B4  2030 7844 9225          dc.b      32,48,120,68,52,10,32,52,58,32,67,117,115,116
000053B8  340A 2034 
000053BC  3A20 4375 
000053C0  7374      
000053C2  6F6D 2076 9226          dc.b      111,109,32,118,97,108,117,101,10,0
000053C6  616C 7565 
000053CA  0A00      
                    9227   @m68kde~1_48:
000053CC  5365 6C65 9228          dc.b      83,101,108,101,99,116,32,112,97,116,116,101
000053D0  6374 2070 
000053D4  6174 7465 
000053D8  726E 00   9229          dc.b      114,110,0
                    9230   @m68kde~1_49:
000053DC  5772 6F74 9231          dc.b      87,114,111,116,101,32,48,120,37,48,50,88,32
000053E0  6520 3078 
000053E4  2530 3258 
000053E8  20        
000053E9  746F 2061 9232          dc.b      116,111,32,97,100,100,114,101,115,115,32,48
000053ED  6464 7265 
000053F1  7373 2030 
000053F5  7825 580A 9233          dc.b      120,37,88,10,0
000053F9  00        
                    9234   @m68kde~1_50:
000053FA  5265 6164 9235          dc.b      82,101,97,100,32,98,97,99,107,58,32,48,120,37
000053FE  2062 6163 
00005402  6B3A 2030 
00005406  7825      
00005408  3032 580A 9236          dc.b      48,50,88,10,0
0000540C  00        
                    9237   @m68kde~1_51:
0000540E  0D0A 5265 9238          dc.b      13,10,82,101,97,100,32,66,108,111,99,107,32
00005412  6164 2042 
00005416  6C6F 636B 
0000541A  20        
0000541B  6F66 2044 9239          dc.b      111,102,32,68,97,116,97,10,0
0000541F  6174 610A 
00005423  00        
                    9240   @m68kde~1_52:
00005424  456E 7465 9241          dc.b      69,110,116,101,114,32,115,116,97,114,116,32
00005428  7220 7374 
0000542C  6172 7420 
00005430  6164 6472 9242          dc.b      97,100,100,114,101,115,115,32,40,104,101,120
00005434  6573 7320 
00005438  2868 6578 
0000543C  293A 2030 9243          dc.b      41,58,32,48,120,0
00005440  7800      
                    9244   @m68kde~1_53:
00005442  0D0A 456E 9245          dc.b      13,10,69,110,116,101,114,32,110,117,109,98,101
00005446  7465 7220 
0000544A  6E75 6D62 
0000544E  65        
0000544F  7220 6F66 9246          dc.b      114,32,111,102,32,98,121,116,101,115,32,116
00005453  2062 7974 
00005457  6573 2074 
0000545B  6F20 7265 9247          dc.b      111,32,114,101,97,100,32,40,104,101,120,41,58
0000545F  6164 2028 
00005463  6865 7829 
00005467  3A        
00005468  2030 7800 9248          dc.b      32,48,120,0
                    9249   @m68kde~1_54:
0000546C  0D0A 5265 9250          dc.b      13,10,82,101,97,100,105,110,103,32,48,120,37
00005470  6164 696E 
00005474  6720 3078 
00005478  25        
00005479  5820 2825 9251          dc.b      88,32,40,37,100,41,32,98,121,116,101,115,32
0000547D  6429 2062 
00005481  7974 6573 
00005485  20        
00005486  7374 6172 9252          dc.b      115,116,97,114,116,105,110,103,32,102,114,111
0000548A  7469 6E67 
0000548E  2066 726F 
00005492  6D20 6164 9253          dc.b      109,32,97,100,100,114,101,115,115,32,48,120
00005496  6472 6573 
0000549A  7320 3078 
0000549E  2558 2E2E 9254          dc.b      37,88,46,46,46,10,0
000054A2  2E0A 00   
                    9255   @m68kde~1_55:
000054A6  0D0A 5772 9256          dc.b      13,10,87,114,105,116,101,32,66,108,111,99,107
000054AA  6974 6520 
000054AE  426C 6F63 
000054B2  6B        
000054B3  206F 6620 9257          dc.b      32,111,102,32,68,97,116,97,10,0
000054B7  4461 7461 
000054BB  0A00      
                    9258   @m68kde~1_56:
000054BE  0D0A 456E 9259          dc.b      13,10,69,110,116,101,114,32,110,117,109,98,101
000054C2  7465 7220 
000054C6  6E75 6D62 
000054CA  65        
000054CB  7220 6F66 9260          dc.b      114,32,111,102,32,98,121,116,101,115,32,116
000054CF  2062 7974 
000054D3  6573 2074 
000054D7  6F20 7772 9261          dc.b      111,32,119,114,105,116,101,32,40,104,101,120
000054DB  6974 6520 
000054DF  2868 6578 
000054E3  293A 2030 9262          dc.b      41,58,32,48,120,0
000054E7  7800      
                    9263   @m68kde~1_57:
000054EA  0D0A 456E 9264          dc.b      13,10,69,110,116,101,114,32,119,104,105,99,104
000054EE  7465 7220 
000054F2  7768 6963 
000054F6  68        
000054F7  2064 6174 9265          dc.b      32,100,97,116,97,32,112,97,116,116,101,114,110
000054FB  6120 7061 
000054FF  7474 6572 
00005503  6E        
00005504  2079 6F75 9266          dc.b      32,121,111,117,32,119,97,110,116,32,116,111
00005508  2077 616E 
0000550C  7420 746F 
00005510  2077 7269 9267          dc.b      32,119,114,105,116,101,32,105,110,116,111,32
00005514  7465 2069 
00005518  6E74 6F20 
0000551C  6D65 6D6F 9268          dc.b      109,101,109,111,114,121,58,10,0
00005520  7279 3A0A 
00005524  00        
                    9269   @m68kde~1_58:
00005526  2030 3A20 9270          dc.b      32,48,58,32,48,120,48,48,10,32,49,58,32,48,120
0000552A  3078 3030 
0000552E  0A20 313A 
00005532  2030 78   
00005535  4232 0A20 9271          dc.b      66,50,10,32,50,58,32,48,120,67,51,10,32,51,58
00005539  323A 2030 
0000553D  7843 330A 
00005541  2033 3A   
00005544  2030 7844 9272          dc.b      32,48,120,68,52,10,32,52,58,32,73,110,99,114
00005548  340A 2034 
0000554C  3A20 496E 
00005550  6372      
00005552  656D 656E 9273          dc.b      101,109,101,110,116,105,110,103,32,112,97,116
00005556  7469 6E67 
0000555A  2070 6174 
0000555E  7465 726E 9274          dc.b      116,101,114,110,10,0
00005562  0A00      
                    9275   @m68kde~1_59:
00005564  5365 6C65 9276          dc.b      83,101,108,101,99,116,101,100,32,105,110,99
00005568  6374 6564 
0000556C  2069 6E63 
00005570  7265 6D65 9277          dc.b      114,101,109,101,110,116,105,110,103,32,112,97
00005574  6E74 696E 
00005578  6720 7061 
0000557C  7474 6572 9278          dc.b      116,116,101,114,110,32,40,97,100,100,114,101
00005580  6E20 2861 
00005584  6464 7265 
00005588  7373 2026 9279          dc.b      115,115,32,38,32,48,120,70,70,41,10,0
0000558C  2030 7846 
00005590  4629 0A00 
                    9280   @m68kde~1_60:
00005594  5365 6C65 9281          dc.b      83,101,108,101,99,116,101,100,32,112,97,116
00005598  6374 6564 
0000559C  2070 6174 
000055A0  7465 726E 9282          dc.b      116,101,114,110,58,32,48,120,37,48,50,88,10
000055A4  3A20 3078 
000055A8  2530 3258 
000055AC  0A        
000055AD  00        9283          dc.b      0
                    9284   @m68kde~1_61:
000055AE  0D0A 5072 9285          dc.b      13,10,80,114,101,112,97,114,105,110,103,32,116
000055B2  6570 6172 
000055B6  696E 6720 
000055BA  74        
000055BB  6F20 7772 9286          dc.b      111,32,119,114,105,116,101,32,48,120,37,88,32
000055BF  6974 6520 
000055C3  3078 2558 
000055C7  20        
000055C8  2825 6429 9287          dc.b      40,37,100,41,32,98,121,116,101,115,32,111,102
000055CC  2062 7974 
000055D0  6573 206F 
000055D4  66        
000055D5  2064 6174 9288          dc.b      32,100,97,116,97,32,115,116,97,114,116,105,110
000055D9  6120 7374 
000055DD  6172 7469 
000055E1  6E        
000055E2  6720 6174 9289          dc.b      103,32,97,116,32,97,100,100,114,101,115,115
000055E6  2061 6464 
000055EA  7265 7373 
000055EE  2030 7825 9290          dc.b      32,48,120,37,88,46,46,46,10,0
000055F2  582E 2E2E 
000055F6  0A00      
                    9291   @m68kde~1_62:
000055F8  0D50 7269 9292          dc.b      13,80,114,105,110,116,105,110,103,32,69,110
000055FC  6E74 696E 
00005600  6720 456E 
00005604  7469 7265 9293          dc.b      116,105,114,101,32,69,69,80,82,79,77,10,0
00005608  2045 4550 
0000560C  524F 4D0A 
00005610  00        
                    9294   @m68kde~1_63:
00005612  0D0A 2041 9295          dc.b      13,10,32,65,68,67,32,82,101,97,100,58,32,37
00005616  4443 2052 
0000561A  6561 643A 
0000561E  2025      
00005620  640A 00   9296          dc.b      100,10,0
                    9297   @m68kde~1_64:
00005624  2425 3038 9298          dc.b      36,37,48,56,88,32,32,0
00005628  5820 2000 
                    9299   @m68kde~1_65:
0000562C  2000      9300          dc.b      32,0
                    9301   @m68kde~1_66:
0000562E  2E00      9302          dc.b      46,0
                    9303   @m68kde~1_67:
00005630  2563 00   9304          dc.b      37,99,0
                    9305   @m68kde~1_68:
00005634  00        9306          dc.b      0
                    9307   @m68kde~1_69:
00005636  0D0A 0D0A 9308          dc.b      13,10,13,10,32,68,48,32,61,32,36,37,48,56,88
0000563A  2044 3020 
0000563E  3D20 2425 
00005642  3038 58   
00005645  2020 4130 9309          dc.b      32,32,65,48,32,61,32,36,37,48,56,88,0
00005649  203D 2024 
0000564D  2530 3858 
00005651  00        
                    9310   @m68kde~1_70:
00005652  0D0A 2044 9311          dc.b      13,10,32,68,49,32,61,32,36,37,48,56,88,32,32
00005656  3120 3D20 
0000565A  2425 3038 
0000565E  5820 20   
00005661  4131 203D 9312          dc.b      65,49,32,61,32,36,37,48,56,88,0
00005665  2024 2530 
00005669  3858 00   
                    9313   @m68kde~1_71:
0000566C  0D0A 2044 9314          dc.b      13,10,32,68,50,32,61,32,36,37,48,56,88,32,32
00005670  3220 3D20 
00005674  2425 3038 
00005678  5820 20   
0000567B  4132 203D 9315          dc.b      65,50,32,61,32,36,37,48,56,88,0
0000567F  2024 2530 
00005683  3858 00   
                    9316   @m68kde~1_72:
00005686  0D0A 2044 9317          dc.b      13,10,32,68,51,32,61,32,36,37,48,56,88,32,32
0000568A  3320 3D20 
0000568E  2425 3038 
00005692  5820 20   
00005695  4133 203D 9318          dc.b      65,51,32,61,32,36,37,48,56,88,0
00005699  2024 2530 
0000569D  3858 00   
                    9319   @m68kde~1_73:
000056A0  0D0A 2044 9320          dc.b      13,10,32,68,52,32,61,32,36,37,48,56,88,32,32
000056A4  3420 3D20 
000056A8  2425 3038 
000056AC  5820 20   
000056AF  4134 203D 9321          dc.b      65,52,32,61,32,36,37,48,56,88,0
000056B3  2024 2530 
000056B7  3858 00   
                    9322   @m68kde~1_74:
000056BA  0D0A 2044 9323          dc.b      13,10,32,68,53,32,61,32,36,37,48,56,88,32,32
000056BE  3520 3D20 
000056C2  2425 3038 
000056C6  5820 20   
000056C9  4135 203D 9324          dc.b      65,53,32,61,32,36,37,48,56,88,0
000056CD  2024 2530 
000056D1  3858 00   
                    9325   @m68kde~1_75:
000056D4  0D0A 2044 9326          dc.b      13,10,32,68,54,32,61,32,36,37,48,56,88,32,32
000056D8  3620 3D20 
000056DC  2425 3038 
000056E0  5820 20   
000056E3  4136 203D 9327          dc.b      65,54,32,61,32,36,37,48,56,88,0
000056E7  2024 2530 
000056EB  3858 00   
                    9328   @m68kde~1_76:
000056EE  0D0A 2044 9329          dc.b      13,10,32,68,55,32,61,32,36,37,48,56,88,32,32
000056F2  3720 3D20 
000056F6  2425 3038 
000056FA  5820 20   
000056FD  4137 203D 9330          dc.b      65,55,32,61,32,36,37,48,56,88,0
00005701  2024 2530 
00005705  3858 00   
                    9331   @m68kde~1_77:
00005708  0D0A 0D0A 9332          dc.b      13,10,13,10,85,83,80,32,61,32,36,37,48,56,88
0000570C  5553 5020 
00005710  3D20 2425 
00005714  3038 58   
00005717  2020 2841 9333          dc.b      32,32,40,65,55,41,32,85,115,101,114,32,83,80
0000571B  3729 2055 
0000571F  7365 7220 
00005723  5350      
00005725  00        9334          dc.b      0
                    9335   @m68kde~1_78:
00005726  0D0A 5353 9336          dc.b      13,10,83,83,80,32,61,32,36,37,48,56,88,32,32
0000572A  5020 3D20 
0000572E  2425 3038 
00005732  5820 20   
00005735  2841 3729 9337          dc.b      40,65,55,41,32,83,117,112,101,114,118,105,115
00005739  2053 7570 
0000573D  6572 7669 
00005741  73        
00005742  6F72 2053 9338          dc.b      111,114,32,83,80,0
00005746  5000      
                    9339   @m68kde~1_79:
00005748  0D0A 2053 9340          dc.b      13,10,32,83,82,32,61,32,36,37,48,52,88,32,32
0000574C  5220 3D20 
00005750  2425 3034 
00005754  5820 20   
00005757  2000      9341          dc.b      32,0
                    9342   @m68kde~1_80:
0000575A  2020 205B 9343          dc.b      32,32,32,91,0
0000575E  00        
                    9344   @m68kde~1_81:
00005760  0D0A 2050 9345          dc.b      13,10,32,80,67,32,61,32,36,37,48,56,88,32,32
00005764  4320 3D20 
00005768  2425 3038 
0000576C  5820 20   
0000576F  00        9346          dc.b      0
                    9347   @m68kde~1_82:
00005770  5B40 2042 9348          dc.b      91,64,32,66,82,69,65,75,80,79,73,78,84,93,0
00005774  5245 414B 
00005778  504F 494E 
0000577C  545D 00   
                    9349   @m68kde~1_83:
00005780  0D0A 5750 9350          dc.b      13,10,87,80,37,100,32,61,32,37,115,0
00005784  2564 203D 
00005788  2025 7300 
                    9351   @m68kde~1_84:
0000578C  0D0A 0D0A 9352          dc.b      13,10,13,10,13,10,13,10,13,10,13,10,83,105,110
00005790  0D0A 0D0A 
00005794  0D0A 0D0A 
00005798  5369 6E   
0000579B  676C 6520 9353          dc.b      103,108,101,32,83,116,101,112,32,32,58,91,79
0000579F  5374 6570 
000057A3  2020 3A5B 
000057A7  4F        
000057A8  4E5D 00   9354          dc.b      78,93,0
                    9355   @m68kde~1_85:
000057AC  0D0A 4272 9356          dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
000057B0  6561 6B20 
000057B4  506F 696E 
000057B8  74        
000057B9  7320 3A5B 9357          dc.b      115,32,58,91,68,105,115,97,98,108,101,100,93
000057BD  4469 7361 
000057C1  626C 6564 
000057C5  5D        
000057C6  00        9358          dc.b      0
                    9359   @m68kde~1_86:
000057C8  0D0A 5072 9360          dc.b      13,10,80,114,101,115,115,32,60,83,80,65,67,69
000057CC  6573 7320 
000057D0  3C53 5041 
000057D4  4345      
000057D6  3E20 746F 9361          dc.b      62,32,116,111,32,69,120,101,99,117,116,101,32
000057DA  2045 7865 
000057DE  6375 7465 
000057E2  20        
000057E3  4E65 7874 9362          dc.b      78,101,120,116,32,73,110,115,116,114,117,99
000057E7  2049 6E73 
000057EB  7472 7563 
000057EF  7469 6F6E 9363          dc.b      116,105,111,110,0
000057F3  00        
                    9364   @m68kde~1_87:
000057F4  0D0A 5072 9365          dc.b      13,10,80,114,101,115,115,32,60,69,83,67,62,32
000057F8  6573 7320 
000057FC  3C45 5343 
00005800  3E20      
00005802  746F 2052 9366          dc.b      116,111,32,82,101,115,117,109,101,32,80,114
00005806  6573 756D 
0000580A  6520 5072 
0000580E  6F67 7261 9367          dc.b      111,103,114,97,109,0
00005812  6D00      
                    9368   @m68kde~1_88:
00005814  0D0A 496C 9369          dc.b      13,10,73,108,108,101,103,97,108,32,68,97,116
00005818  6C65 6761 
0000581C  6C20 4461 
00005820  74        
00005821  6120 5265 9370          dc.b      97,32,82,101,103,105,115,116,101,114,32,58,32
00005825  6769 7374 
00005829  6572 203A 
0000582D  20        
0000582E  5573 6520 9371          dc.b      85,115,101,32,68,48,45,68,55,46,46,46,46,46
00005832  4430 2D44 
00005836  372E 2E2E 
0000583A  2E2E      
0000583C  0D0A 00   9372          dc.b      13,10,0
                    9373   @m68kde~1_89:
00005840  0D0A 4425 9374          dc.b      13,10,68,37,99,32,61,32,0
00005844  6320 3D20 
00005848  00        
                    9375   @m68kde~1_90:
0000584A  0D0A 496C 9376          dc.b      13,10,73,108,108,101,103,97,108,32,65,100,100
0000584E  6C65 6761 
00005852  6C20 4164 
00005856  64        
00005857  7265 7373 9377          dc.b      114,101,115,115,32,82,101,103,105,115,116,101
0000585B  2052 6567 
0000585F  6973 7465 
00005863  7220 3A20 9378          dc.b      114,32,58,32,85,115,101,32,65,48,45,65,55,46
00005867  5573 6520 
0000586B  4130 2D41 
0000586F  372E      
00005871  2E2E 2E2E 9379          dc.b      46,46,46,46,13,10,0
00005875  0D0A 00   
                    9380   @m68kde~1_91:
00005878  0D0A 4125 9381          dc.b      13,10,65,37,99,32,61,32,0
0000587C  6320 3D20 
00005880  00        
                    9382   @m68kde~1_92:
00005882  0D0A 5573 9383          dc.b      13,10,85,115,101,114,32,83,80,32,61,32,0
00005886  6572 2053 
0000588A  5020 3D20 
0000588E  00        
                    9384   @m68kde~1_93:
00005890  0D0A 496C 9385          dc.b      13,10,73,108,108,101,103,97,108,32,82,101,103
00005894  6C65 6761 
00005898  6C20 5265 
0000589C  67        
0000589D  6973 7465 9386          dc.b      105,115,116,101,114,46,46,46,46,0
000058A1  722E 2E2E 
000058A5  2E00      
                    9387   @m68kde~1_94:
000058A8  0D0A 5379 9388          dc.b      13,10,83,121,115,116,101,109,32,83,80,32,61
000058AC  7374 656D 
000058B0  2053 5020 
000058B4  3D        
000058B5  2000      9389          dc.b      32,0
                    9390   @m68kde~1_95:
000058B8  0D0A 5043 9391          dc.b      13,10,80,67,32,61,32,0
000058BC  203D 2000 
                    9392   @m68kde~1_96:
000058C0  0D0A 5352 9393          dc.b      13,10,83,82,32,61,32,0
000058C4  203D 2000 
                    9394   @m68kde~1_97:
000058C8  0D0A 496C 9395          dc.b      13,10,73,108,108,101,103,97,108,32,82,101,103
000058CC  6C65 6761 
000058D0  6C20 5265 
000058D4  67        
000058D5  6973 7465 9396          dc.b      105,115,116,101,114,58,32,85,115,101,32,65,48
000058D9  723A 2055 
000058DD  7365 2041 
000058E1  30        
000058E2  2D41 372C 9397          dc.b      45,65,55,44,32,68,48,45,68,55,44,32,83,83,80
000058E6  2044 302D 
000058EA  4437 2C20 
000058EE  5353 50   
000058F1  2C20 5553 9398          dc.b      44,32,85,83,80,44,32,80,67,32,111,114,32,83
000058F5  502C 2050 
000058F9  4320 6F72 
000058FD  2053      
000058FF  520D 0A00 9399          dc.b      82,13,10,0
                    9400   @m68kde~1_98:
00005904  0D0A 0D0A 9401          dc.b      13,10,13,10,78,117,109,32,32,32,32,32,65,100
00005908  4E75 6D20 
0000590C  2020 2020 
00005910  4164      
00005912  6472 6573 9402          dc.b      100,114,101,115,115,32,32,32,32,32,32,73,110
00005916  7320 2020 
0000591A  2020 2049 
0000591E  6E        
0000591F  7374 7275 9403          dc.b      115,116,114,117,99,116,105,111,110,0
00005923  6374 696F 
00005927  6E00      
                    9404   @m68kde~1_99:
0000592A  0D0A 2D2D 9405          dc.b      13,10,45,45,45,32,32,32,32,32,45,45,45,45,45
0000592E  2D20 2020 
00005932  2020 2D2D 
00005936  2D2D 2D   
00005939  2D2D 2D2D 9406          dc.b      45,45,45,45,32,32,32,32,45,45,45,45,45,45,45
0000593D  2020 2020 
00005941  2D2D 2D2D 
00005945  2D2D 2D   
00005948  2D2D 2D2D 9407          dc.b      45,45,45,45,0
0000594C  00        
                    9408   @m68kde~1_100:
0000594E  0D0A 4E6F 9409          dc.b      13,10,78,111,32,66,114,101,97,107,80,111,105
00005952  2042 7265 
00005956  616B 506F 
0000595A  69        
0000595B  6E74 7320 9410          dc.b      110,116,115,32,83,101,116,0
0000595F  5365 7400 
                    9411   @m68kde~1_101:
00005964  0D0A 2533 9412          dc.b      13,10,37,51,100,32,32,32,32,32,36,37,48,56,120
00005968  6420 2020 
0000596C  2020 2425 
00005970  3038 78   
00005973  00        9413          dc.b      0
                    9414   @m68kde~1_102:
00005974  0D0A 4E75 9415          dc.b      13,10,78,117,109,32,32,32,32,32,65,100,100,114
00005978  6D20 2020 
0000597C  2020 4164 
00005980  6472      
00005982  6573 7300 9416          dc.b      101,115,115,0
                    9417   @m68kde~1_103:
00005986  0D0A 2D2D 9418          dc.b      13,10,45,45,45,32,32,32,32,32,45,45,45,45,45
0000598A  2D20 2020 
0000598E  2020 2D2D 
00005992  2D2D 2D   
00005995  2D2D 2D2D 9419          dc.b      45,45,45,45,0
00005999  00        
                    9420   @m68kde~1_104:
0000599A  0D0A 4E6F 9421          dc.b      13,10,78,111,32,87,97,116,99,104,80,111,105
0000599E  2057 6174 
000059A2  6368 506F 
000059A6  69        
000059A7  6E74 7320 9422          dc.b      110,116,115,32,83,101,116,0
000059AB  5365 7400 
                    9423   @m68kde~1_105:
000059B0  0D0A 456E 9424          dc.b      13,10,69,110,116,101,114,32,66,114,101,97,107
000059B4  7465 7220 
000059B8  4272 6561 
000059BC  6B        
000059BD  2050 6F69 9425          dc.b      32,80,111,105,110,116,32,78,117,109,98,101,114
000059C1  6E74 204E 
000059C5  756D 6265 
000059C9  72        
000059CA  3A20 00   9426          dc.b      58,32,0
                    9427   @m68kde~1_106:
000059CE  0D0A 496C 9428          dc.b      13,10,73,108,108,101,103,97,108,32,82,97,110
000059D2  6C65 6761 
000059D6  6C20 5261 
000059DA  6E        
000059DB  6765 203A 9429          dc.b      103,101,32,58,32,85,115,101,32,48,32,45,32,55
000059DF  2055 7365 
000059E3  2030 202D 
000059E7  2037      
000059E9  00        9430          dc.b      0
                    9431   @m68kde~1_107:
000059EA  0D0A 4272 9432          dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
000059EE  6561 6B20 
000059F2  506F 696E 
000059F6  74        
000059F7  2043 6C65 9433          dc.b      32,67,108,101,97,114,101,100,46,46,46,46,46
000059FB  6172 6564 
000059FF  2E2E 2E2E 
00005A03  2E        
00005A04  0D0A 00   9434          dc.b      13,10,0
                    9435   @m68kde~1_108:
00005A08  0D0A 4272 9436          dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
00005A0C  6561 6B20 
00005A10  506F 696E 
00005A14  74        
00005A15  2077 6173 9437          dc.b      32,119,97,115,110,39,116,32,83,101,116,46,46
00005A19  6E27 7420 
00005A1D  5365 742E 
00005A21  2E        
00005A22  2E2E 2E00 9438          dc.b      46,46,46,0
                    9439   @m68kde~1_109:
00005A26  0D0A 456E 9440          dc.b      13,10,69,110,116,101,114,32,87,97,116,99,104
00005A2A  7465 7220 
00005A2E  5761 7463 
00005A32  68        
00005A33  2050 6F69 9441          dc.b      32,80,111,105,110,116,32,78,117,109,98,101,114
00005A37  6E74 204E 
00005A3B  756D 6265 
00005A3F  72        
00005A40  3A20 00   9442          dc.b      58,32,0
                    9443   @m68kde~1_110:
00005A44  0D0A 5761 9444          dc.b      13,10,87,97,116,99,104,32,80,111,105,110,116
00005A48  7463 6820 
00005A4C  506F 696E 
00005A50  74        
00005A51  2043 6C65 9445          dc.b      32,67,108,101,97,114,101,100,46,46,46,46,46
00005A55  6172 6564 
00005A59  2E2E 2E2E 
00005A5D  2E        
00005A5E  0D0A 00   9446          dc.b      13,10,0
                    9447   @m68kde~1_111:
00005A62  0D0A 5761 9448          dc.b      13,10,87,97,116,99,104,32,80,111,105,110,116
00005A66  7463 6820 
00005A6A  506F 696E 
00005A6E  74        
00005A6F  2057 6173 9449          dc.b      32,87,97,115,32,110,111,116,32,83,101,116,46
00005A73  206E 6F74 
00005A77  2053 6574 
00005A7B  2E        
00005A7C  2E2E 2E2E 9450          dc.b      46,46,46,46,0
00005A80  00        
                    9451   @m68kde~1_112:
00005A82  0D0A 4E6F 9452          dc.b      13,10,78,111,32,70,82,69,69,32,66,114,101,97
00005A86  2046 5245 
00005A8A  4520 4272 
00005A8E  6561      
00005A90  6B20 506F 9453          dc.b      107,32,80,111,105,110,116,115,46,46,46,46,46
00005A94  696E 7473 
00005A98  2E2E 2E2E 
00005A9C  2E        
00005A9D  00        9454          dc.b      0
                    9455   @m68kde~1_113:
00005A9E  0D0A 4272 9456          dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
00005AA2  6561 6B20 
00005AA6  506F 696E 
00005AAA  74        
00005AAB  2041 6464 9457          dc.b      32,65,100,100,114,101,115,115,58,32,0
00005AAF  7265 7373 
00005AB3  3A20 00   
                    9458   @m68kde~1_114:
00005AB6  0D0A 4572 9459          dc.b      13,10,69,114,114,111,114,32,58,32,66,114,101
00005ABA  726F 7220 
00005ABE  3A20 4272 
00005AC2  65        
00005AC3  616B 2050 9460          dc.b      97,107,32,80,111,105,110,116,115,32,67,65,78
00005AC7  6F69 6E74 
00005ACB  7320 4341 
00005ACF  4E        
00005AD0  4E4F 5420 9461          dc.b      78,79,84,32,98,101,32,115,101,116,32,97,116
00005AD4  6265 2073 
00005AD8  6574 2061 
00005ADC  74        
00005ADD  204F 4444 9462          dc.b      32,79,68,68,32,97,100,100,114,101,115,115,101
00005AE1  2061 6464 
00005AE5  7265 7373 
00005AE9  65        
00005AEA  7300      9463          dc.b      115,0
                    9464   @m68kde~1_115:
00005AEC  0D0A 4572 9465          dc.b      13,10,69,114,114,111,114,32,58,32,66,114,101
00005AF0  726F 7220 
00005AF4  3A20 4272 
00005AF8  65        
00005AF9  616B 2050 9466          dc.b      97,107,32,80,111,105,110,116,115,32,67,65,78
00005AFD  6F69 6E74 
00005B01  7320 4341 
00005B05  4E        
00005B06  4E4F 5420 9467          dc.b      78,79,84,32,98,101,32,115,101,116,32,102,111
00005B0A  6265 2073 
00005B0E  6574 2066 
00005B12  6F        
00005B13  7220 524F 9468          dc.b      114,32,82,79,77,32,105,110,32,82,97,110,103
00005B17  4D20 696E 
00005B1B  2052 616E 
00005B1F  67        
00005B20  6520 3A20 9469          dc.b      101,32,58,32,91,36,48,45,36,48,48,48,48,55,70
00005B24  5B24 302D 
00005B28  2430 3030 
00005B2C  3037 46   
00005B2F  4646 5D00 9470          dc.b      70,70,93,0
                    9471   @m68kde~1_116:
00005B34  0D0A 4572 9472          dc.b      13,10,69,114,114,111,114,58,32,66,114,101,97
00005B38  726F 723A 
00005B3C  2042 7265 
00005B40  61        
00005B41  6B20 506F 9473          dc.b      107,32,80,111,105,110,116,32,65,108,114,101
00005B45  696E 7420 
00005B49  416C 7265 
00005B4D  6164 7920 9474          dc.b      97,100,121,32,69,120,105,115,116,115,32,97,116
00005B51  4578 6973 
00005B55  7473 2061 
00005B59  74        
00005B5A  2041 6464 9475          dc.b      32,65,100,100,114,101,115,115,32,58,32,37,48
00005B5E  7265 7373 
00005B62  203A 2025 
00005B66  30        
00005B67  3878 0D0A 9476          dc.b      56,120,13,10,0
00005B6B  00        
                    9477   @m68kde~1_117:
00005B6C  0D0A 4272 9478          dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
00005B70  6561 6B20 
00005B74  506F 696E 
00005B78  74        
00005B79  2053 6574 9479          dc.b      32,83,101,116,32,97,116,32,65,100,100,114,101
00005B7D  2061 7420 
00005B81  4164 6472 
00005B85  65        
00005B86  7373 3A20 9480          dc.b      115,115,58,32,91,36,37,48,56,120,93,0
00005B8A  5B24 2530 
00005B8E  3878 5D00 
                    9481   @m68kde~1_118:
00005B92  0D0A 4E6F 9482          dc.b      13,10,78,111,32,70,82,69,69,32,87,97,116,99
00005B96  2046 5245 
00005B9A  4520 5761 
00005B9E  7463      
00005BA0  6820 506F 9483          dc.b      104,32,80,111,105,110,116,115,46,46,46,46,46
00005BA4  696E 7473 
00005BA8  2E2E 2E2E 
00005BAC  2E        
00005BAD  00        9484          dc.b      0
                    9485   @m68kde~1_119:
00005BAE  0D0A 5761 9486          dc.b      13,10,87,97,116,99,104,32,80,111,105,110,116
00005BB2  7463 6820 
00005BB6  506F 696E 
00005BBA  74        
00005BBB  2041 6464 9487          dc.b      32,65,100,100,114,101,115,115,58,32,0
00005BBF  7265 7373 
00005BC3  3A20 00   
                    9488   @m68kde~1_120:
00005BC6  0D0A 4572 9489          dc.b      13,10,69,114,114,111,114,58,32,87,97,116,99
00005BCA  726F 723A 
00005BCE  2057 6174 
00005BD2  63        
00005BD3  6820 506F 9490          dc.b      104,32,80,111,105,110,116,32,65,108,114,101
00005BD7  696E 7420 
00005BDB  416C 7265 
00005BDF  6164 7920 9491          dc.b      97,100,121,32,83,101,116,32,97,116,32,65,100
00005BE3  5365 7420 
00005BE7  6174 2041 
00005BEB  64        
00005BEC  6472 6573 9492          dc.b      100,114,101,115,115,32,58,32,37,48,56,120,13
00005BF0  7320 3A20 
00005BF4  2530 3878 
00005BF8  0D        
00005BF9  0A00      9493          dc.b      10,0
                    9494   @m68kde~1_121:
00005BFC  0D0A 5761 9495          dc.b      13,10,87,97,116,99,104,32,80,111,105,110,116
00005C00  7463 6820 
00005C04  506F 696E 
00005C08  74        
00005C09  2053 6574 9496          dc.b      32,83,101,116,32,97,116,32,65,100,100,114,101
00005C0D  2061 7420 
00005C11  4164 6472 
00005C15  65        
00005C16  7373 3A20 9497          dc.b      115,115,58,32,91,36,37,48,56,120,93,0
00005C1A  5B24 2530 
00005C1E  3878 5D00 
                    9498   @m68kde~1_122:
00005C22  0D0A 0D0A 9499          dc.b      13,10,13,10,13,10,13,10,64,66,82,69,65,75,80
00005C26  0D0A 0D0A 
00005C2A  4042 5245 
00005C2E  414B 50   
00005C31  4F49 4E54 9500          dc.b      79,73,78,84,0
00005C35  00        
                    9501   @m68kde~1_123:
00005C36  0D0A 5369 9502          dc.b      13,10,83,105,110,103,108,101,32,83,116,101,112
00005C3A  6E67 6C65 
00005C3E  2053 7465 
00005C42  70        
00005C43  203A 205B 9503          dc.b      32,58,32,91,79,78,93,0
00005C47  4F4E 5D00 
                    9504   @m68kde~1_124:
00005C4C  0D0A 4272 9505          dc.b      13,10,66,114,101,97,107,80,111,105,110,116,115
00005C50  6561 6B50 
00005C54  6F69 6E74 
00005C58  73        
00005C59  203A 205B 9506          dc.b      32,58,32,91,69,110,97,98,108,101,100,93,0
00005C5D  456E 6162 
00005C61  6C65 645D 
00005C65  00        
                    9507   @m68kde~1_125:
00005C66  0D0A 5072 9508          dc.b      13,10,80,114,101,115,115,32,60,69,83,67,62,32
00005C6A  6573 7320 
00005C6E  3C45 5343 
00005C72  3E20      
00005C74  746F 2052 9509          dc.b      116,111,32,82,101,115,117,109,101,32,85,115
00005C78  6573 756D 
00005C7C  6520 5573 
00005C80  6572 2050 9510          dc.b      101,114,32,80,114,111,103,114,97,109,13,10,0
00005C84  726F 6772 
00005C88  616D 0D0A 
00005C8C  00        
                    9511   @m68kde~1_126:
00005C8E  0D0A 556E 9512          dc.b      13,10,85,110,107,110,111,119,110,32,67,111,109
00005C92  6B6E 6F77 
00005C96  6E20 436F 
00005C9A  6D        
00005C9B  6D61 6E64 9513          dc.b      109,97,110,100,46,46,46,46,46,13,10,0
00005C9F  2E2E 2E2E 
00005CA3  2E0D 0A00 
                    9514   @m68kde~1_127:
00005CA8  0D0A 5072 9515          dc.b      13,10,80,114,111,103,114,97,109,32,69,110,100
00005CAC  6F67 7261 
00005CB0  6D20 456E 
00005CB4  64        
00005CB5  6564 2028 9516          dc.b      101,100,32,40,84,82,65,80,32,35,49,53,41,46
00005CB9  5452 4150 
00005CBD  2023 3135 
00005CC1  292E      
00005CC3  2E2E 2E00 9517          dc.b      46,46,46,0
                    9518   @m68kde~1_128:
00005CC8  0D0A 4B69 9519          dc.b      13,10,75,105,108,108,32,65,108,108,32,66,114
00005CCC  6C6C 2041 
00005CD0  6C6C 2042 
00005CD4  72        
00005CD5  6561 6B20 9520          dc.b      101,97,107,32,80,111,105,110,116,115,46,46,46
00005CD9  506F 696E 
00005CDD  7473 2E2E 
00005CE1  2E        
00005CE2  2879 2F6E 9521          dc.b      40,121,47,110,41,63,0
00005CE6  293F 00   
                    9522   @m68kde~1_129:
00005CEA  0D0A 4B69 9523          dc.b      13,10,75,105,108,108,32,65,108,108,32,87,97
00005CEE  6C6C 2041 
00005CF2  6C6C 2057 
00005CF6  61        
00005CF7  7463 6820 9524          dc.b      116,99,104,32,80,111,105,110,116,115,46,46,46
00005CFB  506F 696E 
00005CFF  7473 2E2E 
00005D03  2E        
00005D04  2879 2F6E 9525          dc.b      40,121,47,110,41,63,0
00005D08  293F 00   
                    9526   @m68kde~1_130:
00005D0C  0D0A 2D2D 9527          dc.b      13,10,45,45,45,45,45,45,45,45,45,45,45,45,45
00005D10  2D2D 2D2D 
00005D14  2D2D 2D2D 
00005D18  2D2D 2D   
00005D1B  2D2D 2D2D 9528          dc.b      45,45,45,45,45,45,45,45,45,45,45,45,45,45,45
00005D1F  2D2D 2D2D 
00005D23  2D2D 2D2D 
00005D27  2D2D 2D   
00005D2A  2D2D 2D2D 9529          dc.b      45,45,45,45,45,45,45,45,45,45,45,45,45,45,45
00005D2E  2D2D 2D2D 
00005D32  2D2D 2D2D 
00005D36  2D2D 2D   
00005D39  2D2D 2D2D 9530          dc.b      45,45,45,45,45,45,45,45,45,45,45,45,45,45,45
00005D3D  2D2D 2D2D 
00005D41  2D2D 2D2D 
00005D45  2D2D 2D   
00005D48  2D2D 2D2D 9531          dc.b      45,45,45,45,45,45,0
00005D4C  2D2D 00   
                    9532   @m68kde~1_131:
00005D50  0D0A 2020 9533          dc.b      13,10,32,32,68,101,98,117,103,103,101,114,32
00005D54  4465 6275 
00005D58  6767 6572 
00005D5C  20        
00005D5D  436F 6D6D 9534          dc.b      67,111,109,109,97,110,100,32,83,117,109,109
00005D61  616E 6420 
00005D65  5375 6D6D 
00005D69  6172 7900 9535          dc.b      97,114,121,0
                    9536   @m68kde~1_132:
00005D6E  0D0A 2020 9537          dc.b      13,10,32,32,46,40,114,101,103,41,32,32,32,32
00005D72  2E28 7265 
00005D76  6729 2020 
00005D7A  2020      
00005D7C  2020 202D 9538          dc.b      32,32,32,45,32,67,104,97,110,103,101,32,82,101
00005D80  2043 6861 
00005D84  6E67 6520 
00005D88  5265      
00005D8A  6769 7374 9539          dc.b      103,105,115,116,101,114,115,58,32,101,46,103
00005D8E  6572 733A 
00005D92  2065 2E67 
00005D96  2041 302D 9540          dc.b      32,65,48,45,65,55,44,68,48,45,68,55,44,80,67
00005D9A  4137 2C44 
00005D9E  302D 4437 
00005DA2  2C50 43   
00005DA5  2C53 5350 9541          dc.b      44,83,83,80,44,85,83,80,44,83,82,0
00005DA9  2C55 5350 
00005DAD  2C53 5200 
                    9542   @m68kde~1_133:
00005DB2  0D0A 2020 9543          dc.b      13,10,32,32,66,68,47,66,83,47,66,67,47,66,75
00005DB6  4244 2F42 
00005DBA  532F 4243 
00005DBE  2F42 4B   
00005DC1  2020 2D20 9544          dc.b      32,32,45,32,66,114,101,97,107,32,80,111,105
00005DC5  4272 6561 
00005DC9  6B20 506F 
00005DCD  69        
00005DCE  6E74 3A20 9545          dc.b      110,116,58,32,68,105,115,112,108,97,121,47,83
00005DD2  4469 7370 
00005DD6  6C61 792F 
00005DDA  53        
00005DDB  6574 2F43 9546          dc.b      101,116,47,67,108,101,97,114,47,75,105,108,108
00005DDF  6C65 6172 
00005DE3  2F4B 696C 
00005DE7  6C        
00005DE8  00        9547          dc.b      0
                    9548   @m68kde~1_134:
00005DEA  0D0A 2020 9549          dc.b      13,10,32,32,67,32,32,32,32,32,32,32,32,32,32
00005DEE  4320 2020 
00005DF2  2020 2020 
00005DF6  2020 20   
00005DF9  2020 2D20 9550          dc.b      32,32,45,32,67,111,112,121,32,80,114,111,103
00005DFD  436F 7079 
00005E01  2050 726F 
00005E05  67        
00005E06  7261 6D20 9551          dc.b      114,97,109,32,102,114,111,109,32,70,108,97,115
00005E0A  6672 6F6D 
00005E0E  2046 6C61 
00005E12  73        
00005E13  6820 746F 9552          dc.b      104,32,116,111,32,77,97,105,110,32,77,101,109
00005E17  204D 6169 
00005E1B  6E20 4D65 
00005E1F  6D        
00005E20  6F72 7900 9553          dc.b      111,114,121,0
                    9554   @m68kde~1_135:
00005E24  0D0A 2020 9555          dc.b      13,10,32,32,68,32,32,32,32,32,32,32,32,32,32
00005E28  4420 2020 
00005E2C  2020 2020 
00005E30  2020 20   
00005E33  2020 2D20 9556          dc.b      32,32,45,32,68,117,109,112,32,77,101,109,111
00005E37  4475 6D70 
00005E3B  204D 656D 
00005E3F  6F        
00005E40  7279 2043 9557          dc.b      114,121,32,67,111,110,116,101,110,116,115,32
00005E44  6F6E 7465 
00005E48  6E74 7320 
00005E4C  746F 2053 9558          dc.b      116,111,32,83,99,114,101,101,110,0
00005E50  6372 6565 
00005E54  6E00      
                    9559   @m68kde~1_136:
00005E56  0D0A 2020 9560          dc.b      13,10,32,32,69,32,32,32,32,32,32,32,32,32,32
00005E5A  4520 2020 
00005E5E  2020 2020 
00005E62  2020 20   
00005E65  2020 2D20 9561          dc.b      32,32,45,32,69,110,116,101,114,32,83,116,114
00005E69  456E 7465 
00005E6D  7220 5374 
00005E71  72        
00005E72  696E 6720 9562          dc.b      105,110,103,32,105,110,116,111,32,77,101,109
00005E76  696E 746F 
00005E7A  204D 656D 
00005E7E  6F72 7900 9563          dc.b      111,114,121,0
                    9564   @m68kde~1_137:
00005E82  0D0A 2020 9565          dc.b      13,10,32,32,70,32,32,32,32,32,32,32,32,32,32
00005E86  4620 2020 
00005E8A  2020 2020 
00005E8E  2020 20   
00005E91  2020 2D20 9566          dc.b      32,32,45,32,70,105,108,108,32,77,101,109,111
00005E95  4669 6C6C 
00005E99  204D 656D 
00005E9D  6F        
00005E9E  7279 2077 9567          dc.b      114,121,32,119,105,116,104,32,68,97,116,97,0
00005EA2  6974 6820 
00005EA6  4461 7461 
00005EAA  00        
                    9568   @m68kde~1_138:
00005EAC  0D0A 2020 9569          dc.b      13,10,32,32,71,32,32,32,32,32,32,32,32,32,32
00005EB0  4720 2020 
00005EB4  2020 2020 
00005EB8  2020 20   
00005EBB  2020 2D20 9570          dc.b      32,32,45,32,71,111,32,80,114,111,103,114,97
00005EBF  476F 2050 
00005EC3  726F 6772 
00005EC7  61        
00005EC8  6D20 5374 9571          dc.b      109,32,83,116,97,114,116,105,110,103,32,97,116
00005ECC  6172 7469 
00005ED0  6E67 2061 
00005ED4  74        
00005ED5  2041 6464 9572          dc.b      32,65,100,100,114,101,115,115,58,32,36,37,48
00005ED9  7265 7373 
00005EDD  3A20 2425 
00005EE1  30        
00005EE2  3858 00   9573          dc.b      56,88,0
                    9574   @m68kde~1_139:
00005EE6  0D0A 2020 9575          dc.b      13,10,32,32,76,32,32,32,32,32,32,32,32,32,32
00005EEA  4C20 2020 
00005EEE  2020 2020 
00005EF2  2020 20   
00005EF5  2020 2D20 9576          dc.b      32,32,45,32,76,111,97,100,32,80,114,111,103
00005EF9  4C6F 6164 
00005EFD  2050 726F 
00005F01  67        
00005F02  7261 6D20 9577          dc.b      114,97,109,32,40,46,72,69,88,32,102,105,108
00005F06  282E 4845 
00005F0A  5820 6669 
00005F0E  6C        
00005F0F  6529 2066 9578          dc.b      101,41,32,102,114,111,109,32,76,97,112,116,111
00005F13  726F 6D20 
00005F17  4C61 7074 
00005F1B  6F        
00005F1C  7000      9579          dc.b      112,0
                    9580   @m68kde~1_140:
00005F1E  0D0A 2020 9581          dc.b      13,10,32,32,77,32,32,32,32,32,32,32,32,32,32
00005F22  4D20 2020 
00005F26  2020 2020 
00005F2A  2020 20   
00005F2D  2020 2D20 9582          dc.b      32,32,45,32,77,101,109,111,114,121,32,69,120
00005F31  4D65 6D6F 
00005F35  7279 2045 
00005F39  78        
00005F3A  616D 696E 9583          dc.b      97,109,105,110,101,32,97,110,100,32,67,104,97
00005F3E  6520 616E 
00005F42  6420 4368 
00005F46  61        
00005F47  6E67 6500 9584          dc.b      110,103,101,0
                    9585   @m68kde~1_141:
00005F4C  0D0A 2020 9586          dc.b      13,10,32,32,80,32,32,32,32,32,32,32,32,32,32
00005F50  5020 2020 
00005F54  2020 2020 
00005F58  2020 20   
00005F5B  2020 2D20 9587          dc.b      32,32,45,32,80,114,111,103,114,97,109,32,70
00005F5F  5072 6F67 
00005F63  7261 6D20 
00005F67  46        
00005F68  6C61 7368 9588          dc.b      108,97,115,104,32,77,101,109,111,114,121,32
00005F6C  204D 656D 
00005F70  6F72 7920 
00005F74  7769 7468 9589          dc.b      119,105,116,104,32,85,115,101,114,32,80,114
00005F78  2055 7365 
00005F7C  7220 5072 
00005F80  6F67 7261 9590          dc.b      111,103,114,97,109,0
00005F84  6D00      
                    9591   @m68kde~1_142:
00005F86  0D0A 2020 9592          dc.b      13,10,32,32,82,32,32,32,32,32,32,32,32,32,32
00005F8A  5220 2020 
00005F8E  2020 2020 
00005F92  2020 20   
00005F95  2020 2D20 9593          dc.b      32,32,45,32,68,105,115,112,108,97,121,32,54
00005F99  4469 7370 
00005F9D  6C61 7920 
00005FA1  36        
00005FA2  3830 3030 9594          dc.b      56,48,48,48,32,82,101,103,105,115,116,101,114
00005FA6  2052 6567 
00005FAA  6973 7465 
00005FAE  72        
00005FAF  7300      9595          dc.b      115,0
                    9596   @m68kde~1_143:
00005FB2  0D0A 2020 9597          dc.b      13,10,32,32,83,32,32,32,32,32,32,32,32,32,32
00005FB6  5320 2020 
00005FBA  2020 2020 
00005FBE  2020 20   
00005FC1  2020 2D20 9598          dc.b      32,32,45,32,84,111,103,103,108,101,32,79,78
00005FC5  546F 6767 
00005FC9  6C65 204F 
00005FCD  4E        
00005FCE  2F4F 4646 9599          dc.b      47,79,70,70,32,83,105,110,103,108,101,32,83
00005FD2  2053 696E 
00005FD6  676C 6520 
00005FDA  53        
00005FDB  7465 7020 9600          dc.b      116,101,112,32,77,111,100,101,0
00005FDF  4D6F 6465 
00005FE3  00        
                    9601   @m68kde~1_144:
00005FE4  0D0A 2020 9602          dc.b      13,10,32,32,84,77,32,32,32,32,32,32,32,32,32
00005FE8  544D 2020 
00005FEC  2020 2020 
00005FF0  2020 20   
00005FF3  2020 2D20 9603          dc.b      32,32,45,32,84,101,115,116,32,77,101,109,111
00005FF7  5465 7374 
00005FFB  204D 656D 
00005FFF  6F        
00006000  7279 00   9604          dc.b      114,121,0
                    9605   @m68kde~1_145:
00006004  0D0A 2020 9606          dc.b      13,10,32,32,84,83,32,32,32,32,32,32,32,32,32
00006008  5453 2020 
0000600C  2020 2020 
00006010  2020 20   
00006013  2020 2D20 9607          dc.b      32,32,45,32,84,101,115,116,32,83,119,105,116
00006017  5465 7374 
0000601B  2053 7769 
0000601F  74        
00006020  6368 6573 9608          dc.b      99,104,101,115,58,32,83,87,55,45,48,0
00006024  3A20 5357 
00006028  372D 3000 
                    9609   @m68kde~1_146:
0000602C  0D0A 2020 9610          dc.b      13,10,32,32,84,68,32,32,32,32,32,32,32,32,32
00006030  5444 2020 
00006034  2020 2020 
00006038  2020 20   
0000603B  2020 2D20 9611          dc.b      32,32,45,32,84,101,115,116,32,68,105,115,112
0000603F  5465 7374 
00006043  2044 6973 
00006047  70        
00006048  6C61 7973 9612          dc.b      108,97,121,115,58,32,76,69,68,115,32,97,110
0000604C  3A20 4C45 
00006050  4473 2061 
00006054  6E        
00006055  6420 372D 9613          dc.b      100,32,55,45,83,101,103,109,101,110,116,0
00006059  5365 676D 
0000605D  656E 7400 
                    9614   @m68kde~1_147:
00006062  0D0A 2020 9615          dc.b      13,10,32,32,87,68,47,87,83,47,87,67,47,87,75
00006066  5744 2F57 
0000606A  532F 5743 
0000606E  2F57 4B   
00006071  2020 2D20 9616          dc.b      32,32,45,32,87,97,116,99,104,32,80,111,105,110
00006075  5761 7463 
00006079  6820 506F 
0000607D  696E      
0000607F  743A 2044 9617          dc.b      116,58,32,68,105,115,112,108,97,121,47,83,101
00006083  6973 706C 
00006087  6179 2F53 
0000608B  65        
0000608C  742F 436C 9618          dc.b      116,47,67,108,101,97,114,47,75,105,108,108,0
00006090  6561 722F 
00006094  4B69 6C6C 
00006098  00        
                    9619   @m68kde~1_148:
0000609A  0D0A 2300 9620          dc.b      13,10,35,0
                    9621   @m68kde~1_149:
0000609E  0D0A 5072 9622          dc.b      13,10,80,114,111,103,114,97,109,32,82,117,110
000060A2  6F67 7261 
000060A6  6D20 5275 
000060AA  6E        
000060AB  6E69 6E67 9623          dc.b      110,105,110,103,46,46,46,46,46,0
000060AF  2E2E 2E2E 
000060B3  2E00      
                    9624   @m68kde~1_150:
000060B6  0D0A 5072 9625          dc.b      13,10,80,114,101,115,115,32,60,82,69,83,69,84
000060BA  6573 7320 
000060BE  3C52 4553 
000060C2  4554      
000060C4  3E20 6275 9626          dc.b      62,32,98,117,116,116,111,110,32,60,75,101,121
000060C8  7474 6F6E 
000060CC  203C 4B65 
000060D0  79        
000060D1  303E 206F 9627          dc.b      48,62,32,111,110,32,68,69,49,32,116,111,32,115
000060D5  6E20 4445 
000060D9  3120 746F 
000060DD  2073      
000060DF  746F 7000 9628          dc.b      116,111,112,0
                    9629   @m68kde~1_151:
000060E4  0D0A 4572 9630          dc.b      13,10,69,114,114,111,114,58,32,80,114,101,115
000060E8  726F 723A 
000060EC  2050 7265 
000060F0  73        
000060F1  7320 2747 9631          dc.b      115,32,39,71,39,32,102,105,114,115,116,32,116
000060F5  2720 6669 
000060F9  7273 7420 
000060FD  74        
000060FE  6F20 7374 9632          dc.b      111,32,115,116,97,114,116,32,112,114,111,103
00006102  6172 7420 
00006106  7072 6F67 
0000610A  7261 6D00 9633          dc.b      114,97,109,0
                    9634   @m68kde~1_152:
0000610E  0D0A 5369 9635          dc.b      13,10,83,105,110,103,108,101,32,83,116,101,112
00006112  6E67 6C65 
00006116  2053 7465 
0000611A  70        
0000611B  2020 3A5B 9636          dc.b      32,32,58,91,79,78,93,0
0000611F  4F4E 5D00 
                    9637   @m68kde~1_153:
00006124  0D0A 5072 9638          dc.b      13,10,80,114,101,115,115,32,39,71,39,32,116
00006128  6573 7320 
0000612C  2747 2720 
00006130  74        
00006131  6F20 5472 9639          dc.b      111,32,84,114,97,99,101,32,80,114,111,103,114
00006135  6163 6520 
00006139  5072 6F67 
0000613D  72        
0000613E  616D 2066 9640          dc.b      97,109,32,102,114,111,109,32,97,100,100,114
00006142  726F 6D20 
00006146  6164 6472 
0000614A  6573 7320 9641          dc.b      101,115,115,32,36,37,88,46,46,46,46,46,0
0000614E  2425 582E 
00006152  2E2E 2E2E 
00006156  00        
                    9642   @m68kde~1_154:
00006158  0D0A 5075 9643          dc.b      13,10,80,117,115,104,32,60,82,69,83,69,84,32
0000615C  7368 203C 
00006160  5245 5345 
00006164  5420      
00006166  4275 7474 9644          dc.b      66,117,116,116,111,110,62,32,116,111,32,83,116
0000616A  6F6E 3E20 
0000616E  746F 2053 
00006172  74        
00006173  6F70 2E2E 9645          dc.b      111,112,46,46,46,46,46,0
00006177  2E2E 2E00 
                    9646   @m68kde~1_155:
0000617C  0D0A 5369 9647          dc.b      13,10,83,105,110,103,108,101,32,83,116,101,112
00006180  6E67 6C65 
00006184  2053 7465 
00006188  70        
00006189  203A 205B 9648          dc.b      32,58,32,91,79,70,70,93,0
0000618D  4F46 465D 
00006191  00        
                    9649   @m68kde~1_156:
00006192  0D0A 4272 9650          dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
00006196  6561 6B20 
0000619A  506F 696E 
0000619E  74        
0000619F  7320 3A5B 9651          dc.b      115,32,58,91,69,110,97,98,108,101,100,93,0
000061A3  456E 6162 
000061A7  6C65 645D 
000061AB  00        
                    9652   @m68kde~1_157:
000061AC  0D0A 5072 9653          dc.b      13,10,80,114,101,115,115,32,60,69,83,67,62,32
000061B0  6573 7320 
000061B4  3C45 5343 
000061B8  3E20      
000061BA  746F 2052 9654          dc.b      116,111,32,82,101,115,117,109,101,32,85,115
000061BE  6573 756D 
000061C2  6520 5573 
000061C6  6572 2050 9655          dc.b      101,114,32,80,114,111,103,114,97,109,46,46,46
000061CA  726F 6772 
000061CE  616D 2E2E 
000061D2  2E        
000061D3  2E2E 00   9656          dc.b      46,46,0
                    9657   @m68kde~1_158:
000061D6  0D0A 5369 9658          dc.b      13,10,83,105,110,103,108,101,32,83,116,101,112
000061DA  6E67 6C65 
000061DE  2053 7465 
000061E2  70        
000061E3  2020 3A5B 9659          dc.b      32,32,58,91,79,70,70,93,0
000061E7  4F46 465D 
000061EB  00        
                    9660   @m68kde~1_159:
000061EC  0D0A 0D0A 9661          dc.b      13,10,13,10,80,114,111,103,114,97,109,32,65
000061F0  5072 6F67 
000061F4  7261 6D20 
000061F8  41        
000061F9  424F 5254 9662          dc.b      66,79,82,84,32,33,33,33,33,33,33,13,10,0
000061FD  2021 2121 
00006201  2121 210D 
00006205  0A00      
                    9663   @m68kde~1_160:
00006208  2573 0D0A 9664          dc.b      37,115,13,10,0
0000620C  00        
                    9665   @m68kde~1_161:
0000620E  0D0A 0D0A 9666          dc.b      13,10,13,10,80,114,111,103,114,97,109,32,65
00006212  5072 6F67 
00006216  7261 6D20 
0000621A  41        
0000621B  424F 5254 9667          dc.b      66,79,82,84,32,33,33,33,33,33,0
0000621F  2021 2121 
00006223  2121 00   
                    9668   @m68kde~1_162:
00006226  0D0A 556E 9669          dc.b      13,10,85,110,104,97,110,100,108,101,100,32,73
0000622A  6861 6E64 
0000622E  6C65 6420 
00006232  49        
00006233  6E74 6572 9670          dc.b      110,116,101,114,114,117,112,116,58,32,73,82
00006237  7275 7074 
0000623B  3A20 4952 
0000623F  5125 6420 9671          dc.b      81,37,100,32,33,33,33,33,33,0
00006243  2121 2121 
00006247  2100      
                    9672   @m68kde~1_163:
0000624A  4144 4452 9673          dc.b      65,68,68,82,69,83,83,32,69,82,82,79,82,58,32
0000624E  4553 5320 
00006252  4552 524F 
00006256  523A 20   
00006259  3136 206F 9674          dc.b      49,54,32,111,114,32,51,50,32,66,105,116,32,84
0000625D  7220 3332 
00006261  2042 6974 
00006265  2054      
00006267  7261 6E73 9675          dc.b      114,97,110,115,102,101,114,32,116,111,47,102
0000626B  6665 7220 
0000626F  746F 2F66 
00006273  726F 6D20 9676          dc.b      114,111,109,32,97,110,32,79,68,68,32,65,100
00006277  616E 204F 
0000627B  4444 2041 
0000627F  64        
00006280  6472 6573 9677          dc.b      100,114,101,115,115,46,46,46,46,0
00006284  732E 2E2E 
00006288  2E00      
                    9678   @m68kde~1_164:
0000628A  556E 6861 9679          dc.b      85,110,104,97,110,100,108,101,100,32,84,114
0000628E  6E64 6C65 
00006292  6420 5472 
00006296  6170 2021 9680          dc.b      97,112,32,33,33,33,33,33,0
0000629A  2121 2121 
0000629E  00        
                    9681   @m68kde~1_165:
000062A0  4255 5320 9682          dc.b      66,85,83,32,69,114,114,111,114,33,0
000062A4  4572 726F 
000062A8  7221 00   
                    9683   @m68kde~1_166:
000062AC  4144 4452 9684          dc.b      65,68,68,82,69,83,83,32,69,114,114,111,114,33
000062B0  4553 5320 
000062B4  4572 726F 
000062B8  7221      
000062BA  00        9685          dc.b      0
                    9686   @m68kde~1_167:
000062BC  494C 4C45 9687          dc.b      73,76,76,69,71,65,76,32,73,78,83,84,82,85,67
000062C0  4741 4C20 
000062C4  494E 5354 
000062C8  5255 43   
000062CB  5449 4F4E 9688          dc.b      84,73,79,78,0
000062CF  00        
                    9689   @m68kde~1_168:
000062D0  4449 5649 9690          dc.b      68,73,86,73,68,69,32,66,89,32,90,69,82,79,0
000062D4  4445 2042 
000062D8  5920 5A45 
000062DC  524F 00   
                    9691   @m68kde~1_169:
000062E0  2743 484B 9692          dc.b      39,67,72,75,39,32,73,78,83,84,82,85,67,84,73
000062E4  2720 494E 
000062E8  5354 5255 
000062EC  4354 49   
000062EF  4F4E 00   9693          dc.b      79,78,0
                    9694   @m68kde~1_170:
000062F2  5452 4150 9695          dc.b      84,82,65,80,86,32,73,78,83,84,82,85,67,84,73
000062F6  5620 494E 
000062FA  5354 5255 
000062FE  4354 49   
00006301  4F4E 00   9696          dc.b      79,78,0
                    9697   @m68kde~1_171:
00006304  5052 4956 9698          dc.b      80,82,73,86,73,76,69,71,69,32,86,73,79,76,65
00006308  494C 4547 
0000630C  4520 5649 
00006310  4F4C 41   
00006313  5449 4F4E 9699          dc.b      84,73,79,78,0
00006317  00        
                    9700   @m68kde~1_172:
00006318  554E 494E 9701          dc.b      85,78,73,78,73,84,73,65,76,73,83,69,68,32,73
0000631C  4954 4941 
00006320  4C49 5345 
00006324  4420 49   
00006327  5251 00   9702          dc.b      82,81,0
                    9703   @m68kde~1_173:
0000632A  5350 5552 9704          dc.b      83,80,85,82,73,79,85,83,32,73,82,81,0
0000632E  494F 5553 
00006332  2049 5251 
00006336  00        
                    9705   @m68kde~1_174:
00006338  0D0A 5374 9706          dc.b      13,10,83,116,97,114,116,32,65,100,100,114,101
0000633C  6172 7420 
00006340  4164 6472 
00006344  65        
00006345  7373 2069 9707          dc.b      115,115,32,105,110,32,77,101,109,111,114,121
00006349  6E20 4D65 
0000634D  6D6F 7279 
00006351  3A20 00   9708          dc.b      58,32,0
                    9709   @m68kde~1_175:
00006354  0D0A 456E 9710          dc.b      13,10,69,110,116,101,114,32,83,116,114,105,110
00006358  7465 7220 
0000635C  5374 7269 
00006360  6E        
00006361  6720 2845 9711          dc.b      103,32,40,69,83,67,32,116,111,32,101,110,100
00006365  5343 2074 
00006369  6F20 656E 
0000636D  64        
0000636E  2920 3A00 9712          dc.b      41,32,58,0
                    9713   @m68kde~1_176:
00006372  0A45 6E74 9714          dc.b      10,69,110,116,101,114,32,119,104,97,116,32,115
00006376  6572 2077 
0000637A  6861 7420 
0000637E  73        
0000637F  697A 6520 9715          dc.b      105,122,101,32,111,102,32,109,101,109,111,114
00006383  6F66 206D 
00006387  656D 6F72 
0000638B  7920 796F 9716          dc.b      121,32,121,111,117,32,119,97,110,116,32,116
0000638F  7520 7761 
00006393  6E74 2074 
00006397  6F20 7265 9717          dc.b      111,32,114,101,97,100,47,119,114,105,116,101
0000639B  6164 2F77 
0000639F  7269 7465 
000063A3  0A20 4279 9718          dc.b      10,32,66,121,116,101,32,61,32,48,10,32,87,111
000063A7  7465 203D 
000063AB  2030 0A20 
000063AF  576F      
000063B1  7264 203D 9719          dc.b      114,100,32,61,32,49,10,32,76,111,110,103,32
000063B5  2031 0A20 
000063B9  4C6F 6E67 
000063BD  20        
000063BE  576F 7264 9720          dc.b      87,111,114,100,32,61,32,50,10,0
000063C2  203D 2032 
000063C6  0A00      
                    9721   @m68kde~1_177:
000063C8  0A45 6E74 9722          dc.b      10,69,110,116,101,114,32,119,104,105,99,104
000063CC  6572 2077 
000063D0  6869 6368 
000063D4  2064 6174 9723          dc.b      32,100,97,116,97,32,112,97,116,116,101,114,110
000063D8  6120 7061 
000063DC  7474 6572 
000063E0  6E        
000063E1  2079 6F75 9724          dc.b      32,121,111,117,32,119,97,110,116,32,116,111
000063E5  2077 616E 
000063E9  7420 746F 
000063ED  2077 7269 9725          dc.b      32,119,114,105,116,101,32,105,110,116,111,32
000063F1  7465 2069 
000063F5  6E74 6F20 
000063F9  6D65 6D6F 9726          dc.b      109,101,109,111,114,121,10,32,48,120,48,48,32
000063FD  7279 0A20 
00006401  3078 3030 
00006405  20        
00006406  3D20 300A 9727          dc.b      61,32,48,10,32,48,120,66,50,32,61,32,49,10,32
0000640A  2030 7842 
0000640E  3220 3D20 
00006412  310A 20   
00006415  3078 4333 9728          dc.b      48,120,67,51,32,61,32,50,10,32,48,120,68,52
00006419  203D 2032 
0000641D  0A20 3078 
00006421  4434      
00006423  203D 2033 9729          dc.b      32,61,32,51,10,0
00006427  0A00      
                    9730   @m68kde~1_178:
0000642A  0A45 6E74 9731          dc.b      10,69,110,116,101,114,32,119,104,105,99,104
0000642E  6572 2077 
00006432  6869 6368 
00006436  2064 6174 9732          dc.b      32,100,97,116,97,32,112,97,116,116,101,114,110
0000643A  6120 7061 
0000643E  7474 6572 
00006442  6E        
00006443  2079 6F75 9733          dc.b      32,121,111,117,32,119,97,110,116,32,116,111
00006447  2077 616E 
0000644B  7420 746F 
0000644F  2077 7269 9734          dc.b      32,119,114,105,116,101,32,105,110,116,111,32
00006453  7465 2069 
00006457  6E74 6F20 
0000645B  6D65 6D6F 9735          dc.b      109,101,109,111,114,121,10,32,48,120,48,48,48
0000645F  7279 0A20 
00006463  3078 3030 
00006467  30        
00006468  3020 3D20 9736          dc.b      48,32,61,32,48,10,32,48,120,49,50,51,52,32,61
0000646C  300A 2030 
00006470  7831 3233 
00006474  3420 3D   
00006477  2031 0A20 9737          dc.b      32,49,10,32,48,120,65,49,66,50,32,61,32,50,10
0000647B  3078 4131 
0000647F  4232 203D 
00006483  2032 0A   
00006486  2030 7843 9738          dc.b      32,48,120,67,51,68,52,32,61,32,51,10,0
0000648A  3344 3420 
0000648E  3D20 330A 
00006492  00        
                    9739   @m68kde~1_179:
00006494  0A45 6E74 9740          dc.b      10,69,110,116,101,114,32,119,104,105,99,104
00006498  6572 2077 
0000649C  6869 6368 
000064A0  2064 6174 9741          dc.b      32,100,97,116,97,32,112,97,116,116,101,114,110
000064A4  6120 7061 
000064A8  7474 6572 
000064AC  6E        
000064AD  2079 6F75 9742          dc.b      32,121,111,117,32,119,97,110,116,32,116,111
000064B1  2077 616E 
000064B5  7420 746F 
000064B9  2077 7269 9743          dc.b      32,119,114,105,116,101,32,105,110,116,111,32
000064BD  7465 2069 
000064C1  6E74 6F20 
000064C5  6D65 6D6F 9744          dc.b      109,101,109,111,114,121,10,32,48,120,48,48,48
000064C9  7279 0A20 
000064CD  3078 3030 
000064D1  30        
000064D2  305F 3030 9745          dc.b      48,95,48,48,48,48,32,61,32,48,10,32,48,120,65
000064D6  3030 203D 
000064DA  2030 0A20 
000064DE  3078 41   
000064E1  4142 425F 9746          dc.b      65,66,66,95,67,67,68,68,32,61,32,49,10,32,48
000064E5  4343 4444 
000064E9  203D 2031 
000064ED  0A20 30   
000064F0  7831 3132 9747          dc.b      120,49,49,50,50,95,51,51,52,52,32,61,32,50,10
000064F4  325F 3333 
000064F8  3434 203D 
000064FC  2032 0A   
000064FF  2030 7837 9748          dc.b      32,48,120,55,54,53,52,95,51,50,49,48,32,61,32
00006503  3635 345F 
00006507  3332 3130 
0000650B  203D 20   
0000650E  330A 00   9749          dc.b      51,10,0
                    9750   @m68kde~1_180:
00006512  0A50 726F 9751          dc.b      10,80,114,111,118,105,100,101,32,83,116,97,114
00006516  7669 6465 
0000651A  2053 7461 
0000651E  72        
0000651F  7420 4164 9752          dc.b      116,32,65,100,100,114,101,115,115,32,105,110
00006523  6472 6573 
00006527  7320 696E 
0000652B  2068 6578 9753          dc.b      32,104,101,120,32,40,100,111,32,110,111,116
0000652F  2028 646F 
00006533  206E 6F74 
00006537  2075 7365 9754          dc.b      32,117,115,101,32,48,120,32,112,114,101,102
0000653B  2030 7820 
0000653F  7072 6566 
00006543  6978 290A 9755          dc.b      105,120,41,10,48,120,0
00006547  3078 00   
                    9756   @m68kde~1_181:
0000654A  0A50 726F 9757          dc.b      10,80,114,111,118,105,100,101,32,69,110,100
0000654E  7669 6465 
00006552  2045 6E64 
00006556  2041 6464 9758          dc.b      32,65,100,100,114,101,115,115,32,105,110,32
0000655A  7265 7373 
0000655E  2069 6E20 
00006562  6865 7820 9759          dc.b      104,101,120,32,40,100,111,32,110,111,116,32
00006566  2864 6F20 
0000656A  6E6F 7420 
0000656E  7573 6520 9760          dc.b      117,115,101,32,48,120,32,112,114,101,102,105
00006572  3078 2070 
00006576  7265 6669 
0000657A  7829 0A30 9761          dc.b      120,41,10,48,120,0
0000657E  7800      
                    9762   @m68kde~1_182:
00006580  0A53 7461 9763          dc.b      10,83,116,97,114,116,32,65,100,100,114,101,115
00006584  7274 2041 
00006588  6464 7265 
0000658C  73        
0000658D  7320 3078 9764          dc.b      115,32,48,120,37,48,56,120,10,0
00006591  2530 3878 
00006595  0A00      
                    9765   @m68kde~1_183:
00006598  0A45 6E64 9766          dc.b      10,69,110,100,32,65,100,100,114,101,115,115
0000659C  2041 6464 
000065A0  7265 7373 
000065A4  3A20 3078 9767          dc.b      58,32,48,120,37,48,56,120,10,0
000065A8  2530 3878 
000065AC  0A00      
                    9768   @m68kde~1_184:
000065AE  4552 524F 9769          dc.b      69,82,82,79,82,46,46,46,32,65,100,100,114,101
000065B2  522E 2E2E 
000065B6  2041 6464 
000065BA  7265      
000065BC  7373 2030 9770          dc.b      115,115,32,48,120,37,120,32,105,115,32,98,101
000065C0  7825 7820 
000065C4  6973 2062 
000065C8  65        
000065C9  796F 6E64 9771          dc.b      121,111,110,100,32,116,104,101,32,109,101,109
000065CD  2074 6865 
000065D1  206D 656D 
000065D5  6F72 7920 9772          dc.b      111,114,121,32,114,97,110,103,101,10,0
000065D9  7261 6E67 
000065DD  650A 00   
                    9773   @m68kde~1_185:
000065E0  4552 524F 9774          dc.b      69,82,82,79,82,46,46,46,32,86,97,108,117,101
000065E4  522E 2E2E 
000065E8  2056 616C 
000065EC  7565      
000065EE  2077 7269 9775          dc.b      32,119,114,105,116,116,101,110,32,116,111,32
000065F2  7474 656E 
000065F6  2074 6F20 
000065FA  6164 6472 9776          dc.b      97,100,100,114,101,115,115,32,48,120,37,120
000065FE  6573 7320 
00006602  3078 2578 
00006606  203D 3D20 9777          dc.b      32,61,61,32,48,120,37,120,46,32,86,97,108,117
0000660A  3078 2578 
0000660E  2E20 5661 
00006612  6C75      
00006614  6520 4578 9778          dc.b      101,32,69,120,112,101,99,116,101,100,58,32,48
00006618  7065 6374 
0000661C  6564 3A20 
00006620  30        
00006621  7825 780A 9779          dc.b      120,37,120,10,0
00006625  00        
                    9780   @m68kde~1_186:
00006626  4164 6472 9781          dc.b      65,100,100,114,101,115,115,58,32,48,120,37,120
0000662A  6573 733A 
0000662E  2030 7825 
00006632  78        
00006633  2056 616C 9782          dc.b      32,86,97,108,117,101,58,32,48,120,37,48,50,88
00006637  7565 3A20 
0000663B  3078 2530 
0000663F  3258      
00006641  0A00      9783          dc.b      10,0
                    9784   @m68kde~1_187:
00006644  4164 6472 9785          dc.b      65,100,100,114,101,115,115,58,32,48,120,37,120
00006648  6573 733A 
0000664C  2030 7825 
00006650  78        
00006651  2056 616C 9786          dc.b      32,86,97,108,117,101,58,32,48,120,37,48,52,88
00006655  7565 3A20 
00006659  3078 2530 
0000665D  3458      
0000665F  0A00      9787          dc.b      10,0
                    9788   @m68kde~1_188:
00006662  4164 6472 9789          dc.b      65,100,100,114,101,115,115,58,32,48,120,37,120
00006666  6573 733A 
0000666A  2030 7825 
0000666E  78        
0000666F  2056 616C 9790          dc.b      32,86,97,108,117,101,58,32,48,120,37,48,56,88
00006673  7565 3A20 
00006677  3078 2530 
0000667B  3858      
0000667D  0A00      9791          dc.b      10,0
                    9792   @m68kde~1_189:
00006680  4445 312D 9793          dc.b      68,69,49,45,54,56,107,32,66,117,103,32,86,49
00006684  3638 6B20 
00006688  4275 6720 
0000668C  5631      
0000668E  2E37 3700 9794          dc.b      46,55,55,0
                    9795   @m68kde~1_190:
00006692  436F 7079 9796          dc.b      67,111,112,121,114,105,103,104,116,32,40,67
00006696  7269 6768 
0000669A  7420 2843 
0000669E  2920 504A 9797          dc.b      41,32,80,74,32,68,97,118,105,101,115,32,50,48
000066A2  2044 6176 
000066A6  6965 7320 
000066AA  3230      
000066AC  3136 00   9798          dc.b      49,54,0
                    9799   @m68kde~1_191:
000066B0  0D0A 5275 9800          dc.b      13,10,82,117,110,110,105,110,103,46,46,46,46
000066B4  6E6E 696E 
000066B8  672E 2E2E 
000066BC  2E        
000066BD  2E00      9801          dc.b      46,0
                    9802   @m68kde~1_192:
000066C0  5275 6E6E 9803          dc.b      82,117,110,110,105,110,103,46,46,46,46,46,0
000066C4  696E 672E 
000066C8  2E2E 2E2E 
000066CC  00        
                    9804   @m68kde~1_193:
000066CE  4279 3A20 9805          dc.b      66,121,58,32,80,74,32,68,97,118,105,101,115
000066D2  504A 2044 
000066D6  6176 6965 
000066DA  73        
000066DB  00        9806          dc.b      0
                    9807   @m68kde~1_194:
000066DC  0D0A 2573 9808          dc.b      13,10,37,115,0
000066E0  00        
                    9809   @m68kde~1_195:
000066E2  0A20 5374 9810          dc.b      10,32,83,116,117,100,101,110,116,32,78,97,109
000066E6  7564 656E 
000066EA  7420 4E61 
000066EE  6D        
000066EF  6573 3A0A 9811          dc.b      101,115,58,10,32,90,97,99,104,97,114,105,97
000066F3  205A 6163 
000066F7  6861 7269 
000066FB  61        
000066FC  6820 4A6F 9812          dc.b      104,32,74,111,115,101,112,104,58,32,52,53,53
00006700  7365 7068 
00006704  3A20 3435 
00006708  35        
00006709  3030 3035 9813          dc.b      48,48,48,53,53,32,10,32,85,109,97,105,114,32
0000670D  3520 0A20 
00006711  556D 6169 
00006715  7220      
00006717  4D61 7A68 9814          dc.b      77,97,122,104,97,114,58,32,50,48,51,51,51,51
0000671B  6172 3A20 
0000671F  3230 3333 
00006723  3333      
00006725  3038 0A00 9815          dc.b      48,56,10,0
                    9816          section   data
0000672A            9817                   align
          0000 672A 9818   DataStart       equ       *
                    9819   
                    9820   *********************************************************************************************************
                    9821   * Data Section for Initialised Data - these will be placed in rom as constants and have to be copied
                    9822   * to ram as part of the CStart routine in this file
                    9823   *********************************************************************************************************
                    9824   
                    9825   @vsscanf_bufx:
0000672A  0B00 0546 9826          dc.l      @vsscanf_buf
                    9827   @vsscanf_1:
0000672E  0A00      9828          dc.b      10,0
                    9829   __ctype:
00006730  0040 4040 9830          dc.b      0,64,64,64,64,64,64,64,64,64,80,80,80,80,80
00006734  4040 4040 
00006738  4040 5050 
0000673C  5050 50   
0000673F  4040 4040 9831          dc.b      64,64,64,64,64,64,64,64,64,64,64,64,64,64,64
00006743  4040 4040 
00006747  4040 4040 
0000674B  4040 40   
0000674E  4040 40D0 9832          dc.b      64,64,64,208,160,160,160,160,160,160,160,160
00006752  A0A0 A0A0 
00006756  A0A0 A0A0 
0000675A  A0A0 A0A0 9833          dc.b      160,160,160,160,160,160,160,140,140,140,140
0000675E  A0A0 A08C 
00006762  8C8C 8C   
00006765  8C8C 8C8C 9834          dc.b      140,140,140,140,140,140,160,160,160,160,160
00006769  8C8C A0A0 
0000676D  A0A0 A0   
00006770  A0A0 8A8A 9835          dc.b      160,160,138,138,138,138,138,138,130,130,130
00006774  8A8A 8A8A 
00006778  8282 82   
0000677B  8282 8282 9836          dc.b      130,130,130,130,130,130,130,130,130,130,130
0000677F  8282 8282 
00006783  8282 82   
00006786  8282 8282 9837          dc.b      130,130,130,130,130,130,160,160,160,160,160
0000678A  8282 A0A0 
0000678E  A0A0 A0   
00006791  A089 8989 9838          dc.b      160,137,137,137,137,137,137,129,129,129,129
00006795  8989 8981 
00006799  8181 81   
0000679C  8181 8181 9839          dc.b      129,129,129,129,129,129,129,129,129,129,129
000067A0  8181 8181 
000067A4  8181 81   
000067A7  8181 8181 9840          dc.b      129,129,129,129,129,160,160,160,160,64,0,0,0
000067AB  81A0 A0A0 
000067AF  A040 0000 
000067B3  00        
000067B4  0000 0000 9841          dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
000067B8  0000 0000 
000067BC  0000 0000 
000067C0  0000 0000 
000067C4  0000 0000 
000067C8  0000      
000067CA  0000 0000 9842          dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
000067CE  0000 0000 
000067D2  0000 0000 
000067D6  0000 0000 
000067DA  0000 0000 
000067DE  0000      
000067E0  0000 0000 9843          dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
000067E4  0000 0000 
000067E8  0000 0000 
000067EC  0000 0000 
000067F0  0000 0000 
000067F4  0000      
000067F6  0000 0000 9844          dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
000067FA  0000 0000 
000067FE  0000 0000 
00006802  0000 0000 
00006806  0000 0000 
0000680A  0000      
0000680C  0000 0000 9845          dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
00006810  0000 0000 
00006814  0000 0000 
00006818  0000 0000 
0000681C  0000 0000 
00006820  0000      
00006822  0000 0000 9846          dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
00006826  0000 0000 
0000682A  0000 0000 
0000682E  0000 00   
                    9847   @itoa_1:
00006832  2D32 3134 9848          dc.b      45,50,49,52,55,52,56,51,54,52,56,0
00006836  3734 3833 
0000683A  3634 3800 
                    9849          section   bss
0000683E            9850                   align
          0000 683E 9851   DataEnd         equ     *                       this label will equate to the address of the last byte of global variable in it
                    9852   
                    9853   *********************************************************************************************************
                    9854   * Section for Uninitialised Data held in ROM as constants
                    9855   *********************************************************************************************************
                    9856   
0B000000            9857                   org     RamVectorTable          Ram based vector table must be stored here otherwise InstallException Handler will not work
          0000 0114 9858   DataLength      equ     DataEnd-DataStart       length of data needed to copy to Ram on bootup
                    9859   
                    9860   
0B000000            9861   bss             org       bss
                    9862   
                    9863   *********************************************************************************************************
                    9864   * Build a ram based vector table for interrupts so we can install our own Exception Handlers in C code at run time
                    9865   * install the exception handler using the C function InstallExceptionHandler()
                    9866   *********************************************************************************************************
                    9867   
                    9868   
                    9869   
0B000000            9870   VInitialSP       ds.l    1      dummy as we can't really install a handler for this
0B000004            9871   VInitialPC       ds.l    1      dummy as we can't reallin install a handler for this
0B000008            9872   VBusError        ds.l    1      storage for address of Bus Error Handler
0B00000C            9873   VAddressError    ds.l    1      storage for address of Address Error Handler
0B000010            9874   VIllegalInstr    ds.l    1      storage for address of Illegal Instruction handler
0B000014            9875   VDividebyZero    ds.l    1      storage for address of divide by zero handler
0B000018            9876   VCheck           ds.l    1      ditto
0B00001C            9877   VTrapV           ds.l    1      ditto
0B000020            9878   VPrivilege       ds.l    1      ditto
0B000024            9879   VTrace           ds.l    1
0B000028            9880   VLine1010emul    ds.l    1
0B00002C            9881   VLine1111emul    ds.l    1
0B000030            9882   VUnassigned1     ds.l    1
0B000034            9883   VUnassigned2     ds.l    1
0B000038            9884   VUnassigned3     ds.l    1
0B00003C            9885   VUninit_IRQ      ds.l    1
0B000040            9886   VUnassigned4     ds.l    1
0B000044            9887   VUnassigned5     ds.l    1
0B000048            9888   VUnassigned6     ds.l    1
0B00004C            9889   VUnassigned7     ds.l    1
0B000050            9890   VUnassigned8     ds.l    1
0B000054            9891   VUnassigned9     ds.l    1
0B000058            9892   VUnassigned10    ds.l    1
0B00005C            9893   VUnassigned11    ds.l    1
0B000060            9894   VSpuriousIRQ     ds.l    1
                    9895   
                    9896   * Interrupt handlers Vector 25-31
0B000064            9897   VL1IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000068            9898   VL2IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0B00006C            9899   VL3IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000070            9900   VL4IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000074            9901   VL5IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000078            9902   VL6IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0B00007C            9903   VL7IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
                    9904   
                    9905   * Trap Handler vectors 32-47
0B000080            9906   VTrap0           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000084            9907   VTrap1           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000088            9908   VTrap2           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B00008C            9909   VTrap3           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000090            9910   VTrap4           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000094            9911   VTrap5           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000098            9912   VTrap6           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B00009C            9913   VTrap7           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000A0            9914   VTrap8           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000A4            9915   VTrap9           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000A8            9916   VTrap10          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000AC            9917   VTrap11          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000B0            9918   VTrap12          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000B4            9919   VTrap13          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000B8            9920   VTrap14          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000BC            9921   VTrap15          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
                    9922   
                    9923   * the remaining exceptions are unassigned in the 68000 so no need to allocate storage for them here
                    9924   
                    9925   ***********************************************************************************************************
                    9926   * Other Variables
                    9927   ***********************************************************************************************************
                    9928   *__DebugA5       ds.l    1
                    9929   *__UserA5        ds.l    1
                    9930   
                    9931   ***********************************************************************************************************
0B0000C0            9932   __ungetbuf:     ds.l    1       ; ungetbuffer for stdio functions
0B0000C4            9933   __allocp:       ds.l    0       ; start of allocation units
0B0000C4            9934   __heap:         ds.l    0       ; pointers for malloc functions
                    9935   
                    9936   *__himem:       ds.l    himem            ; highest memory location + 1
                    9937   *__stklen:      ds.l    stklen           ; default stack size
                    9938   
                    9939   *********************************************************************************************************
                    9940   * Section for Heap
                    9941   *********************************************************************************************************
                    9942   
                    9943   _i:
0B0000C4            9944          ds.b      4
                    9945   _x:
0B0000C8            9946          ds.b      4
                    9947   _y:
0B0000CC            9948          ds.b      4
                    9949   _z:
0B0000D0            9950          ds.b      4
                    9951   _PortA_Count:
0B0000D4            9952          ds.b      4
                    9953   _Trace:
0B0000D8            9954          ds.b      4
                    9955   _GoFlag:
0B0000DC            9956          ds.b      4
                    9957   _Echo:
0B0000E0            9958          ds.b      4
                    9959   _d0:
0B0000E4            9960          ds.b      4
                    9961   _d1:
0B0000E8            9962          ds.b      4
                    9963   _d2:
0B0000EC            9964          ds.b      4
                    9965   _d3:
0B0000F0            9966          ds.b      4
                    9967   _d4:
0B0000F4            9968          ds.b      4
                    9969   _d5:
0B0000F8            9970          ds.b      4
                    9971   _d6:
0B0000FC            9972          ds.b      4
                    9973   _d7:
0B000100            9974          ds.b      4
                    9975   _a0:
0B000104            9976          ds.b      4
                    9977   _a1:
0B000108            9978          ds.b      4
                    9979   _a2:
0B00010C            9980          ds.b      4
                    9981   _a3:
0B000110            9982          ds.b      4
                    9983   _a4:
0B000114            9984          ds.b      4
                    9985   _a5:
0B000118            9986          ds.b      4
                    9987   _a6:
0B00011C            9988          ds.b      4
                    9989   _PC:
0B000120            9990          ds.b      4
                    9991   _SSP:
0B000124            9992          ds.b      4
                    9993   _USP:
0B000128            9994          ds.b      4
                    9995   _SR:
0B00012C            9996          ds.b      2
                    9997   _BreakPointAddress:
0B00012E            9998          ds.b      32
                    9999   _BreakPointInstruction:
0B00014E            10000          ds.b      16
                    10001   _BreakPointSetOrCleared:
0B00015E            10002          ds.b      32
                    10003   _InstructionSize:
0B00017E            10004          ds.b      4
                    10005   _WatchPointAddress:
0B000182            10006          ds.b      32
                    10007   _WatchPointSetOrCleared:
0B0001A2            10008          ds.b      32
                    10009   _WatchPointString:
0B0001C2            10010          ds.b      800
                    10011   _TempString:
0B0004E2            10012          ds.b      100
                    10013   @vsscanf_buf:
0B000546            10014          ds.b      80
                    10015          section   heap
0B000596            10016                   align
          0B00 0596 10017   bssEnd          equ *                   end of storage space for unitialised variables
                    10018   *                                       we have to copy all initialised variable from rom to here at startup
          0B00 0596 10019   heap   equ       *
0B000596            10020                    align
          0000 0000

Assembly errors: 0
