680x0 MACRO ASSEMBLER   Version 5.00   (c) 1992-2005 Peter J. Fondse

Date: 08 Apr 2025      Time: 14:01:18          Source: C:\COSMICIMPALASM68K\OUTPUT\LAB1DEBUGMONITOR.SRC

                       1          section   code
                       2   ; for initial stack use $08040000 if your system uses SRAM for main memory (top of 256kbyte SRAM space)
                       3   ; When your system is converted to use DRAM for main memory set this constant to $0C000000 (top of 64MByte DRAM space
                       4   
                       5   ; StackPointerVal     equ $08040000      when using sram
          0C00 0000    6   StackPointerVal     equ $0C000000      when using dram
                       7   
                       8   ; define RamVectorTable as $0803000 if your system uses SRAM for main memory
                       9   ; When your system is converted to use DRAM for main memory define RamVectorTable constant as $0B000000 (top of 64MByte DRAM space)
                      10   
                      11   ;RamVectorTable      equ $08030000      when using sram
          0B00 0000   12   RamVectorTable      equ $0B000000      when using dram
                      13   
                      14   
                      15   
                      16   ; CSTART.ASM  -  C startup-code for Debug Monitor
00000000              17                   align
                      18   
00000000              19                   org $00000000          ;start of rom based vector table, 68k hard wired to expect this at $0
                      20   
00000000  0C00 0000   21   InitialSP       dc.l StackPointerVal   ;initial supervisor state stack pointer(stack decrements first before being used)
00000004  0000 0400   22   InitialPC       dc.l start             ;address of 1st instruction of program after a reset
00000008  0000 0802   23   BusError        dc.l E_BErro           ;bus error - stop program
0000000C  0000 0814   24   AddressError    dc.l E_AErro           ;address error - stop program
00000010  0000 0826   25   IllegalInstr    dc.l E_IInst           ;illegal instruction - stop program
00000014  0000 0838   26   DividebyZero    dc.l E_DZero           ;divide by zero error - stop program
00000018  0000 084A   27   Check           dc.l E_Check           ;Check instruction - stop program
0000001C  0000 085C   28   TrapV           dc.l E_Trapv           ;Trapv instruction - stop program
00000020  0000 086E   29   Privilege       dc.l E_Priv            ;privilige violation - stop program
00000024  0000 0880   30   Trace           dc.l E_Trace           ;stop on trace
00000028  0000 0892   31   Line1010emul    dc.l E_1010            ;1010 instructions stop
0000002C  0000 08A4   32   Line1111emul    dc.l E_1111            ;1111 instructions stop
00000030  0000 08B6   33   Unassigned1     dc.l E_Unnas1           ;unassigned vector
00000034  0000 08B6   34   Unassigned2     dc.l E_Unnas2           ;unassigned vector
00000038  0000 08B6   35   Unassigned3     dc.l E_Unnas3           ;unassigned vector
0000003C  0000 08B6   36   Uninit_IRQ      dc.l E_UnitI           ;uninitialised interrupt
00000040  0000 08B6   37   Unassigned4     dc.l E_Unnas4           ;unassigned vector
00000044  0000 08B6   38   Unassigned5     dc.l E_Unnas5           ;unassigned vector
00000048  0000 08B6   39   Unassigned6     dc.l E_Unnas6           ;unassigned vector
0000004C  0000 08B6   40   Unassigned7     dc.l E_Unnas7           ;unassigned vector
00000050  0000 08B6   41   Unassigned8     dc.l E_Unnas8           ;unassigned vector
00000054  0000 08B6   42   Unassigned9     dc.l E_Unnas9           ;unassigned vector
00000058  0000 08B6   43   Unassigned10    dc.l E_Unnas10           ;unassigned vector
0000005C  0000 08B6   44   Unassigned11    dc.l E_Unnas11           ;unassigned vector
00000060  0000 08B6   45   SpuriousIRQ     dc.l E_Spuri           ;stop on spurious irq
                      46   *
                      47   *
00000064  0000 049A   48   Level1IRQ       dc.l Level1RamISR
00000068  0000 04AC   49   Level2IRQ       dc.l Level2RamISR
0000006C  0000 04BE   50   Level3IRQ       dc.l Level3RamISR
00000070  0000 04D0   51   Level4IRQ       dc.l Level4RamISR
00000074  0000 04E2   52   Level5IRQ       dc.l Level5RamISR
00000078  0000 05EC   53   Level6IRQ       dc.l Level6RamISR
0000007C  0000 05FE   54   Level7IRQ       dc.l Level7RamISR
                      55   *
                      56   *
00000080  0000 0610   57   Trap0           dc.l Trap0RamISR        ; User installed trap handler
00000084  0000 0622   58   Trap1           dc.l Trap1RamISR        ; User installed trap handler
00000088  0000 0634   59   Trap2           dc.l Trap2RamISR        ; User installed trap handler
0000008C  0000 0646   60   Trap3           dc.l Trap3RamISR        ; User installed trap handler
00000090  0000 0658   61   Trap4           dc.l Trap4RamISR        ; User installed trap handler
00000094  0000 066A   62   Trap5           dc.l Trap5RamISR        ; User installed trap handler
00000098  0000 067C   63   Trap6           dc.l Trap6RamISR        ; User installed trap handler
0000009C  0000 068E   64   Trap7           dc.l Trap7RamISR        ; User installed trap handler
000000A0  0000 06A0   65   Trap8           dc.l Trap8RamISR        ; User installed trap handler
000000A4  0000 06B2   66   Trap9           dc.l Trap9RamISR        ; User installed trap handler
000000A8  0000 06C4   67   Trap10          dc.l Trap10RamISR       ; User installed trap handler
000000AC  0000 06D6   68   Trap11          dc.l Trap11RamISR       ; User installed trap handler
000000B0  0000 06E8   69   Trap12          dc.l Trap12RamISR       ; User installed trap handler
000000B4  0000 06FA   70   Trap13          dc.l Trap13RamISR       ; User installed trap handler
000000B8  0000 070C   71   Trap14          dc.l Trap14RamISR       ; User installed trap handler
000000BC  0000 07FC   72   Trap15          dc.l Trap15RamISR       ; User installed trap handler
                      73   
                      74   *
                      75   * Other vectors 64-255 are users vectors for autovectored IO device (not implemented in TG68)
                      76   *
                      77   
00000400              78                   org       $00000400
                      79   
00000400  46FC 2700   80   start:          move.w     #$2700,SR             set interrupts to disable until later
                      81   
                      82   *************************************************************************************
                      83   ** add some 68000 instruction to read and write to memory, IO etc. This doesn't do anything
                      84   ** important, it just creates read and write bus cycles to specific addresses which
                      85   ** help with debugging hardware in Quartus simulations
                      86   **************************************************************************************
                      87   
                      88                   ; perform some dummy read/write of 32 bit values to memory to see waveforms during a simulation
                      89   
00000404  23FC 1122   90                   move.l     #$11223344,$08060000 write 32 bits, to memory
00000408  3344 0806 
0000040C  0000      
0000040E  2039 0806   91                   move.l     $08060000,d0         read 32 bits back
00000412  0000      
00000414  13FC 0000   92                   move.b     #$00,$00400000         write to the output ports
00000418  0040 0000 
0000041C  13FC 0000   93                   move.b     #$00,$00400002         write to the output ports
00000420  0040 0002 
00000424  13FC 0000   94                   move.b     #$00,$00400004         write to the output ports
00000428  0040 0004 
0000042C  13FC 0000   95                   move.b     #$00,$00400006         write to the output ports
00000430  0040 0006 
00000434  13FC 0000   96                   move.b     #$00,$00400008         write to the output ports
00000438  0040 0008 
0000043C  13FC 0000   97                   move.b     #$00,$00400010         write to the hex display ports
00000440  0040 0010 
00000444  13FC 0000   98                   move.b     #$00,$00400012         write to the hex display ports
00000448  0040 0012 
0000044C  13FC 0000   99                   move.b     #$00,$00400014         write to the hex display ports
00000450  0040 0014 
00000454  13FC 0000  100                   move.b     #0,$00400020         write to the LCD
00000458  0040 0020 
0000045C  13FC 0000  101                   move.b     #0,$00400022         write to the LCD
00000460  0040 0022 
00000464  13FC 0000  102                   move.b     #0,$00400030         write to the Timer1 Data
00000468  0040 0030 
0000046C  13FC 0000  103                   move.b     #0,$00400032         write to the Timer1 Control
00000470  0040 0032 
                     104   
                     105                   ; some important initialisation do not modify
00000474  23FC FFFF  106                   move.l    #-1,__ungetbuf  ; unget-buffer for keyboard input
00000478  FFFF 0B00 
0000047C  00C0      
0000047E  23FC 0000  107                   move.l    #0,__allocp     ; pointer to allocated memory for malloc-function
00000482  0000 0B00 
00000486  00C4      
00000488  23FC 0B00  108                   move.l    #heap,__heap    ; pointer to free memory
0000048C  0596 0B00 
00000490  00C4      
                     109   
                     110   
00000492  4EB9 0000  111   mainloop        jsr       _main
00000496  3968      
00000498  60F8       112                   bra       mainloop
                     113   
                     114   *********************************************************************************************************
                     115   * Code to call Ram Based Interrupt handler and other exeception handler code
                     116   *********************************************************************************************************
0000049A  48E7 FFFE  117   Level1RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000049E  2079 0B00  118                   move.l    VL1IRQ,a0               get ram based address into a0
000004A2  0064      
000004A4  4E90       119                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
000004A6  4CDF 7FFF  120                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004AA  4E73       121                   rte
000004AC  48E7 FFFE  122   Level2RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004B0  2079 0B00  123                   move.l    VL2IRQ,a0               get ram based address into a0
000004B4  0068      
000004B6  4E90       124                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
000004B8  4CDF 7FFF  125                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004BC  4E73       126                   rte
000004BE  48E7 FFFE  127   Level3RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004C2  2079 0B00  128                   move.l    VL3IRQ,a0               get ram based address into a0
000004C6  006C      
000004C8  4E90       129                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
000004CA  4CDF 7FFF  130                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004CE  4E73       131                   rte
000004D0  48E7 FFFE  132   Level4RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000004D4  2079 0B00  133                   move.l    VL4IRQ,a0               get ram based address into a0
000004D8  0070      
000004DA  4E90       134                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
000004DC  4CDF 7FFF  135                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000004E0  4E73       136                   rte
                     137   
                     138   * Trace trap Handler
                     139   
                     140   Level5RamISR
                     141   *
                     142   **         Copy 68000 registers from debug monitor Variables,
                     143   *
                     144   *
000004E2  23FC 0000  145                   move.l    #1,_Trace              switch on Trace Mode
000004E6  0001 0B00 
000004EA  00D8      
000004EC  13FC 0000  146                   move.b    #$0,$0040000A          turn off a trace exception so we don't when generate a trace when disassembling instruction in the register dump (disassembling causes access to use program)
000004F0  0040 000A 
000004F4  33DF 0B00  147                   move.w    (sp)+,_SR              get at the users status register pointed to by stack pointer and copy
000004F8  012C      
000004FA  23DF 0B00  148                   move.l    (sp)+,_PC              get at the users program counter and copy
000004FE  0120      
                     149   *
00000500  23CF 0B00  150                   move.l    SP,_SSP                copy system stack pointer to debug monitor variable
00000504  0124      
00000506  23C0 0B00  151                   move.l    d0,_d0
0000050A  00E4      
0000050C  23C1 0B00  152                   move.l    d1,_d1
00000510  00E8      
00000512  23C2 0B00  153                   move.l    d2,_d2
00000516  00EC      
00000518  23C3 0B00  154                   move.l    d3,_d3
0000051C  00F0      
0000051E  23C4 0B00  155                   move.l    d4,_d4
00000522  00F4      
00000524  23C5 0B00  156                   move.l    d5,_d5
00000528  00F8      
0000052A  23C6 0B00  157                   move.l    d6,_d6
0000052E  00FC      
00000530  23C7 0B00  158                   move.l    d7,_d7
00000534  0100      
                     159   *
00000536  23C8 0B00  160                   move.l    a0,_a0
0000053A  0104      
0000053C  23C9 0B00  161                   move.l    a1,_a1
00000540  0108      
00000542  23CA 0B00  162                   move.l    a2,_a2
00000546  010C      
00000548  23CB 0B00  163                   move.l    a3,_a3
0000054C  0110      
0000054E  23CC 0B00  164                   move.l    a4,_a4
00000552  0114      
00000554  23CD 0B00  165                   move.l    a5,_a5
00000558  0118      
0000055A  23CE 0B00  166                   move.l    a6,_a6
0000055E  011C      
00000560  4E68       167                   move.l    usp,a0
00000562  23C8 0B00  168                   move.l    a0,_USP
00000566  0128      
                     169   *
00000568  2079 0B00  170                   move.l    VL5IRQ,a0              get ram based address into a0, trace exception for next instruction will be generated in Menu SPACE command
0000056C  0074      
0000056E  4E90       171                   jsr       0(a0)                  jump to the subroutine that is the trap handler, using ram based address
                     172   
                     173   ** After trace, reload 68000 registers with new values before continuing
                     174   
00000570  2039 0B00  175                   move.l   _d0,d0
00000574  00E4      
00000576  2239 0B00  176                   move.l   _d1,d1
0000057A  00E8      
0000057C  2439 0B00  177                   move.l   _d2,d2
00000580  00EC      
00000582  2639 0B00  178                   move.l   _d3,d3
00000586  00F0      
00000588  2839 0B00  179                   move.l   _d4,d4
0000058C  00F4      
0000058E  2A39 0B00  180                   move.l   _d5,d5
00000592  00F8      
00000594  2C39 0B00  181                   move.l   _d6,d6
00000598  00FC      
0000059A  2E39 0B00  182                   move.l   _d7,d7
0000059E  0100      
                     183   
000005A0  2079 0B00  184                   move.l   _USP,a0
000005A4  0128      
000005A6  4E60       185                   move.l   a0,USP                     load user stack pointer
000005A8  2079 0B00  186                   move.l   _a0,a0
000005AC  0104      
000005AE  2279 0B00  187                   move.l   _a1,a1
000005B2  0108      
000005B4  2479 0B00  188                   move.l   _a2,a2
000005B8  010C      
000005BA  2679 0B00  189                   move.l   _a3,a3
000005BE  0110      
000005C0  2879 0B00  190                   move.l   _a4,a4
000005C4  0114      
000005C6  2A79 0B00  191                   move.l   _a5,a5
000005CA  0118      
000005CC  2C79 0B00  192                   move.l   _a6,a6
000005D0  011C      
                     193   
000005D2  2E79 0B00  194                   move.l   _SSP,sp
000005D6  0124      
000005D8  2F39 0B00  195                   move.l   _PC,-(sp)
000005DC  0120      
000005DE  3F39 0B00  196                   move.w   _SR,-(sp)
000005E2  012C      
000005E4  11F8 0074  197                   move.b    $00000074,$0	          read trace exception vector after accessing disassembly to reset the trace request causes by disassembling program above
000005E8  0000      
000005EA  4E73       198                   rte
                     199   
                     200   * address trap handler
                     201   
000005EC  48E7 FFFE  202   Level6RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000005F0  2079 0B00  203                   move.l    VL6IRQ,a0               get ram based address into a0
000005F4  0078      
000005F6  4E90       204                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
000005F8  4CDF 7FFF  205                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000005FC  4E73       206                   rte
                     207   
000005FE  48E7 FFFE  208   Level7RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000602  2079 0B00  209                   move.l    VL7IRQ,a0               get ram based address into a0
00000606  007C      
00000608  4E90       210                   jsr       0(a0)                   jump to the subroutine that is the interrupt handler, using ram based address
0000060A  4CDF 7FFF  211                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000060E  4E73       212                   rte
                     213   
                     214   
                     215   ********************************************************************************************************
                     216   * Ram based Trap handler and other exeception handler code
                     217   *********************************************************************************************************
                     218   
00000610  48E7 FFFE  219   Trap0RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000614  2079 0B00  220                   move.l    VTrap0,a0                get ram based address into a0
00000618  0080      
0000061A  4E90       221                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000061C  4CDF 7FFF  222                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000620  4E73       223                   rte
                     224   
00000622  48E7 FFFE  225   Trap1RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000626  2079 0B00  226                   move.l    VTrap1,a0                get ram based address into a0
0000062A  0084      
0000062C  4E90       227                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000062E  4CDF 7FFF  228                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000632  4E73       229                   rte
                     230   
00000634  48E7 FFFE  231   Trap2RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000638  2079 0B00  232                   move.l    VTrap2,a0                get ram based address into a0
0000063C  0088      
0000063E  4E90       233                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000640  4CDF 7FFF  234                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000644  4E73       235                   rte
                     236   
00000646  48E7 FFFE  237   Trap3RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000064A  2079 0B00  238                   move.l    VTrap3,a0                get ram based address into a0
0000064E  008C      
00000650  4E90       239                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000652  4CDF 7FFF  240                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000656  4E73       241                   rte
                     242   
00000658  48E7 FFFE  243   Trap4RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000065C  2079 0B00  244                   move.l    VTrap4,a0                get ram based address into a0
00000660  0090      
00000662  4E90       245                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000664  4CDF 7FFF  246                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000668  4E73       247                   rte
                     248   
0000066A  48E7 FFFE  249   Trap5RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000066E  2079 0B00  250                   move.l    VTrap5,a0                get ram based address into a0
00000672  0094      
00000674  4E90       251                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000676  4CDF 7FFF  252                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000067A  4E73       253                   rte
                     254   
0000067C  48E7 FFFE  255   Trap6RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000680  2079 0B00  256                   move.l    VTrap6,a0                get ram based address into a0
00000684  0098      
00000686  4E90       257                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000688  4CDF 7FFF  258                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000068C  4E73       259                   rte
                     260   
0000068E  48E7 FFFE  261   Trap7RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000692  2079 0B00  262                   move.l    VTrap7,a0                get ram based address into a0
00000696  009C      
00000698  4E90       263                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000069A  4CDF 7FFF  264                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000069E  4E73       265                   rte
                     266   
000006A0  48E7 FFFE  267   Trap8RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006A4  2079 0B00  268                   move.l    VTrap8,a0                get ram based address into a0
000006A8  00A0      
000006AA  4E90       269                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000006AC  4CDF 7FFF  270                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000006B0  4E73       271                   rte
                     272   
000006B2  48E7 FFFE  273   Trap9RamISR     movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006B6  2079 0B00  274                   move.l    VTrap9,a0                get ram based address into a0
000006BA  00A4      
000006BC  4E90       275                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000006BE  4CDF 7FFF  276                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000006C2  4E73       277                   rte
                     278   
000006C4  48E7 FFFE  279   Trap10RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006C8  2079 0B00  280                   move.l    VTrap10,a0                get ram based address into a0
000006CC  00A8      
000006CE  4E90       281                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000006D0  4CDF 7FFF  282                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000006D4  4E73       283                   rte
                     284   
000006D6  48E7 FFFE  285   Trap11RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006DA  2079 0B00  286                   move.l    VTrap11,a0                get ram based address into a0
000006DE  00AC      
000006E0  4E90       287                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000006E2  4CDF 7FFF  288                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000006E6  4E73       289                   rte
                     290   
000006E8  48E7 FFFE  291   Trap12RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006EC  2079 0B00  292                   move.l    VTrap12,a0                get ram based address into a0
000006F0  00B0      
000006F2  4E90       293                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000006F4  4CDF 7FFF  294                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000006F8  4E73       295                   rte
                     296   
000006FA  48E7 FFFE  297   Trap13RamISR    movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000006FE  2079 0B00  298                   move.l    VTrap13,a0                get ram based address into a0
00000702  00B4      
00000704  4E90       299                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000706  4CDF 7FFF  300                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000070A  4E73       301                   rte
                     302   
                     303   Trap14RamISR    ;Break Point Handler
                     304   *
                     305   **         Copy 68000 registers from debug monitor Variables
                     306   *
0000070C  23FC 0000  307                   move.l    #1,_Trace      switch on Trace Mode
00000710  0001 0B00 
00000714  00D8      
00000716  33DF 0B00  308                   move.w    (sp)+,_SR       get at the users status register pointed to by stack pointer and copy
0000071A  012C      
0000071C  23DF 0B00  309                   move.l    (sp)+,_PC      get at the users program counter and copy
00000720  0120      
                     310   *
00000722  23C0 0B00  311                   move.l    d0,_d0
00000726  00E4      
00000728  23C1 0B00  312                   move.l    d1,_d1
0000072C  00E8      
0000072E  23C2 0B00  313                   move.l    d2,_d2
00000732  00EC      
00000734  23C3 0B00  314                   move.l    d3,_d3
00000738  00F0      
0000073A  23C4 0B00  315                   move.l    d4,_d4
0000073E  00F4      
00000740  23C5 0B00  316                   move.l    d5,_d5
00000744  00F8      
00000746  23C6 0B00  317                   move.l    d6,_d6
0000074A  00FC      
0000074C  23C7 0B00  318                   move.l    d7,_d7
00000750  0100      
                     319   *
00000752  23C8 0B00  320                   move.l    a0,_a0
00000756  0104      
00000758  23C9 0B00  321                   move.l    a1,_a1
0000075C  0108      
0000075E  23CA 0B00  322                   move.l    a2,_a2
00000762  010C      
00000764  23CB 0B00  323                   move.l    a3,_a3
00000768  0110      
0000076A  23CC 0B00  324                   move.l    a4,_a4
0000076E  0114      
00000770  23CD 0B00  325                   move.l    a5,_a5
00000774  0118      
00000776  23CE 0B00  326                   move.l    a6,_a6
0000077A  011C      
0000077C  4E68       327                   move.l    USP,a0
0000077E  23C8 0B00  328                   move.l    a0,_USP
00000782  0128      
                     329   *
00000784  2079 0B00  330                   move.l    VTrap14,a0             get ram based address into a0
00000788  00B8      
0000078A  4E90       331                   jsr       0(a0)                  jump to the subroutine that is the trap handler, using ram based address
                     332   
                     333   ** After breakpoint reload 68000 registers with new values before continuing
                     334   
                     335   *                move.b    #$ff,$0040000A     generate a trace exception for the next instruction
0000078C  2039 0B00  336                   move.l   _d0,d0
00000790  00E4      
00000792  2239 0B00  337                   move.l   _d1,d1
00000796  00E8      
00000798  2439 0B00  338                   move.l   _d2,d2
0000079C  00EC      
0000079E  2639 0B00  339                   move.l   _d3,d3
000007A2  00F0      
000007A4  2839 0B00  340                   move.l   _d4,d4
000007A8  00F4      
000007AA  2A39 0B00  341                   move.l   _d5,d5
000007AE  00F8      
000007B0  2C39 0B00  342                   move.l   _d6,d6
000007B4  00FC      
000007B6  2E39 0B00  343                   move.l   _d7,d7
000007BA  0100      
                     344   
000007BC  2079 0B00  345                   move.l   _USP,a0
000007C0  0128      
000007C2  4E60       346                   move.l   a0,USP        load user stack pointer A7
000007C4  2079 0B00  347                   move.l   _a0,a0
000007C8  0104      
000007CA  2279 0B00  348                   move.l   _a1,a1
000007CE  0108      
000007D0  2479 0B00  349                   move.l   _a2,a2
000007D4  010C      
000007D6  2679 0B00  350                   move.l   _a3,a3
000007DA  0110      
000007DC  2879 0B00  351                   move.l   _a4,a4
000007E0  0114      
000007E2  2A79 0B00  352                   move.l   _a5,a5
000007E6  0118      
000007E8  2C79 0B00  353                   move.l   _a6,a6
000007EC  011C      
                     354   
000007EE  2F39 0B00  355                   move.l   _PC,-(sp)
000007F2  0120      
000007F4  3F39 0B00  356                   move.w   _SR,-(sp)
000007F8  012C      
000007FA  4E73       357                   rte
                     358   
000007FC  4EF9 0000  359   Trap15RamISR    jmp     _CallDebugMonitor
00000800  2FFC      
                     360   *                movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
                     361   *                move.l    VTrap15,a0                get ram based address into a0
                     362   *                jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
                     363   *                movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
                     364   *                rte
                     365   
                     366   *********************************************************************************************************
                     367   *Default exception handler for everything without a specific handler
                     368   *********************************************************************************************************
                     369   
                     370   *
                     371   **              Jump here for each unhandled exception
                     372   **              If you need to, MAKE SURE YOU SAVE ALL IMPORTANT REGISTERS AND RESTORE THEM BEFORE RETURNING (IF APPROPRIATE)
                     373   *
                     374   
00000802  48E7 FFFE  375   E_BErro         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000806  2079 0B00  376                   move.l    VBusError,a0            get ram based address into a0
0000080A  0008      
0000080C  4E90       377                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000080E  4CDF 7FFF  378                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000812  4E73       379                   rte
00000814  48E7 FFFE  380   E_AErro         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000818  2079 0B00  381                   move.l    VAddressError,a0        get ram based address into a0
0000081C  000C      
0000081E  4E90       382                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000820  4CDF 7FFF  383                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000824  4E73       384                   rte
00000826  48E7 FFFE  385   E_IInst         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000082A  2079 0B00  386                   move.l    VIllegalInstr,a0        get ram based address into a0
0000082E  0010      
00000830  4E90       387                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000832  4CDF 7FFF  388                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000836  4E73       389                   rte
00000838  48E7 FFFE  390   E_DZero         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000083C  2079 0B00  391                   move.l    VDividebyZero,a0        get ram based address into a0
00000840  0014      
00000842  4E90       392                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000844  4CDF 7FFF  393                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000848  4E73       394                   rte
0000084A  48E7 FFFE  395   E_Check         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
0000084E  2079 0B00  396                   move.l    VCheck,a0               get ram based address into a0
00000852  0018      
00000854  4E90       397                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000856  4CDF 7FFF  398                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000085A  4E73       399                   rte
0000085C  48E7 FFFE  400   E_Trapv         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000860  2079 0B00  401                   move.l    VTrapV,a0               get ram based address into a0
00000864  001C      
00000866  4E90       402                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
00000868  4CDF 7FFF  403                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000086C  4E73       404                   rte
0000086E  48E7 FFFE  405   E_Priv          movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000872  2079 0B00  406                   move.l    VPrivilege,a0           get ram based address into a0
00000876  0020      
00000878  4E90       407                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000087A  4CDF 7FFF  408                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
0000087E  4E73       409                   rte
00000880  48E7 FFFE  410   E_Trace         movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000884  2079 0B00  411                   move.l    VTrace,a0               get ram based address into a0
00000888  0024      
0000088A  4E90       412                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000088C  4CDF 7FFF  413                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
00000890  4E73       414                   rte
00000892  48E7 FFFE  415   E_1010          movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
00000896  2079 0B00  416                   move.l    VLine1010emul,a0        get ram based address into a0
0000089A  0028      
0000089C  4E90       417                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
0000089E  4CDF 7FFF  418                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000008A2  4E73       419                   rte
000008A4  48E7 FFFE  420   E_1111          movem.l   d0-d7/a0-a6,-(SP)       save everything not automatically saved
000008A8  2079 0B00  421                   move.l    VLine1111emul,a0        get ram based address into a0
000008AC  002C      
000008AE  4E90       422                   jsr       0(a0)                   jump to the subroutine that is the trap handler, using ram based address
000008B0  4CDF 7FFF  423                   movem.l   (SP)+,d0-d7/a0-a6       pull eveything off the stack
000008B4  4E73       424                   rte
                     425   E_Unnas1
                     426   E_Unnas2
                     427   E_Unnas3
                     428   E_UnitI
                     429   E_Unnas4
                     430   E_Unnas5
                     431   E_Unnas6
                     432   E_Unnas7
                     433   E_Unnas8
                     434   E_Unnas9
                     435   E_Unnas10
                     436   E_Unnas11
                     437   E_Spuri
000008B6  60FE       438   _stop            bra _stop                         stop
                     439   ***************************************************************************************************
                     440   * Go() function in debug monitor
                     441   ***************************************************************************************************
                     442   _go
000008B8  2E79 0B00  443                   move.l   _SSP,a7        load system stack pointer (remember we are in supervisor mode when running this so a7 is the System stack pointer)
000008BC  0124      
000008BE  2F39 0B00  444                   move.l   _PC,-(sp)      copy debug monitor PC variable to the stack
000008C2  0120      
000008C4  3F39 0B00  445                   move.w   _SR,-(sp)      copy debug monitor status reg to the stack
000008C8  012C      
                     446   
000008CA  1038 0078  447                   move.b   $00000078,d0  remove any spurious address exception arising after power on
000008CE  2039 0B00  448                   move.l   _d0,d0
000008D2  00E4      
000008D4  2239 0B00  449                   move.l   _d1,d1
000008D8  00E8      
000008DA  2439 0B00  450                   move.l   _d2,d2
000008DE  00EC      
000008E0  2639 0B00  451                   move.l   _d3,d3
000008E4  00F0      
000008E6  2839 0B00  452                   move.l   _d4,d4
000008EA  00F4      
000008EC  2A39 0B00  453                   move.l   _d5,d5
000008F0  00F8      
000008F2  2C39 0B00  454                   move.l   _d6,d6
000008F6  00FC      
000008F8  2E39 0B00  455                   move.l   _d7,d7
000008FC  0100      
                     456   
000008FE  2079 0B00  457                   move.l   _USP,a0
00000902  0128      
00000904  4E60       458                   move.l   a0,USP        load user stack pointer (remember we are in supervisor mode when running this, so a7 is the System stack pointer)
00000906  2079 0B00  459                   move.l   _a0,a0
0000090A  0104      
0000090C  2279 0B00  460                   move.l   _a1,a1
00000910  0108      
00000912  2479 0B00  461                   move.l   _a2,a2
00000916  010C      
00000918  2679 0B00  462                   move.l   _a3,a3
0000091C  0110      
0000091E  2879 0B00  463                   move.l   _a4,a4
00000922  0114      
00000924  2A79 0B00  464                   move.l   _a5,a5
00000928  0118      
0000092A  2C79 0B00  465                   move.l   _a6,a6
0000092E  011C      
00000930  4E73       466                   rte                    load the status reg and PC from the stack and commence running
                     467                                          *used to be rte but this didn't load the status byte
                     468   
                     469   ; C:\M68KV6.0 - 800BY480\PROGRAMS\DEBUGMONITORCODE\CANBUS_CONTROLLER.C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
                     470   ; /*********************************************************************************************
                     471   ; ** These addresses and definitions were taken from Appendix 7 of the Can Controller
                     472   ; ** application note and adapted for the 68k assignment
                     473   ; *********************************************************************************************/
                     474   ; /*
                     475   ; ** definition for the SJA1000 registers and bits based on 68k address map areas
                     476   ; ** assume the addresses for the 2 can controllers given in the assignment
                     477   ; **
                     478   ; ** Registers are defined in terms of the following Macro for each Can controller,
                     479   ; ** where (i) represents an registers number
                     480   ; */
                     481   ; #define CAN0_CONTROLLER(i) (*(volatile unsigned char *)(0x00500000 + (i << 1)))
                     482   ; #define CAN1_CONTROLLER(i) (*(volatile unsigned char *)(0x00500200 + (i << 1)))
                     483   ; /* Can 0 register definitions */
                     484   ; #define Can0_ModeControlReg      CAN0_CONTROLLER(0)
                     485   ; #define Can0_CommandReg          CAN0_CONTROLLER(1)
                     486   ; #define Can0_StatusReg           CAN0_CONTROLLER(2)
                     487   ; #define Can0_InterruptReg        CAN0_CONTROLLER(3)
                     488   ; #define Can0_InterruptEnReg      CAN0_CONTROLLER(4) /* PeliCAN mode */
                     489   ; #define Can0_BusTiming0Reg       CAN0_CONTROLLER(6)
                     490   ; #define Can0_BusTiming1Reg       CAN0_CONTROLLER(7)
                     491   ; #define Can0_OutControlReg       CAN0_CONTROLLER(8)
                     492   ; /* address definitions of Other Registers */
                     493   ; #define Can0_ArbLostCapReg       CAN0_CONTROLLER(11)
                     494   ; #define Can0_ErrCodeCapReg       CAN0_CONTROLLER(12)
                     495   ; #define Can0_ErrWarnLimitReg     CAN0_CONTROLLER(13)
                     496   ; #define Can0_RxErrCountReg       CAN0_CONTROLLER(14)
                     497   ; #define Can0_TxErrCountReg       CAN0_CONTROLLER(15)
                     498   ; #define Can0_RxMsgCountReg       CAN0_CONTROLLER(29)
                     499   ; #define Can0_RxBufStartAdr       CAN0_CONTROLLER(30)
                     500   ; #define Can0_ClockDivideReg      CAN0_CONTROLLER(31)
                     501   ; /* address definitions of Acceptance Code & Mask Registers - RESET MODE */
                     502   ; #define Can0_AcceptCode0Reg      CAN0_CONTROLLER(16)
                     503   ; #define Can0_AcceptCode1Reg      CAN0_CONTROLLER(17)
                     504   ; #define Can0_AcceptCode2Reg      CAN0_CONTROLLER(18)
                     505   ; #define Can0_AcceptCode3Reg      CAN0_CONTROLLER(19)
                     506   ; #define Can0_AcceptMask0Reg      CAN0_CONTROLLER(20)
                     507   ; #define Can0_AcceptMask1Reg      CAN0_CONTROLLER(21)
                     508   ; #define Can0_AcceptMask2Reg      CAN0_CONTROLLER(22)
                     509   ; #define Can0_AcceptMask3Reg      CAN0_CONTROLLER(23)
                     510   ; /* address definitions Rx Buffer - OPERATING MODE - Read only register*/
                     511   ; #define Can0_RxFrameInfo         CAN0_CONTROLLER(16)
                     512   ; #define Can0_RxBuffer1           CAN0_CONTROLLER(17)
                     513   ; #define Can0_RxBuffer2           CAN0_CONTROLLER(18)
                     514   ; #define Can0_RxBuffer3           CAN0_CONTROLLER(19)
                     515   ; #define Can0_RxBuffer4           CAN0_CONTROLLER(20)
                     516   ; #define Can0_RxBuffer5           CAN0_CONTROLLER(21)
                     517   ; #define Can0_RxBuffer6           CAN0_CONTROLLER(22)
                     518   ; #define Can0_RxBuffer7           CAN0_CONTROLLER(23)
                     519   ; #define Can0_RxBuffer8           CAN0_CONTROLLER(24)
                     520   ; #define Can0_RxBuffer9           CAN0_CONTROLLER(25)
                     521   ; #define Can0_RxBuffer10          CAN0_CONTROLLER(26)
                     522   ; #define Can0_RxBuffer11          CAN0_CONTROLLER(27)
                     523   ; #define Can0_RxBuffer12          CAN0_CONTROLLER(28)
                     524   ; /* address definitions of the Tx-Buffer - OPERATING MODE - Write only register */
                     525   ; #define Can0_TxFrameInfo         CAN0_CONTROLLER(16)
                     526   ; #define Can0_TxBuffer1           CAN0_CONTROLLER(17)
                     527   ; #define Can0_TxBuffer2           CAN0_CONTROLLER(18)
                     528   ; #define Can0_TxBuffer3           CAN0_CONTROLLER(19)
                     529   ; #define Can0_TxBuffer4           CAN0_CONTROLLER(20)
                     530   ; #define Can0_TxBuffer5           CAN0_CONTROLLER(21)
                     531   ; #define Can0_TxBuffer6           CAN0_CONTROLLER(22)
                     532   ; #define Can0_TxBuffer7           CAN0_CONTROLLER(23)
                     533   ; #define Can0_TxBuffer8           CAN0_CONTROLLER(24)
                     534   ; #define Can0_TxBuffer9           CAN0_CONTROLLER(25)
                     535   ; #define Can0_TxBuffer10          CAN0_CONTROLLER(26)
                     536   ; #define Can0_TxBuffer11          CAN0_CONTROLLER(27)
                     537   ; #define Can0_TxBuffer12          CAN0_CONTROLLER(28)
                     538   ; /* read only addresses */
                     539   ; #define Can0_TxFrameInfoRd       CAN0_CONTROLLER(96)
                     540   ; #define Can0_TxBufferRd1         CAN0_CONTROLLER(97)
                     541   ; #define Can0_TxBufferRd2         CAN0_CONTROLLER(98)
                     542   ; #define Can0_TxBufferRd3         CAN0_CONTROLLER(99)
                     543   ; #define Can0_TxBufferRd4         CAN0_CONTROLLER(100)
                     544   ; #define Can0_TxBufferRd5         CAN0_CONTROLLER(101)
                     545   ; #define Can0_TxBufferRd6         CAN0_CONTROLLER(102)
                     546   ; #define Can0_TxBufferRd7         CAN0_CONTROLLER(103)
                     547   ; #define Can0_TxBufferRd8         CAN0_CONTROLLER(104)
                     548   ; #define Can0_TxBufferRd9         CAN0_CONTROLLER(105)
                     549   ; #define Can0_TxBufferRd10        CAN0_CONTROLLER(106)
                     550   ; #define Can0_TxBufferRd11        CAN0_CONTROLLER(107)
                     551   ; #define Can0_TxBufferRd12        CAN0_CONTROLLER(108)
                     552   ; /* CAN1 Controller register definitions */
                     553   ; #define Can1_ModeControlReg      CAN1_CONTROLLER(0)
                     554   ; #define Can1_CommandReg          CAN1_CONTROLLER(1)
                     555   ; #define Can1_StatusReg           CAN1_CONTROLLER(2)
                     556   ; #define Can1_InterruptReg        CAN1_CONTROLLER(3)
                     557   ; #define Can1_InterruptEnReg      CAN1_CONTROLLER(4) /* PeliCAN mode */
                     558   ; #define Can1_BusTiming0Reg       CAN1_CONTROLLER(6)
                     559   ; #define Can1_BusTiming1Reg       CAN1_CONTROLLER(7)
                     560   ; #define Can1_OutControlReg       CAN1_CONTROLLER(8)
                     561   ; /* address definitions of Other Registers */
                     562   ; #define Can1_ArbLostCapReg       CAN1_CONTROLLER(11)
                     563   ; #define Can1_ErrCodeCapReg       CAN1_CONTROLLER(12)
                     564   ; #define Can1_ErrWarnLimitReg     CAN1_CONTROLLER(13)
                     565   ; #define Can1_RxErrCountReg       CAN1_CONTROLLER(14)
                     566   ; #define Can1_TxErrCountReg       CAN1_CONTROLLER(15)
                     567   ; #define Can1_RxMsgCountReg       CAN1_CONTROLLER(29)
                     568   ; #define Can1_RxBufStartAdr       CAN1_CONTROLLER(30)
                     569   ; #define Can1_ClockDivideReg      CAN1_CONTROLLER(31)
                     570   ; /* address definitions of Acceptance Code & Mask Registers - RESET MODE */
                     571   ; #define Can1_AcceptCode0Reg      CAN1_CONTROLLER(16)
                     572   ; #define Can1_AcceptCode1Reg      CAN1_CONTROLLER(17)
                     573   ; #define Can1_AcceptCode2Reg      CAN1_CONTROLLER(18)
                     574   ; #define Can1_AcceptCode3Reg      CAN1_CONTROLLER(19)
                     575   ; #define Can1_AcceptMask0Reg      CAN1_CONTROLLER(20)
                     576   ; #define Can1_AcceptMask1Reg      CAN1_CONTROLLER(21)
                     577   ; #define Can1_AcceptMask2Reg      CAN1_CONTROLLER(22)
                     578   ; #define Can1_AcceptMask3Reg      CAN1_CONTROLLER(23)
                     579   ; /* address definitions Rx Buffer - OPERATING MODE - Read only register*/
                     580   ; #define Can1_RxFrameInfo         CAN1_CONTROLLER(16)
                     581   ; #define Can1_RxBuffer1           CAN1_CONTROLLER(17)
                     582   ; #define Can1_RxBuffer2           CAN1_CONTROLLER(18)
                     583   ; #define Can1_RxBuffer3           CAN1_CONTROLLER(19)
                     584   ; #define Can1_RxBuffer4           CAN1_CONTROLLER(20)
                     585   ; #define Can1_RxBuffer5           CAN1_CONTROLLER(21)
                     586   ; #define Can1_RxBuffer6           CAN1_CONTROLLER(22)
                     587   ; #define Can1_RxBuffer7           CAN1_CONTROLLER(23)
                     588   ; #define Can1_RxBuffer8           CAN1_CONTROLLER(24)
                     589   ; #define Can1_RxBuffer9           CAN1_CONTROLLER(25)
                     590   ; #define Can1_RxBuffer10          CAN1_CONTROLLER(26)
                     591   ; #define Can1_RxBuffer11          CAN1_CONTROLLER(27)
                     592   ; #define Can1_RxBuffer12          CAN1_CONTROLLER(28)
                     593   ; /* address definitions of the Tx-Buffer - OPERATING MODE - Write only register */
                     594   ; #define Can1_TxFrameInfo         CAN1_CONTROLLER(16)
                     595   ; #define Can1_TxBuffer1           CAN1_CONTROLLER(17)
                     596   ; #define Can1_TxBuffer2           CAN1_CONTROLLER(18)
                     597   ; #define Can1_TxBuffer3           CAN1_CONTROLLER(19)
                     598   ; #define Can1_TxBuffer4           CAN1_CONTROLLER(20)
                     599   ; #define Can1_TxBuffer5           CAN1_CONTROLLER(21)
                     600   ; #define Can1_TxBuffer6           CAN1_CONTROLLER(22)
                     601   ; #define Can1_TxBuffer7           CAN1_CONTROLLER(23)
                     602   ; #define Can1_TxBuffer8           CAN1_CONTROLLER(24)
                     603   ; #define Can1_TxBuffer9           CAN1_CONTROLLER(25)
                     604   ; #define Can1_TxBuffer10          CAN1_CONTROLLER(26)
                     605   ; #define Can1_TxBuffer11          CAN1_CONTROLLER(27)
                     606   ; #define Can1_TxBuffer12          CAN1_CONTROLLER(28)
                     607   ; /* read only addresses */
                     608   ; #define Can1_TxFrameInfoRd       CAN1_CONTROLLER(96)
                     609   ; #define Can1_TxBufferRd1         CAN1_CONTROLLER(97)
                     610   ; #define Can1_TxBufferRd2         CAN1_CONTROLLER(98)
                     611   ; #define Can1_TxBufferRd3         CAN1_CONTROLLER(99)
                     612   ; #define Can1_TxBufferRd4         CAN1_CONTROLLER(100)
                     613   ; #define Can1_TxBufferRd5         CAN1_CONTROLLER(101)
                     614   ; #define Can1_TxBufferRd6         CAN1_CONTROLLER(102)
                     615   ; #define Can1_TxBufferRd7         CAN1_CONTROLLER(103)
                     616   ; #define Can1_TxBufferRd8         CAN1_CONTROLLER(104)
                     617   ; #define Can1_TxBufferRd9         CAN1_CONTROLLER(105)
                     618   ; #define Can1_TxBufferRd10        CAN1_CONTROLLER(106)
                     619   ; #define Can1_TxBufferRd11        CAN1_CONTROLLER(107)
                     620   ; #define Can1_TxBufferRd12        CAN1_CONTROLLER(108)
                     621   ; /* bit definitions for the Mode & Control Register */
                     622   ; #define RM_RR_Bit 0x01 /* reset mode (request) bit */
                     623   ; #define LOM_Bit 0x02 /* listen only mode bit */
                     624   ; #define STM_Bit 0x04 /* self test mode bit */
                     625   ; #define AFM_Bit 0x08 /* acceptance filter mode bit */
                     626   ; #define SM_Bit  0x10 /* enter sleep mode bit */
                     627   ; /* bit definitions for the Interrupt Enable & Control Register */
                     628   ; #define RIE_Bit 0x01 /* receive interrupt enable bit */
                     629   ; #define TIE_Bit 0x02 /* transmit interrupt enable bit */
                     630   ; #define EIE_Bit 0x04 /* error warning interrupt enable bit */
                     631   ; #define DOIE_Bit 0x08 /* data overrun interrupt enable bit */
                     632   ; #define WUIE_Bit 0x10 /* wake-up interrupt enable bit */
                     633   ; #define EPIE_Bit 0x20 /* error passive interrupt enable bit */
                     634   ; #define ALIE_Bit 0x40 /* arbitration lost interr. enable bit*/
                     635   ; #define BEIE_Bit 0x80 /* bus error interrupt enable bit */
                     636   ; /* bit definitions for the Command Register */
                     637   ; #define TR_Bit 0x01 /* transmission request bit */
                     638   ; #define AT_Bit 0x02 /* abort transmission bit */
                     639   ; #define RRB_Bit 0x04 /* release receive buffer bit */
                     640   ; #define CDO_Bit 0x08 /* clear data overrun bit */
                     641   ; #define SRR_Bit 0x10 /* self reception request bit */
                     642   ; /* bit definitions for the Status Register */
                     643   ; #define RBS_Bit 0x01 /* receive buffer status bit */
                     644   ; #define DOS_Bit 0x02 /* data overrun status bit */
                     645   ; #define TBS_Bit 0x04 /* transmit buffer status bit */
                     646   ; #define TCS_Bit 0x08 /* transmission complete status bit */
                     647   ; #define RS_Bit 0x10 /* receive status bit */
                     648   ; #define TS_Bit 0x20 /* transmit status bit */
                     649   ; #define ES_Bit 0x40 /* error status bit */
                     650   ; #define BS_Bit 0x80 /* bus status bit */
                     651   ; /* bit definitions for the Interrupt Register */
                     652   ; #define RI_Bit 0x01 /* receive interrupt bit */
                     653   ; #define TI_Bit 0x02 /* transmit interrupt bit */
                     654   ; #define EI_Bit 0x04 /* error warning interrupt bit */
                     655   ; #define DOI_Bit 0x08 /* data overrun interrupt bit */
                     656   ; #define WUI_Bit 0x10 /* wake-up interrupt bit */
                     657   ; #define EPI_Bit 0x20 /* error passive interrupt bit */
                     658   ; #define ALI_Bit 0x40 /* arbitration lost interrupt bit */
                     659   ; #define BEI_Bit 0x80 /* bus error interrupt bit */
                     660   ; /* bit definitions for the Bus Timing Registers */
                     661   ; #define SAM_Bit 0x80                        /* sample mode bit 1 == the bus is sampled 3 times, 0 == the bus is sampled once */
                     662   ; /* bit definitions for the Output Control Register OCMODE1, OCMODE0 */
                     663   ; #define BiPhaseMode 0x00 /* bi-phase output mode */
                     664   ; #define NormalMode 0x02 /* normal output mode */
                     665   ; #define ClkOutMode 0x03 /* clock output mode */
                     666   ; /* output pin configuration for TX1 */
                     667   ; #define OCPOL1_Bit 0x20 /* output polarity control bit */
                     668   ; #define Tx1Float 0x00 /* configured as float */
                     669   ; #define Tx1PullDn 0x40 /* configured as pull-down */
                     670   ; #define Tx1PullUp 0x80 /* configured as pull-up */
                     671   ; #define Tx1PshPull 0xC0 /* configured as push/pull */
                     672   ; /* output pin configuration for TX0 */
                     673   ; #define OCPOL0_Bit 0x04 /* output polarity control bit */
                     674   ; #define Tx0Float 0x00 /* configured as float */
                     675   ; #define Tx0PullDn 0x08 /* configured as pull-down */
                     676   ; #define Tx0PullUp 0x10 /* configured as pull-up */
                     677   ; #define Tx0PshPull 0x18 /* configured as push/pull */
                     678   ; /* bit definitions for the Clock Divider Register */
                     679   ; #define DivBy1 0x07 /* CLKOUT = oscillator frequency */
                     680   ; #define DivBy2 0x00 /* CLKOUT = 1/2 oscillator frequency */
                     681   ; #define ClkOff_Bit 0x08 /* clock off bit, control of the CLK OUT pin */
                     682   ; #define RXINTEN_Bit 0x20 /* pin TX1 used for receive interrupt */
                     683   ; #define CBP_Bit 0x40 /* CAN comparator bypass control bit */
                     684   ; #define CANMode_Bit 0x80 /* CAN mode definition bit */
                     685   ; /*- definition of used constants ---------------------------------------*/
                     686   ; #define YES 1
                     687   ; #define NO 0
                     688   ; #define ENABLE 1
                     689   ; #define DISABLE 0
                     690   ; #define ENABLE_N 0
                     691   ; #define DISABLE_N 1
                     692   ; #define INTLEVELACT 0
                     693   ; #define INTEDGEACT 1
                     694   ; #define PRIORITY_LOW 0
                     695   ; #define PRIORITY_HIGH 1
                     696   ; /* default (reset) value for register content, clear register */
                     697   ; #define ClrByte 0x00
                     698   ; /* constant: clear Interrupt Enable Register */
                     699   ; #define ClrIntEnSJA ClrByte
                     700   ; /* definitions for the acceptance code and mask register */
                     701   ; #define DontCare 0xFF
                     702   ; /*  bus timing values for
                     703   ; **  bit-rate : 100 kBit/s
                     704   ; **  oscillator frequency : 25 MHz, 1 sample per bit, 0 tolerance %
                     705   ; **  maximum tolerated propagation delay : 4450 ns
                     706   ; **  minimum requested propagation delay : 500 ns
                     707   ; **
                     708   ; **  https://www.kvaser.com/support/calculators/bit-timing-calculator/
                     709   ; **  T1 	T2 	BTQ 	SP% 	SJW 	BIT RATE 	ERR% 	BTR0 	BTR1
                     710   ; **  17	8	25	    68	     1	      100	    0	      04	7f
                     711   ; */
                     712   ; /*
                     713   ; Can Transceiver - controls logic level signals from can controller to physical ones
                     714   ; Can Controller - controls the logic level signals from the microcontroller to the transceive
                     715   ; Enters sleep mode:
                     716   ; - no bus activity
                     717   ; - no interrupt pending
                     718   ; */
                     719   ; // initialisation for Can controller 0
                     720   ; void Init_CanBus_Controller0(void)
                     721   ; {
                     722   _Init_CanBus_Controller0:
                     723   ; // TODO - put your Canbus initialisation code for CanController 0 here
                     724   ; // See section 4.2.1 in the application note for details (PELICAN MODE)
                     725   ; // This should just be the configuration of the registers of the SJA1000 controller
                     726   ; // It is assumed that after power-on, the CAN controller gets a reset pulse at pin 17
                     727   ; // Before setting up registers, we should check the reset/request mode flag before writing anything
                     728   ; // Init Process:
                     729   ; // Configure clock divider for PeliCAN, clk_out disabled
                     730   ; // internal comperator should be bypassed (I THINK)
                     731   ; // TX1 Output Config should be set to 0 since we're sending TX message from controller to transeiver 
                     732   ; // Configure acceptance code and mask registers
                     733   ; // COnfigure bus timing registers
                     734   ; // Configure output control register
                     735   ; // Enter operating mode
                     736   ; // Poll to check if we exited reset mode AKA in normal mode, 
                     737   ; //        if not go back to before entering operating mode
                     738   ; // Enable can interrupts if used (not sure tbh)
                     739   ; // INTERRUPT do later
                     740   ; /* disable interrupts, if used (not necessary after power-on) */
                     741   ; //EA = DISABLE; /* disable all interrupts */
                     742   ; //SJAIntEn = DISABLE; /* disable external interrupt from SJA1000 */
                     743   ; while((Can0_ModeControlReg & RM_RR_Bit ) == ClrByte)
                     744   Init_CanBus_Controller0_1:
00000932  1039 0050  745          move.b    5242880,D0
00000936  0000      
00000938  C03C 0001  746          and.b     #1,D0
0000093C  6612       747          bne.s     Init_CanBus_Controller0_3
                     748   ; {
                     749   ; /* other bits than the reset mode/request bit are unchanged */
                     750   ; Can0_ModeControlReg = Can0_ModeControlReg | RM_RR_Bit ;
0000093E  1039 0050  751          move.b    5242880,D0
00000942  0000      
00000944  803C 0001  752          or.b      #1,D0
00000948  13C0 0050  753          move.b    D0,5242880
0000094C  0000      
0000094E  60E2       754          bra       Init_CanBus_Controller0_1
                     755   Init_CanBus_Controller0_3:
                     756   ; }
                     757   ; Can0_ClockDivideReg = CANMode_Bit | CBP_Bit | DivBy2;
00000950  13FC 00C0  758          move.b    #192,5242942
00000954  0050 003E 
                     759   ; Can0_InterruptEnReg = ClrIntEnSJA; // disable all interrupts
00000958  4239 0050  760          clr.b     5242888
0000095C  0008      
                     761   ; Can0_AcceptCode0Reg = ClrByte; // clear acceptance code registers
0000095E  4239 0050  762          clr.b     5242912
00000962  0020      
                     763   ; Can0_AcceptCode1Reg = ClrByte;
00000964  4239 0050  764          clr.b     5242914
00000968  0022      
                     765   ; Can0_AcceptCode2Reg = ClrByte;
0000096A  4239 0050  766          clr.b     5242916
0000096E  0024      
                     767   ; Can0_AcceptCode3Reg = ClrByte;
00000970  4239 0050  768          clr.b     5242918
00000974  0026      
                     769   ; Can0_AcceptMask0Reg = ClrByte; // clear acceptance mask registers
00000976  4239 0050  770          clr.b     5242920
0000097A  0028      
                     771   ; Can0_AcceptMask1Reg = ClrByte;
0000097C  4239 0050  772          clr.b     5242922
00000980  002A      
                     773   ; Can0_AcceptMask2Reg = ClrByte;
00000982  4239 0050  774          clr.b     5242924
00000986  002C      
                     775   ; Can0_AcceptMask3Reg = ClrByte;
00000988  4239 0050  776          clr.b     5242926
0000098C  002E      
                     777   ; //25
                     778   ; Can0_BusTiming0Reg = 0x04;
0000098E  13FC 0004  779          move.b    #4,5242892
00000992  0050 000C 
                     780   ; Can0_BusTiming1Reg = 0x7f;
00000996  13FC 007F  781          move.b    #127,5242894
0000099A  0050 000E 
                     782   ; //45
                     783   ; Can0_BusTiming0Reg = 0x08;
0000099E  13FC 0008  784          move.b    #8,5242892
000009A2  0050 000C 
                     785   ; Can0_BusTiming1Reg = 0x7f;
000009A6  13FC 007F  786          move.b    #127,5242894
000009AA  0050 000E 
                     787   ; Can0_OutControlReg = Tx1Float | Tx0PshPull | NormalMode;
000009AE  13FC 001A  788          move.b    #26,5242896
000009B2  0050 0010 
                     789   ; do {
                     790   Init_CanBus_Controller0_4:
                     791   ; Can0_ModeControlReg = ClrByte;
000009B6  4239 0050  792          clr.b     5242880
000009BA  0000      
000009BC  1039 0050  793          move.b    5242880,D0
000009C0  0000      
000009C2  C03C 0001  794          and.b     #1,D0
000009C6  66EE       795          bne       Init_CanBus_Controller0_4
000009C8  4E75       796          rts
                     797   ; } while ((Can0_ModeControlReg & RM_RR_Bit) != ClrByte); // wait until reset mode bit is cleared
                     798   ; // INTERRUPT do later
                     799   ; //SJAIntEn = ENABLE; /* enable external interrupt from SJA1000 */
                     800   ; //EA = ENABLE; /* enable all interrupts
                     801   ; }
                     802   ; // initialisation for Can controller 1
                     803   ; void Init_CanBus_Controller1(void)
                     804   ; {
                     805   _Init_CanBus_Controller1:
                     806   ; // TODO - put your Canbus initialisation code for CanController 1 here
                     807   ; // See section 4.2.1 in the application note for details (PELICAN MODE)
                     808   ; // INTERRUPT do later
                     809   ; /* disable interrupts, if used (not necessary after power-on) */
                     810   ; //EA = DISABLE; /* disable all interrupts */
                     811   ; //SJAIntEn = DISABLE; /* disable external interrupt from SJA1000 */
                     812   ; while((Can1_ModeControlReg & RM_RR_Bit ) == ClrByte)
                     813   Init_CanBus_Controller1_1:
000009CA  1039 0050  814          move.b    5243392,D0
000009CE  0200      
000009D0  C03C 0001  815          and.b     #1,D0
000009D4  6612       816          bne.s     Init_CanBus_Controller1_3
                     817   ; {
                     818   ; /* other bits than the reset mode/request bit are unchanged */
                     819   ; Can1_ModeControlReg = Can1_ModeControlReg | RM_RR_Bit ;
000009D6  1039 0050  820          move.b    5243392,D0
000009DA  0200      
000009DC  803C 0001  821          or.b      #1,D0
000009E0  13C0 0050  822          move.b    D0,5243392
000009E4  0200      
000009E6  60E2       823          bra       Init_CanBus_Controller1_1
                     824   Init_CanBus_Controller1_3:
                     825   ; }
                     826   ; Can1_ClockDivideReg = CANMode_Bit | CBP_Bit | DivBy2;
000009E8  13FC 00C0  827          move.b    #192,5243454
000009EC  0050 023E 
                     828   ; Can1_InterruptEnReg = ClrIntEnSJA; // disable all interrupts
000009F0  4239 0050  829          clr.b     5243400
000009F4  0208      
                     830   ; Can1_AcceptCode0Reg = ClrByte; // clear acceptance code registers
000009F6  4239 0050  831          clr.b     5243424
000009FA  0220      
                     832   ; Can1_AcceptCode1Reg = ClrByte;
000009FC  4239 0050  833          clr.b     5243426
00000A00  0222      
                     834   ; Can1_AcceptCode2Reg = ClrByte;
00000A02  4239 0050  835          clr.b     5243428
00000A06  0224      
                     836   ; Can1_AcceptCode3Reg = ClrByte;
00000A08  4239 0050  837          clr.b     5243430
00000A0C  0226      
                     838   ; Can1_AcceptMask0Reg = ClrByte; // clear acceptance mask registers
00000A0E  4239 0050  839          clr.b     5243432
00000A12  0228      
                     840   ; Can1_AcceptMask1Reg = ClrByte;
00000A14  4239 0050  841          clr.b     5243434
00000A18  022A      
                     842   ; Can1_AcceptMask2Reg = ClrByte;
00000A1A  4239 0050  843          clr.b     5243436
00000A1E  022C      
                     844   ; Can1_AcceptMask3Reg = ClrByte;
00000A20  4239 0050  845          clr.b     5243438
00000A24  022E      
                     846   ; //25
                     847   ; Can1_BusTiming0Reg = 0x04;
00000A26  13FC 0004  848          move.b    #4,5243404
00000A2A  0050 020C 
                     849   ; Can1_BusTiming1Reg = 0x7f;
00000A2E  13FC 007F  850          move.b    #127,5243406
00000A32  0050 020E 
                     851   ; //45
                     852   ; Can1_BusTiming0Reg = 0x08;
00000A36  13FC 0008  853          move.b    #8,5243404
00000A3A  0050 020C 
                     854   ; Can1_BusTiming1Reg = 0x7f;
00000A3E  13FC 007F  855          move.b    #127,5243406
00000A42  0050 020E 
                     856   ; Can1_OutControlReg = Tx1Float | Tx0PshPull | NormalMode;
00000A46  13FC 001A  857          move.b    #26,5243408
00000A4A  0050 0210 
                     858   ; do {
                     859   Init_CanBus_Controller1_4:
                     860   ; Can1_ModeControlReg = ClrByte;
00000A4E  4239 0050  861          clr.b     5243392
00000A52  0200      
00000A54  1039 0050  862          move.b    5243392,D0
00000A58  0200      
00000A5A  C03C 0001  863          and.b     #1,D0
00000A5E  66EE       864          bne       Init_CanBus_Controller1_4
00000A60  4E75       865          rts
                     866   ; } while ((Can1_ModeControlReg & RM_RR_Bit) != ClrByte); // wait until reset mode bit is cleared
                     867   ; // INTERRUPT do later
                     868   ; //SJAIntEn = ENABLE; /* enable external interrupt from SJA1000 */
                     869   ; //EA = ENABLE; /* enable all interrupts
                     870   ; }
                     871   ; /*
                     872   ; Has to transmit into transfer buffer and set Transmit Request flag in cmd register
                     873   ; request: transmit a message
                     874   ; is transmit buffer released?
                     875   ; if yes:
                     876   ; write into transmit buffer
                     877   ; set transmit request bit (TR) in command register
                     878   ; if no: 
                     879   ; poll status register until transmit buffer is released
                     880   ; temporary storage of message to be transmitted
                     881   ; set flag "further message"
                     882   ; When transmitting, transmit buffer is locked
                     883   ; */
                     884   ; // Transmit for sending a message via Can controller 0
                     885   ; void CanBus0_Transmit(void)
                     886   ; {
                     887   _CanBus0_Transmit:
                     888   ; // TODO - put your Canbus transmit code for CanController 0 here
                     889   ; // See section 4.2.2 in the application note for details (PELICAN MODE)
                     890   ; do
                     891   ; {
                     892   CanBus0_Transmit_1:
                     893   ; /* start a polling timer and run some tasks while waiting
                     894   ; break the loop and signal an error if time too long */
                     895   ; } while((Can0_StatusReg & TBS_Bit ) != TBS_Bit );
00000A62  1039 0050  896          move.b    5242884,D0
00000A66  0004      
00000A68  C03C 0004  897          and.b     #4,D0
00000A6C  0C00 0004  898          cmp.b     #4,D0
00000A70  66F0       899          bne       CanBus0_Transmit_1
                     900   ; /* Transmit Buffer is released, a message may be written into the buffer */
                     901   ; /* in this example a Standard Frame message shall be transmitted */
                     902   ; Can0_TxFrameInfo = 0x08; /* SFF (data), DLC=8 */
00000A72  13FC 0008  903          move.b    #8,5242912
00000A76  0050 0020 
                     904   ; Can0_TxBuffer1 = 0xA5; /* ID1 = A5, (1010 0101) */
00000A7A  13FC 00A5  905          move.b    #165,5242914
00000A7E  0050 0022 
                     906   ; Can0_TxBuffer2 = 0x20; /* ID2 = 20, (0010 0000) */
00000A82  13FC 0020  907          move.b    #32,5242916
00000A86  0050 0024 
                     908   ; Can0_TxBuffer3 = 0x51; /* data1 = 51 */
00000A8A  13FC 0051  909          move.b    #81,5242918
00000A8E  0050 0026 
                     910   ; Can0_TxBuffer4 = 0x52; /* data2 = 52 */
00000A92  13FC 0052  911          move.b    #82,5242920
00000A96  0050 0028 
                     912   ; Can0_TxBuffer5 = 0x53; /* data3 = 53 */
00000A9A  13FC 0053  913          move.b    #83,5242922
00000A9E  0050 002A 
                     914   ; Can0_TxBuffer6 = 0x54; /* data4 = 54 */
00000AA2  13FC 0054  915          move.b    #84,5242924
00000AA6  0050 002C 
                     916   ; Can0_TxBuffer7 = 0x55; /* data5 = 55 */
00000AAA  13FC 0055  917          move.b    #85,5242926
00000AAE  0050 002E 
                     918   ; Can0_TxBuffer8 = 0x56; /* data6 = 56 */
00000AB2  13FC 0056  919          move.b    #86,5242928
00000AB6  0050 0030 
                     920   ; Can0_TxBuffer9 = 0x57; /* data7 = 57 */
00000ABA  13FC 0057  921          move.b    #87,5242930
00000ABE  0050 0032 
                     922   ; Can0_TxBuffer10 = 0x58; /* data8 = 58 */
00000AC2  13FC 0058  923          move.b    #88,5242932
00000AC6  0050 0034 
                     924   ; /* Start the transmission */
                     925   ; Can0_CommandReg = TR_Bit ; /* Set Transmission Request bit */
00000ACA  13FC 0001  926          move.b    #1,5242882
00000ACE  0050 0002 
00000AD2  4E75       927          rts
                     928   ; }
                     929   ; // Transmit for sending a message via Can controller 1
                     930   ; void CanBus1_Transmit(void)
                     931   ; {
                     932   _CanBus1_Transmit:
                     933   ; // TODO - put your Canbus transmit code for CanController 1 here
                     934   ; // See section 4.2.2 in the application note for details (PELICAN MODE)
                     935   ; do
                     936   ; {
                     937   CanBus1_Transmit_1:
                     938   ; /* start a polling timer and run some tasks while waiting
                     939   ; break the loop and signal an error if time too long */
                     940   ; } while((Can1_StatusReg & TBS_Bit) != TBS_Bit);
00000AD4  1039 0050  941          move.b    5243396,D0
00000AD8  0204      
00000ADA  C03C 0004  942          and.b     #4,D0
00000ADE  0C00 0004  943          cmp.b     #4,D0
00000AE2  66F0       944          bne       CanBus1_Transmit_1
                     945   ; /* Transmit Buffer is released, a message may be written into the buffer */
                     946   ; /* in this example a Standard Frame message shall be transmitted */
                     947   ; Can1_TxFrameInfo = 0x08; /* SFF (data), DLC=8 */
00000AE4  13FC 0008  948          move.b    #8,5243424
00000AE8  0050 0220 
                     949   ; Can1_TxBuffer1 = 0xA5; /* ID1 = A5, (1010 0101) */
00000AEC  13FC 00A5  950          move.b    #165,5243426
00000AF0  0050 0222 
                     951   ; Can1_TxBuffer2 = 0x20; /* ID2 = 20, (0010 0000) */
00000AF4  13FC 0020  952          move.b    #32,5243428
00000AF8  0050 0224 
                     953   ; Can1_TxBuffer3 = 0x51; /* data1 = 51 */
00000AFC  13FC 0051  954          move.b    #81,5243430
00000B00  0050 0226 
                     955   ; Can1_TxBuffer4 = 0x52; /* data2 = 52 */
00000B04  13FC 0052  956          move.b    #82,5243432
00000B08  0050 0228 
                     957   ; Can1_TxBuffer5 = 0x53; /* data3 = 53 */
00000B0C  13FC 0053  958          move.b    #83,5243434
00000B10  0050 022A 
                     959   ; Can1_TxBuffer6 = 0x54; /* data4 = 54 */
00000B14  13FC 0054  960          move.b    #84,5243436
00000B18  0050 022C 
                     961   ; Can1_TxBuffer7 = 0x55; /* data5 = 55 */
00000B1C  13FC 0055  962          move.b    #85,5243438
00000B20  0050 022E 
                     963   ; Can1_TxBuffer8 = 0x56; /* data6 = 56 */
00000B24  13FC 0056  964          move.b    #86,5243440
00000B28  0050 0230 
                     965   ; Can1_TxBuffer9 = 0x57; /* data7 = 57 */
00000B2C  13FC 0057  966          move.b    #87,5243442
00000B30  0050 0232 
                     967   ; Can1_TxBuffer10 = 0x58; /* data8 = 58 */
00000B34  13FC 0058  968          move.b    #88,5243444
00000B38  0050 0234 
                     969   ; /* Start the transmission */
                     970   ; Can1_CommandReg = TR_Bit; /* Set Transmission Request bit */
00000B3C  13FC 0001  971          move.b    #1,5243394
00000B40  0050 0202 
00000B44  4E75       972          rts
                     973   ; }
                     974   ; // Receive for reading a received message via Can controller 0
                     975   ; void CanBus0_Receive(void)
                     976   ; {
                     977   _CanBus0_Receive:
00000B46  4E75       978          rts
                     979   ; // TODO - put your Canbus receive code for CanController 0 here
                     980   ; // See section 4.2.4 in the application note for details (PELICAN MODE)
                     981   ; }
                     982   ; // Receive for reading a received message via Can controller 1
                     983   ; void CanBus1_Receive(void)
                     984   ; {
                     985   _CanBus1_Receive:
00000B48  4E75       986          rts
                     987   ; // TODO - put your Canbus receive code for CanController 1 here
                     988   ; // See section 4.2.4 in the application note for details (PELICAN MODE)
                     989   ; }
                     990   ; void delay(void)
                     991   ; {
                     992   _delay:
00000B4A  4E75       993          rts
                     994   ; // TODO - put your delay code here
                     995   ; // This is a simple delay routine for 1/2 second
                     996   ; // You can use a loop or a timer to create the delay
                     997   ; }
                     998   ; void CanBusTest(void)
                     999   ; {
                    1000   _CanBusTest:
00000B4C  2F0A      1001          move.l    A2,-(A7)
00000B4E  45F9 0000 1002          lea       _printf.L,A2
00000B52  3C28      
                    1003   ; // initialise the two Can controllers
                    1004   ; Init_CanBus_Controller0();
00000B54  4EB8 0932 1005          jsr       _Init_CanBus_Controller0
                    1006   ; Init_CanBus_Controller1();
00000B58  4EB8 09CA 1007          jsr       _Init_CanBus_Controller1
                    1008   ; printf("\r\n\r\n---- CANBUS Test ----\r\n") ;
00000B5C  4879 0000 1009          pea       @canbus~1_1.L
00000B60  50A8      
00000B62  4E92      1010          jsr       (A2)
00000B64  584F      1011          addq.w    #4,A7
                    1012   ; // simple application to alternately transmit and receive messages from each of two nodes
                    1013   ; while(1)    {
                    1014   CanBusTest_1:
                    1015   ; delay();                    // write a routine to delay say 1/2 second so we don't flood the network with messages to0 quickly
00000B66  4EB8 0B4A 1016          jsr       _delay
                    1017   ; CanBus0_Transmit() ;       // transmit a message via Controller 0
00000B6A  4EB8 0A62 1018          jsr       _CanBus0_Transmit
                    1019   ; CanBus1_Receive() ;        // receive a message via Controller 1 (and display it)
00000B6E  4EB8 0B48 1020          jsr       _CanBus1_Receive
                    1021   ; printf("\r\n") ;
00000B72  4879 0000 1022          pea       @canbus~1_2.L
00000B76  50C4      
00000B78  4E92      1023          jsr       (A2)
00000B7A  584F      1024          addq.w    #4,A7
                    1025   ; delay();                    // write a routine to delay say 1/2 second so we don't flood the network with messages to0 quickly
00000B7C  4EB8 0B4A 1026          jsr       _delay
                    1027   ; CanBus1_Transmit() ;        // transmit a message via Controller 1
00000B80  4EB8 0AD4 1028          jsr       _CanBus1_Transmit
                    1029   ; CanBus0_Receive() ;         // receive a message via Controller 0 (and display it)
00000B84  4EB8 0B46 1030          jsr       _CanBus0_Receive
                    1031   ; printf("\r\n") ;
00000B88  4879 0000 1032          pea       @canbus~1_2.L
00000B8C  50C4      
00000B8E  4E92      1033          jsr       (A2)
00000B90  584F      1034          addq.w    #4,A7
00000B92  60D2      1035          bra       CanBusTest_1
                    1036   ; }
                    1037   ; }
                    1038   ; C:\M68KV6.0 - 800BY480\PROGRAMS\DEBUGMONITORCODE\M68KDEBUG (NO DISASSEMBLER).C - Compiled by CC68K  Version 5.00 (c) 1991-2005  Peter J. Fondse
                    1039   ; #include "DebugMonitor.h"
                    1040   ; // use 08030000 for a system running from sram or 0B000000 for system running from dram
                    1041   ; // #define StartOfExceptionVectorTable 0x08030000
                    1042   ; #define StartOfExceptionVectorTable 0x0B000000
                    1043   ; // use 0C000000 for dram or hex 08040000 for sram
                    1044   ; //#define TopOfStack 0x08040000
                    1045   ; #define TopOfStack 0x0C000000
                    1046   ; /* DO NOT INITIALISE GLOBAL VARIABLES - DO IT in MAIN() */
                    1047   ; unsigned int i, x, y, z, PortA_Count;
                    1048   ; int     Trace, GoFlag, Echo;                       // used in tracing/single stepping
                    1049   ; // 68000 register dump and preintialise value (these can be changed by the user program when it is running, e.g. stack pointer, registers etc
                    1050   ; unsigned int d0,d1,d2,d3,d4,d5,d6,d7 ;
                    1051   ; unsigned int a0,a1,a2,a3,a4,a5,a6 ;
                    1052   ; unsigned int PC, SSP, USP ;
                    1053   ; unsigned short int SR;
                    1054   ; // Breakpoint variables
                    1055   ; unsigned int BreakPointAddress[8];                      //array of 8 breakpoint addresses
                    1056   ; unsigned short int BreakPointInstruction[8] ;           // to hold the instruction opcode at the breakpoint
                    1057   ; unsigned int BreakPointSetOrCleared[8] ;
                    1058   ; unsigned int InstructionSize ;
                    1059   ; // watchpoint variables
                    1060   ; unsigned int WatchPointAddress[8];                      //array of 8 breakpoint addresses
                    1061   ; unsigned int WatchPointSetOrCleared[8] ;
                    1062   ; char WatchPointString[8][100] ;
                    1063   ; char    TempString[100] ;
                    1064   ; /************************************************************************************
                    1065   ; *Subroutine to give the 68000 something useless to do to waste 1 mSec
                    1066   ; ************************************************************************************/
                    1067   ; void Wait1ms(void)
                    1068   ; {
                    1069   _Wait1ms:
00000B94  2F02      1070          move.l    D2,-(A7)
                    1071   ; long int  i ;
                    1072   ; for(i = 0; i < 1000; i ++)
00000B96  4282      1073          clr.l     D2
                    1074   Wait1ms_1:
00000B98  0C82 0000 1075          cmp.l     #1000,D2
00000B9C  03E8      
00000B9E  6C04      1076          bge.s     Wait1ms_3
00000BA0  5282      1077          addq.l    #1,D2
00000BA2  60F4      1078          bra       Wait1ms_1
                    1079   Wait1ms_3:
00000BA4  241F      1080          move.l    (A7)+,D2
00000BA6  4E75      1081          rts
                    1082   ; ;
                    1083   ; }
                    1084   ; /************************************************************************************
                    1085   ; *Subroutine to give the 68000 something useless to do to waste 3 mSec
                    1086   ; **************************************************************************************/
                    1087   ; void Wait3ms(void)
                    1088   ; {
                    1089   _Wait3ms:
00000BA8  2F02      1090          move.l    D2,-(A7)
                    1091   ; int i ;
                    1092   ; for(i = 0; i < 3; i++)
00000BAA  4282      1093          clr.l     D2
                    1094   Wait3ms_1:
00000BAC  0C82 0000 1095          cmp.l     #3,D2
00000BB0  0003      
00000BB2  6C08      1096          bge.s     Wait3ms_3
                    1097   ; Wait1ms() ;
00000BB4  4EB8 0B94 1098          jsr       _Wait1ms
00000BB8  5282      1099          addq.l    #1,D2
00000BBA  60F0      1100          bra       Wait3ms_1
                    1101   Wait3ms_3:
00000BBC  241F      1102          move.l    (A7)+,D2
00000BBE  4E75      1103          rts
                    1104   ; }
                    1105   ; /*********************************************************************************************
                    1106   ; *Subroutine to initialise the display by writing some commands to the LCD internal registers
                    1107   ; *********************************************************************************************/
                    1108   ; void Init_LCD(void)
                    1109   ; {
                    1110   _Init_LCD:
                    1111   ; LCDcommand = (char)(0x0c) ;
00000BC0  13FC 000C 1112          move.b    #12,4194336
00000BC4  0040 0020 
                    1113   ; Wait3ms() ;
00000BC8  4EB8 0BA8 1114          jsr       _Wait3ms
                    1115   ; LCDcommand = (char)(0x38) ;
00000BCC  13FC 0038 1116          move.b    #56,4194336
00000BD0  0040 0020 
                    1117   ; Wait3ms() ;
00000BD4  4EB8 0BA8 1118          jsr       _Wait3ms
00000BD8  4E75      1119          rts
                    1120   ; }
                    1121   ; /******************************************************************************
                    1122   ; *subroutine to output a single character held in d1 to the LCD display
                    1123   ; *it is assumed the character is an ASCII code and it will be displayed at the
                    1124   ; *current cursor position
                    1125   ; *******************************************************************************/
                    1126   ; void Outchar(int c)
                    1127   ; {
                    1128   _Outchar:
00000BDA  4E56 0000 1129          link      A6,#0
                    1130   ; LCDdata = (char)(c);
00000BDE  202E 0008 1131          move.l    8(A6),D0
00000BE2  13C0 0040 1132          move.b    D0,4194338
00000BE6  0022      
                    1133   ; Wait1ms() ;
00000BE8  4EB8 0B94 1134          jsr       _Wait1ms
00000BEC  4E5E      1135          unlk      A6
00000BEE  4E75      1136          rts
                    1137   ; }
                    1138   ; /**********************************************************************************
                    1139   ; *subroutine to output a message at the current cursor position of the LCD display
                    1140   ; ************************************************************************************/
                    1141   ; void OutMess(char *theMessage)
                    1142   ; {
                    1143   _OutMess:
00000BF0  4E56 FFFC 1144          link      A6,#-4
                    1145   ; char c ;
                    1146   ; while((c = *theMessage++) != (char)(0))
                    1147   OutMess_1:
00000BF4  206E 0008 1148          move.l    8(A6),A0
00000BF8  52AE 0008 1149          addq.l    #1,8(A6)
00000BFC  1D50 FFFF 1150          move.b    (A0),-1(A6)
00000C00  1010      1151          move.b    (A0),D0
00000C02  6712      1152          beq.s     OutMess_3
                    1153   ; Outchar(c) ;
00000C04  122E FFFF 1154          move.b    -1(A6),D1
00000C08  4881      1155          ext.w     D1
00000C0A  48C1      1156          ext.l     D1
00000C0C  2F01      1157          move.l    D1,-(A7)
00000C0E  4EB8 0BDA 1158          jsr       _Outchar
00000C12  584F      1159          addq.w    #4,A7
00000C14  60DE      1160          bra       OutMess_1
                    1161   OutMess_3:
00000C16  4E5E      1162          unlk      A6
00000C18  4E75      1163          rts
                    1164   ; }
                    1165   ; /******************************************************************************
                    1166   ; *subroutine to clear the line by issuing 24 space characters
                    1167   ; *******************************************************************************/
                    1168   ; void Clearln(void)
                    1169   ; {
                    1170   _Clearln:
00000C1A  2F02      1171          move.l    D2,-(A7)
                    1172   ; unsigned char i ;
                    1173   ; for(i = 0; i < 24; i ++)
00000C1C  4202      1174          clr.b     D2
                    1175   Clearln_1:
00000C1E  0C02 0018 1176          cmp.b     #24,D2
00000C22  640E      1177          bhs.s     Clearln_3
                    1178   ; Outchar(' ') ;  /* write a space char to the LCD display */
00000C24  4878 0020 1179          pea       32
00000C28  4EB8 0BDA 1180          jsr       _Outchar
00000C2C  584F      1181          addq.w    #4,A7
00000C2E  5202      1182          addq.b    #1,D2
00000C30  60EC      1183          bra       Clearln_1
                    1184   Clearln_3:
00000C32  241F      1185          move.l    (A7)+,D2
00000C34  4E75      1186          rts
                    1187   ; }
                    1188   ; /******************************************************************************
                    1189   ; *subroutine to move the cursor to the start of line 1 and clear that line
                    1190   ; *******************************************************************************/
                    1191   ; void Oline0(char *theMessage)
                    1192   ; {
                    1193   _Oline0:
00000C36  4E56 0000 1194          link      A6,#0
                    1195   ; LCDcommand = (char)(0x80) ;
00000C3A  13FC 0080 1196          move.b    #128,4194336
00000C3E  0040 0020 
                    1197   ; Wait3ms();
00000C42  4EB8 0BA8 1198          jsr       _Wait3ms
                    1199   ; Clearln() ;
00000C46  4EB8 0C1A 1200          jsr       _Clearln
                    1201   ; LCDcommand = (char)(0x80) ;
00000C4A  13FC 0080 1202          move.b    #128,4194336
00000C4E  0040 0020 
                    1203   ; Wait3ms() ;
00000C52  4EB8 0BA8 1204          jsr       _Wait3ms
                    1205   ; OutMess(theMessage) ;
00000C56  2F2E 0008 1206          move.l    8(A6),-(A7)
00000C5A  4EB8 0BF0 1207          jsr       _OutMess
00000C5E  584F      1208          addq.w    #4,A7
00000C60  4E5E      1209          unlk      A6
00000C62  4E75      1210          rts
                    1211   ; }
                    1212   ; /******************************************************************************
                    1213   ; *subroutine to move the cursor to the start of line 2 and clear that line
                    1214   ; *******************************************************************************/
                    1215   ; void Oline1(char *theMessage)
                    1216   ; {
                    1217   _Oline1:
00000C64  4E56 0000 1218          link      A6,#0
                    1219   ; LCDcommand = (char)(0xC0) ;
00000C68  13FC 00C0 1220          move.b    #192,4194336
00000C6C  0040 0020 
                    1221   ; Wait3ms();
00000C70  4EB8 0BA8 1222          jsr       _Wait3ms
                    1223   ; Clearln() ;
00000C74  4EB8 0C1A 1224          jsr       _Clearln
                    1225   ; LCDcommand = (char)(0xC0) ;
00000C78  13FC 00C0 1226          move.b    #192,4194336
00000C7C  0040 0020 
                    1227   ; Wait3ms() ;
00000C80  4EB8 0BA8 1228          jsr       _Wait3ms
                    1229   ; OutMess(theMessage) ;
00000C84  2F2E 0008 1230          move.l    8(A6),-(A7)
00000C88  4EB8 0BF0 1231          jsr       _OutMess
00000C8C  584F      1232          addq.w    #4,A7
00000C8E  4E5E      1233          unlk      A6
00000C90  4E75      1234          rts
                    1235   ; }
                    1236   ; void InstallExceptionHandler( void (*function_ptr)(), int level)
                    1237   ; {
                    1238   _InstallExceptionHandler:
00000C92  4E56 FFFC 1239          link      A6,#-4
                    1240   ; volatile long int *RamVectorAddress = (volatile long int *)(StartOfExceptionVectorTable) ;   // pointer to the Ram based interrupt vector table created in Cstart in debug monitor
00000C96  2D7C 0B00 1241          move.l    #184549376,-4(A6)
00000C9A  0000 FFFC 
                    1242   ; RamVectorAddress[level] = (long int *)(function_ptr);
00000C9E  206E FFFC 1243          move.l    -4(A6),A0
00000CA2  202E 000C 1244          move.l    12(A6),D0
00000CA6  E588      1245          lsl.l     #2,D0
00000CA8  21AE 0008 1246          move.l    8(A6),0(A0,D0.L)
00000CAC  0800      
00000CAE  4E5E      1247          unlk      A6
00000CB0  4E75      1248          rts
                    1249   ; }
                    1250   ; void TestLEDS(void)
                    1251   ; {
                    1252   _TestLEDS:
00000CB2  48E7 3000 1253          movem.l   D2/D3,-(A7)
                    1254   ; int delay ;
                    1255   ; unsigned char count = 0 ;
00000CB6  4202      1256          clr.b     D2
                    1257   ; while(1)    {
                    1258   TestLEDS_1:
                    1259   ; PortA = PortB = PortC = PortD = HEX_A = HEX_B = HEX_C = HEX_D = ((count << 4) + (count & 0x0f)) ;
00000CB8  1002      1260          move.b    D2,D0
00000CBA  E908      1261          lsl.b     #4,D0
00000CBC  1202      1262          move.b    D2,D1
00000CBE  C23C 000F 1263          and.b     #15,D1
00000CC2  D001      1264          add.b     D1,D0
00000CC4  13C0 0040 1265          move.b    D0,4194326
00000CC8  0016      
00000CCA  13C0 0040 1266          move.b    D0,4194324
00000CCE  0014      
00000CD0  13C0 0040 1267          move.b    D0,4194322
00000CD4  0012      
00000CD6  13C0 0040 1268          move.b    D0,4194320
00000CDA  0010      
00000CDC  13C0 0040 1269          move.b    D0,4194310
00000CE0  0006      
00000CE2  13C0 0040 1270          move.b    D0,4194308
00000CE6  0004      
00000CE8  13C0 0040 1271          move.b    D0,4194306
00000CEC  0002      
00000CEE  13C0 0040 1272          move.b    D0,4194304
00000CF2  0000      
                    1273   ; for(delay = 0; delay < 200000; delay ++)
00000CF4  4283      1274          clr.l     D3
                    1275   TestLEDS_4:
00000CF6  0C83 0003 1276          cmp.l     #200000,D3
00000CFA  0D40      
00000CFC  6C04      1277          bge.s     TestLEDS_6
00000CFE  5283      1278          addq.l    #1,D3
00000D00  60F4      1279          bra       TestLEDS_4
                    1280   TestLEDS_6:
                    1281   ; ;
                    1282   ; count ++;
00000D02  5202      1283          addq.b    #1,D2
00000D04  60B2      1284          bra       TestLEDS_1
                    1285   ; }
                    1286   ; }
                    1287   ; void SwitchTest(void)
                    1288   ; {
                    1289   _SwitchTest:
00000D06  48E7 3020 1290          movem.l   D2/D3/A2,-(A7)
00000D0A  45F9 0000 1291          lea       _printf.L,A2
00000D0E  3C28      
                    1292   ; int i, switches = 0 ;
00000D10  4283      1293          clr.l     D3
                    1294   ; printf("\r\n") ;
00000D12  4879 0000 1295          pea       @m68kde~1_1.L
00000D16  50C8      
00000D18  4E92      1296          jsr       (A2)
00000D1A  584F      1297          addq.w    #4,A7
                    1298   ; while(1)    {
                    1299   SwitchTest_1:
                    1300   ; switches = (PortB << 8) | (PortA) ;
00000D1C  1039 0040 1301          move.b    4194306,D0
00000D20  0002      
00000D22  C0BC 0000 1302          and.l     #255,D0
00000D26  00FF      
00000D28  E188      1303          lsl.l     #8,D0
00000D2A  1239 0040 1304          move.b    4194304,D1
00000D2E  0000      
00000D30  C2BC 0000 1305          and.l     #255,D1
00000D34  00FF      
00000D36  8081      1306          or.l      D1,D0
00000D38  2600      1307          move.l    D0,D3
                    1308   ; printf("\rSwitches SW[7-0] = ") ;
00000D3A  4879 0000 1309          pea       @m68kde~1_2.L
00000D3E  50CC      
00000D40  4E92      1310          jsr       (A2)
00000D42  584F      1311          addq.w    #4,A7
                    1312   ; for( i = (int)(0x00000080); i > 0; i = i >> 1)  {
00000D44  243C 0000 1313          move.l    #128,D2
00000D48  0080      
                    1314   SwitchTest_4:
00000D4A  0C82 0000 1315          cmp.l     #0,D2
00000D4E  0000      
00000D50  6F20      1316          ble.s     SwitchTest_6
                    1317   ; if((switches & i) == 0)
00000D52  2003      1318          move.l    D3,D0
00000D54  C082      1319          and.l     D2,D0
00000D56  660C      1320          bne.s     SwitchTest_7
                    1321   ; printf("0") ;
00000D58  4879 0000 1322          pea       @m68kde~1_3.L
00000D5C  50E2      
00000D5E  4E92      1323          jsr       (A2)
00000D60  584F      1324          addq.w    #4,A7
00000D62  600A      1325          bra.s     SwitchTest_8
                    1326   SwitchTest_7:
                    1327   ; else
                    1328   ; printf("1") ;
00000D64  4879 0000 1329          pea       @m68kde~1_4.L
00000D68  50E4      
00000D6A  4E92      1330          jsr       (A2)
00000D6C  584F      1331          addq.w    #4,A7
                    1332   SwitchTest_8:
00000D6E  E282      1333          asr.l     #1,D2
00000D70  60D8      1334          bra       SwitchTest_4
                    1335   SwitchTest_6:
00000D72  60A8      1336          bra       SwitchTest_1
                    1337   ; }
                    1338   ; }
                    1339   ; }
                    1340   ; /*********************************************************************************************
                    1341   ; *Subroutine to initialise the RS232 Port by writing some commands to the internal registers
                    1342   ; *********************************************************************************************/
                    1343   ; void Init_RS232(void)
                    1344   ; {
                    1345   _Init_RS232:
                    1346   ; RS232_Control = (char)(0x15) ; //  %00010101    divide by 16 clock, set rts low, 8 bits no parity, 1 stop bit transmitter interrupt disabled
00000D74  13FC 0015 1347          move.b    #21,4194368
00000D78  0040 0040 
                    1348   ; RS232_Baud = (char)(0x1) ;      // program baud rate generator 000 = 230k, 001 = 115k, 010 = 57.6k, 011 = 38.4k, 100 = 19.2, all others = 9600
00000D7C  13FC 0001 1349          move.b    #1,4194372
00000D80  0040 0044 
00000D84  4E75      1350          rts
                    1351   ; }
                    1352   ; int kbhit(void)
                    1353   ; {
                    1354   _kbhit:
                    1355   ; if(((char)(RS232_Status) & (char)(0x01)) == (char)(0x01))    // wait for Rx bit in status register to be '1'
00000D86  1039 0040 1356          move.b    4194368,D0
00000D8A  0040      
00000D8C  C03C 0001 1357          and.b     #1,D0
00000D90  0C00 0001 1358          cmp.b     #1,D0
00000D94  6604      1359          bne.s     kbhit_1
                    1360   ; return 1 ;
00000D96  7001      1361          moveq     #1,D0
00000D98  6002      1362          bra.s     kbhit_3
                    1363   kbhit_1:
                    1364   ; else
                    1365   ; return 0 ;
00000D9A  4280      1366          clr.l     D0
                    1367   kbhit_3:
00000D9C  4E75      1368          rts
                    1369   ; }
                    1370   ; /*********************************************************************************************************
                    1371   ; **  Subroutine to provide a low level output function to 6850 ACIA
                    1372   ; **  This routine provides the basic functionality to output a single character to the serial Port
                    1373   ; **  to allow the board to communicate with HyperTerminal Program
                    1374   ; **
                    1375   ; **  NOTE you do not call this function directly, instead you call the normal putchar() function
                    1376   ; **  which in turn calls _putch() below). Other functions like puts(), printf() call putchar() so will
                    1377   ; **  call _putch() also
                    1378   ; *********************************************************************************************************/
                    1379   ; int _putch( int c)
                    1380   ; {
                    1381   __putch:
00000D9E  4E56 0000 1382          link      A6,#0
                    1383   ; while(((char)(RS232_Status) & (char)(0x02)) != (char)(0x02))    // wait for Tx bit in status register or 6850 serial comms chip to be '1'
                    1384   _putch_1:
00000DA2  1039 0040 1385          move.b    4194368,D0
00000DA6  0040      
00000DA8  C03C 0002 1386          and.b     #2,D0
00000DAC  0C00 0002 1387          cmp.b     #2,D0
00000DB0  6702      1388          beq.s     _putch_3
00000DB2  60EE      1389          bra       _putch_1
                    1390   _putch_3:
                    1391   ; ;
                    1392   ; (char)(RS232_TxData) = ((char)(c) & (char)(0x7f));                      // write to the data register to output the character (mask off bit 8 to keep it 7 bit ASCII)
00000DB4  202E 0008 1393          move.l    8(A6),D0
00000DB8  C03C 007F 1394          and.b     #127,D0
00000DBC  13C0 0040 1395          move.b    D0,4194370
00000DC0  0042      
                    1396   ; return c ;                                              // putchar() expects the character to be returned
00000DC2  202E 0008 1397          move.l    8(A6),D0
00000DC6  4E5E      1398          unlk      A6
00000DC8  4E75      1399          rts
                    1400   ; }
                    1401   ; /*********************************************************************************************************
                    1402   ; **  Subroutine to provide a low level input function to 6850 ACIA
                    1403   ; **  This routine provides the basic functionality to input a single character from the serial Port
                    1404   ; **  to allow the board to communicate with HyperTerminal Program Keyboard (your PC)
                    1405   ; **
                    1406   ; **  NOTE you do not call this function directly, instead you call the normal _getch() function
                    1407   ; **  which in turn calls _getch() below). Other functions like gets(), scanf() call _getch() so will
                    1408   ; **  call _getch() also
                    1409   ; *********************************************************************************************************/
                    1410   ; int _getch( void )
                    1411   ; {
                    1412   __getch:
00000DCA  2F02      1413          move.l    D2,-(A7)
                    1414   ; int c ;
                    1415   ; while(((char)(RS232_Status) & (char)(0x01)) != (char)(0x01))    // wait for Rx bit in 6850 serial comms chip status register to be '1'
                    1416   _getch_1:
00000DCC  1039 0040 1417          move.b    4194368,D0
00000DD0  0040      
00000DD2  C03C 0001 1418          and.b     #1,D0
00000DD6  0C00 0001 1419          cmp.b     #1,D0
00000DDA  6702      1420          beq.s     _getch_3
00000DDC  60EE      1421          bra       _getch_1
                    1422   _getch_3:
                    1423   ; ;
                    1424   ; c = (RS232_RxData & (char)(0x7f));                   // read received character, mask off top bit and return as 7 bit ASCII character
00000DDE  1039 0040 1425          move.b    4194370,D0
00000DE2  0042      
00000DE4  C0BC 0000 1426          and.l     #255,D0
00000DE8  00FF      
00000DEA  C0BC 0000 1427          and.l     #127,D0
00000DEE  007F      
00000DF0  2400      1428          move.l    D0,D2
                    1429   ; // shall we echo the character? Echo is set to TRUE at reset, but for speed we don't want to echo when downloading code with the 'L' debugger command
                    1430   ; if(Echo)
00000DF2  4AB9 0B00 1431          tst.l     _Echo.L
00000DF6  00E0      
00000DF8  6708      1432          beq.s     _getch_4
                    1433   ; _putch(c);
00000DFA  2F02      1434          move.l    D2,-(A7)
00000DFC  4EB8 0D9E 1435          jsr       __putch
00000E00  584F      1436          addq.w    #4,A7
                    1437   _getch_4:
                    1438   ; return c ;
00000E02  2002      1439          move.l    D2,D0
00000E04  241F      1440          move.l    (A7)+,D2
00000E06  4E75      1441          rts
                    1442   ; }
                    1443   ; // flush the input stream for any unread characters
                    1444   ; void FlushKeyboard(void)
                    1445   ; {
                    1446   _FlushKeyboard:
00000E08  4E56 FFFC 1447          link      A6,#-4
                    1448   ; char c ;
                    1449   ; while(1)    {
                    1450   FlushKeyboard_1:
                    1451   ; if(((char)(RS232_Status) & (char)(0x01)) == (char)(0x01))    // if Rx bit in status register is '1'
00000E0C  1039 0040 1452          move.b    4194368,D0
00000E10  0040      
00000E12  C03C 0001 1453          and.b     #1,D0
00000E16  0C00 0001 1454          cmp.b     #1,D0
00000E1A  6610      1455          bne.s     FlushKeyboard_4
                    1456   ; c = ((char)(RS232_RxData) & (char)(0x7f)) ;
00000E1C  1039 0040 1457          move.b    4194370,D0
00000E20  0042      
00000E22  C03C 007F 1458          and.b     #127,D0
00000E26  1D40 FFFF 1459          move.b    D0,-1(A6)
00000E2A  6002      1460          bra.s     FlushKeyboard_5
                    1461   FlushKeyboard_4:
                    1462   ; else
                    1463   ; return ;
00000E2C  6002      1464          bra.s     FlushKeyboard_6
                    1465   FlushKeyboard_5:
00000E2E  60DC      1466          bra       FlushKeyboard_1
                    1467   FlushKeyboard_6:
00000E30  4E5E      1468          unlk      A6
00000E32  4E75      1469          rts
                    1470   ; }
                    1471   ; }
                    1472   ; // converts hex char to 4 bit binary equiv in range 0000-1111 (0-F)
                    1473   ; // char assumed to be a valid hex char 0-9, a-f, A-F
                    1474   ; char xtod(int c)
                    1475   ; {
                    1476   _xtod:
00000E34  4E56 0000 1477          link      A6,#0
00000E38  2F02      1478          move.l    D2,-(A7)
00000E3A  242E 0008 1479          move.l    8(A6),D2
                    1480   ; if ((char)(c) <= (char)('9'))
00000E3E  0C02 0039 1481          cmp.b     #57,D2
00000E42  6E08      1482          bgt.s     xtod_1
                    1483   ; return c - (char)(0x30);    // 0 - 9 = 0x30 - 0x39 so convert to number by sutracting 0x30
00000E44  1002      1484          move.b    D2,D0
00000E46  0400 0030 1485          sub.b     #48,D0
00000E4A  6014      1486          bra.s     xtod_3
                    1487   xtod_1:
                    1488   ; else if((char)(c) > (char)('F'))    // assume lower case
00000E4C  0C02 0046 1489          cmp.b     #70,D2
00000E50  6F08      1490          ble.s     xtod_4
                    1491   ; return c - (char)(0x57);    // a-f = 0x61-66 so needs to be converted to 0x0A - 0x0F so subtract 0x57
00000E52  1002      1492          move.b    D2,D0
00000E54  0400 0057 1493          sub.b     #87,D0
00000E58  6006      1494          bra.s     xtod_3
                    1495   xtod_4:
                    1496   ; else
                    1497   ; return c - (char)(0x37);    // A-F = 0x41-46 so needs to be converted to 0x0A - 0x0F so subtract 0x37
00000E5A  1002      1498          move.b    D2,D0
00000E5C  0400 0037 1499          sub.b     #55,D0
                    1500   xtod_3:
00000E60  241F      1501          move.l    (A7)+,D2
00000E62  4E5E      1502          unlk      A6
00000E64  4E75      1503          rts
                    1504   ; }
                    1505   ; int Get2HexDigits(char *CheckSumPtr)
                    1506   ; {
                    1507   _Get2HexDigits:
00000E66  4E56 0000 1508          link      A6,#0
00000E6A  2F02      1509          move.l    D2,-(A7)
                    1510   ; register int i = (xtod(_getch()) << 4) | (xtod(_getch()));
00000E6C  2F00      1511          move.l    D0,-(A7)
00000E6E  4EB8 0DCA 1512          jsr       __getch
00000E72  2200      1513          move.l    D0,D1
00000E74  201F      1514          move.l    (A7)+,D0
00000E76  2F01      1515          move.l    D1,-(A7)
00000E78  4EB8 0E34 1516          jsr       _xtod
00000E7C  584F      1517          addq.w    #4,A7
00000E7E  C0BC 0000 1518          and.l     #255,D0
00000E82  00FF      
00000E84  E980      1519          asl.l     #4,D0
00000E86  2F00      1520          move.l    D0,-(A7)
00000E88  2F01      1521          move.l    D1,-(A7)
00000E8A  4EB8 0DCA 1522          jsr       __getch
00000E8E  221F      1523          move.l    (A7)+,D1
00000E90  2F00      1524          move.l    D0,-(A7)
00000E92  4EB8 0E34 1525          jsr       _xtod
00000E96  584F      1526          addq.w    #4,A7
00000E98  2200      1527          move.l    D0,D1
00000E9A  201F      1528          move.l    (A7)+,D0
00000E9C  C2BC 0000 1529          and.l     #255,D1
00000EA0  00FF      
00000EA2  8081      1530          or.l      D1,D0
00000EA4  2400      1531          move.l    D0,D2
                    1532   ; if(CheckSumPtr)
00000EA6  4AAE 0008 1533          tst.l     8(A6)
00000EAA  6706      1534          beq.s     Get2HexDigits_1
                    1535   ; *CheckSumPtr += i ;
00000EAC  206E 0008 1536          move.l    8(A6),A0
00000EB0  D510      1537          add.b     D2,(A0)
                    1538   Get2HexDigits_1:
                    1539   ; return i ;
00000EB2  2002      1540          move.l    D2,D0
00000EB4  241F      1541          move.l    (A7)+,D2
00000EB6  4E5E      1542          unlk      A6
00000EB8  4E75      1543          rts
                    1544   ; }
                    1545   ; int Get4HexDigits(char *CheckSumPtr)
                    1546   ; {
                    1547   _Get4HexDigits:
00000EBA  4E56 0000 1548          link      A6,#0
                    1549   ; return (Get2HexDigits(CheckSumPtr) << 8) | (Get2HexDigits(CheckSumPtr));
00000EBE  2F2E 0008 1550          move.l    8(A6),-(A7)
00000EC2  4EB8 0E66 1551          jsr       _Get2HexDigits
00000EC6  584F      1552          addq.w    #4,A7
00000EC8  E180      1553          asl.l     #8,D0
00000ECA  2F00      1554          move.l    D0,-(A7)
00000ECC  2F2E 0008 1555          move.l    8(A6),-(A7)
00000ED0  4EB8 0E66 1556          jsr       _Get2HexDigits
00000ED4  584F      1557          addq.w    #4,A7
00000ED6  2200      1558          move.l    D0,D1
00000ED8  201F      1559          move.l    (A7)+,D0
00000EDA  8081      1560          or.l      D1,D0
00000EDC  4E5E      1561          unlk      A6
00000EDE  4E75      1562          rts
                    1563   ; }
                    1564   ; int Get6HexDigits(char *CheckSumPtr)
                    1565   ; {
                    1566   _Get6HexDigits:
00000EE0  4E56 0000 1567          link      A6,#0
                    1568   ; return (Get4HexDigits(CheckSumPtr) << 8) | (Get2HexDigits(CheckSumPtr));
00000EE4  2F2E 0008 1569          move.l    8(A6),-(A7)
00000EE8  4EB8 0EBA 1570          jsr       _Get4HexDigits
00000EEC  584F      1571          addq.w    #4,A7
00000EEE  E180      1572          asl.l     #8,D0
00000EF0  2F00      1573          move.l    D0,-(A7)
00000EF2  2F2E 0008 1574          move.l    8(A6),-(A7)
00000EF6  4EB8 0E66 1575          jsr       _Get2HexDigits
00000EFA  584F      1576          addq.w    #4,A7
00000EFC  2200      1577          move.l    D0,D1
00000EFE  201F      1578          move.l    (A7)+,D0
00000F00  8081      1579          or.l      D1,D0
00000F02  4E5E      1580          unlk      A6
00000F04  4E75      1581          rts
                    1582   ; }
                    1583   ; int Get8HexDigits(char *CheckSumPtr)
                    1584   ; {
                    1585   _Get8HexDigits:
00000F06  4E56 0000 1586          link      A6,#0
                    1587   ; return (Get4HexDigits(CheckSumPtr) << 16) | (Get4HexDigits(CheckSumPtr));
00000F0A  2F2E 0008 1588          move.l    8(A6),-(A7)
00000F0E  4EB8 0EBA 1589          jsr       _Get4HexDigits
00000F12  584F      1590          addq.w    #4,A7
00000F14  E180      1591          asl.l     #8,D0
00000F16  E180      1592          asl.l     #8,D0
00000F18  2F00      1593          move.l    D0,-(A7)
00000F1A  2F2E 0008 1594          move.l    8(A6),-(A7)
00000F1E  4EB8 0EBA 1595          jsr       _Get4HexDigits
00000F22  584F      1596          addq.w    #4,A7
00000F24  2200      1597          move.l    D0,D1
00000F26  201F      1598          move.l    (A7)+,D0
00000F28  8081      1599          or.l      D1,D0
00000F2A  4E5E      1600          unlk      A6
00000F2C  4E75      1601          rts
                    1602   ; }
                    1603   ; void DumpMemory(void)   // simple dump memory fn
                    1604   ; {
                    1605   _DumpMemory:
00000F2E  48E7 3C30 1606          movem.l   D2/D3/D4/D5/A2/A3,-(A7)
00000F32  45F9 0000 1607          lea       _printf.L,A2
00000F36  3C28      
00000F38  47F9 0000 1608          lea       _putch.L,A3
00000F3C  3D48      
                    1609   ; int i, j ;
                    1610   ; unsigned char *RamPtr,c ; // pointer to where the program is download (assumed)
                    1611   ; printf("\r\nDump Memory Block: <ESC> to Abort, <SPACE> to Continue") ;
00000F3E  4879 0000 1612          pea       @m68kde~1_5.L
00000F42  50E6      
00000F44  4E92      1613          jsr       (A2)
00000F46  584F      1614          addq.w    #4,A7
                    1615   ; printf("\r\nEnter Start Address: ") ;
00000F48  4879 0000 1616          pea       @m68kde~1_6.L
00000F4C  5120      
00000F4E  4E92      1617          jsr       (A2)
00000F50  584F      1618          addq.w    #4,A7
                    1619   ; RamPtr = Get8HexDigits(0) ;
00000F52  42A7      1620          clr.l     -(A7)
00000F54  4EB8 0F06 1621          jsr       _Get8HexDigits
00000F58  584F      1622          addq.w    #4,A7
00000F5A  2600      1623          move.l    D0,D3
                    1624   ; while(1)    {
                    1625   DumpMemory_1:
                    1626   ; for(i = 0; i < 16; i ++)    {
00000F5C  4285      1627          clr.l     D5
                    1628   DumpMemory_4:
00000F5E  0C85 0000 1629          cmp.l     #16,D5
00000F62  0010      
00000F64  6C00 0096 1630          bge       DumpMemory_6
                    1631   ; printf("\r\n%08x ", RamPtr) ;
00000F68  2F03      1632          move.l    D3,-(A7)
00000F6A  4879 0000 1633          pea       @m68kde~1_7.L
00000F6E  5138      
00000F70  4E92      1634          jsr       (A2)
00000F72  504F      1635          addq.w    #8,A7
                    1636   ; for(j=0; j < 16; j ++)  {
00000F74  4282      1637          clr.l     D2
                    1638   DumpMemory_7:
00000F76  0C82 0000 1639          cmp.l     #16,D2
00000F7A  0010      
00000F7C  6C24      1640          bge.s     DumpMemory_9
                    1641   ; printf("%02X",RamPtr[j]) ;
00000F7E  2043      1642          move.l    D3,A0
00000F80  1230 2800 1643          move.b    0(A0,D2.L),D1
00000F84  C2BC 0000 1644          and.l     #255,D1
00000F88  00FF      
00000F8A  2F01      1645          move.l    D1,-(A7)
00000F8C  4879 0000 1646          pea       @m68kde~1_8.L
00000F90  5140      
00000F92  4E92      1647          jsr       (A2)
00000F94  504F      1648          addq.w    #8,A7
                    1649   ; putchar(' ') ;
00000F96  4878 0020 1650          pea       32
00000F9A  4E93      1651          jsr       (A3)
00000F9C  584F      1652          addq.w    #4,A7
00000F9E  5282      1653          addq.l    #1,D2
00000FA0  60D4      1654          bra       DumpMemory_7
                    1655   DumpMemory_9:
                    1656   ; }
                    1657   ; // now display the data as ASCII at the end
                    1658   ; printf("  ") ;
00000FA2  4879 0000 1659          pea       @m68kde~1_9.L
00000FA6  5146      
00000FA8  4E92      1660          jsr       (A2)
00000FAA  584F      1661          addq.w    #4,A7
                    1662   ; for(j = 0; j < 16; j++) {
00000FAC  4282      1663          clr.l     D2
                    1664   DumpMemory_10:
00000FAE  0C82 0000 1665          cmp.l     #16,D2
00000FB2  0010      
00000FB4  6C00 003A 1666          bge       DumpMemory_12
                    1667   ; c = ((char)(RamPtr[j]) & 0x7f) ;
00000FB8  2043      1668          move.l    D3,A0
00000FBA  1030 2800 1669          move.b    0(A0,D2.L),D0
00000FBE  C03C 007F 1670          and.b     #127,D0
00000FC2  1800      1671          move.b    D0,D4
                    1672   ; if((c > (char)(0x7f)) || (c < ' '))
00000FC4  0C04 007F 1673          cmp.b     #127,D4
00000FC8  6206      1674          bhi.s     DumpMemory_15
00000FCA  0C04 0020 1675          cmp.b     #32,D4
00000FCE  640A      1676          bhs.s     DumpMemory_13
                    1677   DumpMemory_15:
                    1678   ; putchar('.') ;
00000FD0  4878 002E 1679          pea       46
00000FD4  4E93      1680          jsr       (A3)
00000FD6  584F      1681          addq.w    #4,A7
00000FD8  6012      1682          bra.s     DumpMemory_14
                    1683   DumpMemory_13:
                    1684   ; else
                    1685   ; putchar(RamPtr[j]) ;
00000FDA  2043      1686          move.l    D3,A0
00000FDC  1230 2800 1687          move.b    0(A0,D2.L),D1
00000FE0  C2BC 0000 1688          and.l     #255,D1
00000FE4  00FF      
00000FE6  2F01      1689          move.l    D1,-(A7)
00000FE8  4E93      1690          jsr       (A3)
00000FEA  584F      1691          addq.w    #4,A7
                    1692   DumpMemory_14:
00000FEC  5282      1693          addq.l    #1,D2
00000FEE  60BE      1694          bra       DumpMemory_10
                    1695   DumpMemory_12:
                    1696   ; }
                    1697   ; RamPtr = RamPtr + 16 ;
00000FF0  0683 0000 1698          add.l     #16,D3
00000FF4  0010      
00000FF6  5285      1699          addq.l    #1,D5
00000FF8  6000 FF64 1700          bra       DumpMemory_4
                    1701   DumpMemory_6:
                    1702   ; }
                    1703   ; printf("\r\n") ;
00000FFC  4879 0000 1704          pea       @m68kde~1_1.L
00001000  50C8      
00001002  4E92      1705          jsr       (A2)
00001004  584F      1706          addq.w    #4,A7
                    1707   ; c = _getch() ;
00001006  4EB8 0DCA 1708          jsr       __getch
0000100A  1800      1709          move.b    D0,D4
                    1710   ; if(c == 0x1b)          // break on ESC
0000100C  0C04 001B 1711          cmp.b     #27,D4
00001010  6602      1712          bne.s     DumpMemory_16
                    1713   ; break ;
00001012  6004      1714          bra.s     DumpMemory_3
                    1715   DumpMemory_16:
00001014  6000 FF46 1716          bra       DumpMemory_1
                    1717   DumpMemory_3:
00001018  4CDF 0C3C 1718          movem.l   (A7)+,D2/D3/D4/D5/A2/A3
0000101C  4E75      1719          rts
                    1720   ; }
                    1721   ; }
                    1722   ; void FillMemory()
                    1723   ; {
                    1724   _FillMemory:
0000101E  48E7 3820 1725          movem.l   D2/D3/D4/A2,-(A7)
00001022  45F9 0000 1726          lea       _printf.L,A2
00001026  3C28      
                    1727   ; char *StartRamPtr, *EndRamPtr ;
                    1728   ; unsigned char FillData ;
                    1729   ; printf("\r\nFill Memory Block") ;
00001028  4879 0000 1730          pea       @m68kde~1_10.L
0000102C  514A      
0000102E  4E92      1731          jsr       (A2)
00001030  584F      1732          addq.w    #4,A7
                    1733   ; printf("\r\nEnter Start Address: ") ;
00001032  4879 0000 1734          pea       @m68kde~1_6.L
00001036  5120      
00001038  4E92      1735          jsr       (A2)
0000103A  584F      1736          addq.w    #4,A7
                    1737   ; StartRamPtr = Get8HexDigits(0) ;
0000103C  42A7      1738          clr.l     -(A7)
0000103E  4EB8 0F06 1739          jsr       _Get8HexDigits
00001042  584F      1740          addq.w    #4,A7
00001044  2400      1741          move.l    D0,D2
                    1742   ; printf("\r\nEnter End Address: ") ;
00001046  4879 0000 1743          pea       @m68kde~1_11.L
0000104A  515E      
0000104C  4E92      1744          jsr       (A2)
0000104E  584F      1745          addq.w    #4,A7
                    1746   ; EndRamPtr = Get8HexDigits(0) ;
00001050  42A7      1747          clr.l     -(A7)
00001052  4EB8 0F06 1748          jsr       _Get8HexDigits
00001056  584F      1749          addq.w    #4,A7
00001058  2800      1750          move.l    D0,D4
                    1751   ; printf("\r\nEnter Fill Data: ") ;
0000105A  4879 0000 1752          pea       @m68kde~1_12.L
0000105E  5174      
00001060  4E92      1753          jsr       (A2)
00001062  584F      1754          addq.w    #4,A7
                    1755   ; FillData = Get2HexDigits(0) ;
00001064  42A7      1756          clr.l     -(A7)
00001066  4EB8 0E66 1757          jsr       _Get2HexDigits
0000106A  584F      1758          addq.w    #4,A7
0000106C  1600      1759          move.b    D0,D3
                    1760   ; printf("\r\nFilling Addresses [$%08X - $%08X] with $%02X", StartRamPtr, EndRamPtr, FillData) ;
0000106E  C6BC 0000 1761          and.l     #255,D3
00001072  00FF      
00001074  2F03      1762          move.l    D3,-(A7)
00001076  2F04      1763          move.l    D4,-(A7)
00001078  2F02      1764          move.l    D2,-(A7)
0000107A  4879 0000 1765          pea       @m68kde~1_13.L
0000107E  5188      
00001080  4E92      1766          jsr       (A2)
00001082  DEFC 0010 1767          add.w     #16,A7
                    1768   ; while(StartRamPtr < EndRamPtr)
                    1769   FillMemory_1:
00001086  B484      1770          cmp.l     D4,D2
00001088  6408      1771          bhs.s     FillMemory_3
                    1772   ; *StartRamPtr++ = FillData ;
0000108A  2042      1773          move.l    D2,A0
0000108C  5282      1774          addq.l    #1,D2
0000108E  1083      1775          move.b    D3,(A0)
00001090  60F4      1776          bra       FillMemory_1
                    1777   FillMemory_3:
00001092  4CDF 041C 1778          movem.l   (A7)+,D2/D3/D4/A2
00001096  4E75      1779          rts
                    1780   ; }
                    1781   ; void Load_SRecordFile()
                    1782   ; {
                    1783   _Load_SRecordFile:
00001098  4E56 FFDC 1784          link      A6,#-36
0000109C  48E7 3F3C 1785          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
000010A0  45EE FFFA 1786          lea       -6(A6),A2
000010A4  47F8 0E66 1787          lea       _Get2HexDigits.L,A3
000010A8  49F9 0000 1788          lea       _printf.L,A4
000010AC  3C28      
                    1789   ; int i, Address, AddressSize, DataByte, NumDataBytesToRead, LoadFailed, FailedAddress, AddressFail, SRecordCount = 0, ByteTotal = 0 ;
000010AE  42AE FFEE 1790          clr.l     -18(A6)
000010B2  3A7C 0000 1791          move.w    #0,A5
                    1792   ; int result, ByteCount ;
                    1793   ; char c, CheckSum, ReadCheckSum, HeaderType ;
                    1794   ; char *RamPtr ;                          // pointer to Memory where downloaded program will be stored
                    1795   ; LoadFailed = 0 ;                        //assume LOAD operation will pass
000010B6  7E00      1796          moveq     #0,D7
                    1797   ; AddressFail = 0 ;
000010B8  42AE FFEA 1798          clr.l     -22(A6)
                    1799   ; Echo = 0 ;                              // don't echo S records during download
000010BC  42B9 0B00 1800          clr.l     _Echo.L
000010C0  00E0      
                    1801   ; printf("\r\nUse HyperTerminal to Send Text File (.hex)\r\n") ;
000010C2  4879 0000 1802          pea       @m68kde~1_14.L
000010C6  51B8      
000010C8  4E94      1803          jsr       (A4)
000010CA  584F      1804          addq.w    #4,A7
                    1805   ; while(1)    {
                    1806   Load_SRecordFile_1:
                    1807   ; CheckSum = 0 ;
000010CC  4212      1808          clr.b     (A2)
                    1809   ; do {
                    1810   Load_SRecordFile_4:
                    1811   ; c = toupper(_getch()) ;
000010CE  2F00      1812          move.l    D0,-(A7)
000010D0  4EB8 0DCA 1813          jsr       __getch
000010D4  2200      1814          move.l    D0,D1
000010D6  201F      1815          move.l    (A7)+,D0
000010D8  2F01      1816          move.l    D1,-(A7)
000010DA  4EB9 0000 1817          jsr       _toupper
000010DE  3E42      
000010E0  584F      1818          addq.w    #4,A7
000010E2  1C00      1819          move.b    D0,D6
                    1820   ; if(c == 0x1b )      // if break
000010E4  0C06 001B 1821          cmp.b     #27,D6
000010E8  6604      1822          bne.s     Load_SRecordFile_6
                    1823   ; return;
000010EA  6000 0132 1824          bra       Load_SRecordFile_8
                    1825   Load_SRecordFile_6:
000010EE  0C06 0053 1826          cmp.b     #83,D6
000010F2  66DA      1827          bne       Load_SRecordFile_4
                    1828   ; }while(c != (char)('S'));   // wait for S start of header
                    1829   ; HeaderType = _getch() ;
000010F4  4EB8 0DCA 1830          jsr       __getch
000010F8  1600      1831          move.b    D0,D3
                    1832   ; if(HeaderType == (char)('0') || HeaderType == (char)('5'))       // ignore s0, s5 records
000010FA  0C03 0030 1833          cmp.b     #48,D3
000010FE  6706      1834          beq.s     Load_SRecordFile_11
00001100  0C03 0035 1835          cmp.b     #53,D3
00001104  6604      1836          bne.s     Load_SRecordFile_9
                    1837   Load_SRecordFile_11:
                    1838   ; continue ;
00001106  6000 00D2 1839          bra       Load_SRecordFile_23
                    1840   Load_SRecordFile_9:
                    1841   ; if(HeaderType >= (char)('7'))
0000110A  0C03 0037 1842          cmp.b     #55,D3
0000110E  6D04      1843          blt.s     Load_SRecordFile_12
                    1844   ; break ;                 // end load on s7,s8,s9 records
00001110  6000 00CC 1845          bra       Load_SRecordFile_3
                    1846   Load_SRecordFile_12:
                    1847   ; // get the bytecount
                    1848   ; ByteCount = Get2HexDigits(&CheckSum) ;
00001114  2F0A      1849          move.l    A2,-(A7)
00001116  4E93      1850          jsr       (A3)
00001118  584F      1851          addq.w    #4,A7
0000111A  2D40 FFF6 1852          move.l    D0,-10(A6)
                    1853   ; // get the address, 4 digits for s1, 6 digits for s2, and 8 digits for s3 record
                    1854   ; if(HeaderType == (char)('1')) {
0000111E  0C03 0031 1855          cmp.b     #49,D3
00001122  660E      1856          bne.s     Load_SRecordFile_14
                    1857   ; AddressSize = 2 ;       // 2 byte address
00001124  7A02      1858          moveq     #2,D5
                    1859   ; Address = Get4HexDigits(&CheckSum);
00001126  2F0A      1860          move.l    A2,-(A7)
00001128  4EB8 0EBA 1861          jsr       _Get4HexDigits
0000112C  584F      1862          addq.w    #4,A7
0000112E  2800      1863          move.l    D0,D4
00001130  6020      1864          bra.s     Load_SRecordFile_17
                    1865   Load_SRecordFile_14:
                    1866   ; }
                    1867   ; else if (HeaderType == (char)('2')) {
00001132  0C03 0032 1868          cmp.b     #50,D3
00001136  660E      1869          bne.s     Load_SRecordFile_16
                    1870   ; AddressSize = 3 ;       // 3 byte address
00001138  7A03      1871          moveq     #3,D5
                    1872   ; Address = Get6HexDigits(&CheckSum) ;
0000113A  2F0A      1873          move.l    A2,-(A7)
0000113C  4EB8 0EE0 1874          jsr       _Get6HexDigits
00001140  584F      1875          addq.w    #4,A7
00001142  2800      1876          move.l    D0,D4
00001144  600C      1877          bra.s     Load_SRecordFile_17
                    1878   Load_SRecordFile_16:
                    1879   ; }
                    1880   ; else    {
                    1881   ; AddressSize = 4 ;       // 4 byte address
00001146  7A04      1882          moveq     #4,D5
                    1883   ; Address = Get8HexDigits(&CheckSum) ;
00001148  2F0A      1884          move.l    A2,-(A7)
0000114A  4EB8 0F06 1885          jsr       _Get8HexDigits
0000114E  584F      1886          addq.w    #4,A7
00001150  2800      1887          move.l    D0,D4
                    1888   Load_SRecordFile_17:
                    1889   ; }
                    1890   ; RamPtr = (char *)(Address) ;                            // point to download area
00001152  2D44 FFFC 1891          move.l    D4,-4(A6)
                    1892   ; NumDataBytesToRead = ByteCount - AddressSize - 1 ;
00001156  202E FFF6 1893          move.l    -10(A6),D0
0000115A  9085      1894          sub.l     D5,D0
0000115C  5380      1895          subq.l    #1,D0
0000115E  2D40 FFE2 1896          move.l    D0,-30(A6)
                    1897   ; for(i = 0; i < NumDataBytesToRead; i ++) {     // read in remaining data bytes (ignore address and checksum at the end
00001162  4282      1898          clr.l     D2
                    1899   Load_SRecordFile_18:
00001164  B4AE FFE2 1900          cmp.l     -30(A6),D2
00001168  6C1E      1901          bge.s     Load_SRecordFile_20
                    1902   ; DataByte = Get2HexDigits(&CheckSum) ;
0000116A  2F0A      1903          move.l    A2,-(A7)
0000116C  4E93      1904          jsr       (A3)
0000116E  584F      1905          addq.w    #4,A7
00001170  2D40 FFDE 1906          move.l    D0,-34(A6)
                    1907   ; *RamPtr++ = DataByte ;                      // store downloaded byte in Ram at specified address
00001174  202E FFDE 1908          move.l    -34(A6),D0
00001178  206E FFFC 1909          move.l    -4(A6),A0
0000117C  52AE FFFC 1910          addq.l    #1,-4(A6)
00001180  1080      1911          move.b    D0,(A0)
                    1912   ; ByteTotal++;
00001182  524D      1913          addq.w    #1,A5
00001184  5282      1914          addq.l    #1,D2
00001186  60DC      1915          bra       Load_SRecordFile_18
                    1916   Load_SRecordFile_20:
                    1917   ; }
                    1918   ; // checksum is the 1's complement of the sum of all data pairs following the bytecount, i.e. it includes the address and the data itself
                    1919   ; ReadCheckSum = Get2HexDigits(0) ;
00001188  42A7      1920          clr.l     -(A7)
0000118A  4E93      1921          jsr       (A3)
0000118C  584F      1922          addq.w    #4,A7
0000118E  1D40 FFFB 1923          move.b    D0,-5(A6)
                    1924   ; if((~CheckSum&0Xff) != (ReadCheckSum&0Xff))   {
00001192  1012      1925          move.b    (A2),D0
00001194  4600      1926          not.b     D0
00001196  4880      1927          ext.w     D0
00001198  C07C 00FF 1928          and.w     #255,D0
0000119C  122E FFFB 1929          move.b    -5(A6),D1
000011A0  4881      1930          ext.w     D1
000011A2  C27C 00FF 1931          and.w     #255,D1
000011A6  B041      1932          cmp.w     D1,D0
000011A8  6708      1933          beq.s     Load_SRecordFile_21
                    1934   ; LoadFailed = 1 ;
000011AA  7E01      1935          moveq     #1,D7
                    1936   ; FailedAddress = Address ;
000011AC  2D44 FFE6 1937          move.l    D4,-26(A6)
                    1938   ; break;
000011B0  602C      1939          bra.s     Load_SRecordFile_3
                    1940   Load_SRecordFile_21:
                    1941   ; }
                    1942   ; SRecordCount++ ;
000011B2  52AE FFEE 1943          addq.l    #1,-18(A6)
                    1944   ; // display feedback on progress
                    1945   ; if(SRecordCount % 25 == 0)
000011B6  2F2E FFEE 1946          move.l    -18(A6),-(A7)
000011BA  4878 0019 1947          pea       25
000011BE  4EB9 0000 1948          jsr       LDIV
000011C2  3C7C      
000011C4  202F 0004 1949          move.l    4(A7),D0
000011C8  504F      1950          addq.w    #8,A7
000011CA  4A80      1951          tst.l     D0
000011CC  660C      1952          bne.s     Load_SRecordFile_23
                    1953   ; putchar('.') ;
000011CE  4878 002E 1954          pea       46
000011D2  4EB9 0000 1955          jsr       _putch
000011D6  3D48      
000011D8  584F      1956          addq.w    #4,A7
                    1957   Load_SRecordFile_23:
000011DA  6000 FEF0 1958          bra       Load_SRecordFile_1
                    1959   Load_SRecordFile_3:
                    1960   ; }
                    1961   ; if(LoadFailed == 1) {
000011DE  0C87 0000 1962          cmp.l     #1,D7
000011E2  0001      
000011E4  6610      1963          bne.s     Load_SRecordFile_25
                    1964   ; printf("\r\nLoad Failed at Address = [$%08X]\r\n", FailedAddress) ;
000011E6  2F2E FFE6 1965          move.l    -26(A6),-(A7)
000011EA  4879 0000 1966          pea       @m68kde~1_15.L
000011EE  51E8      
000011F0  4E94      1967          jsr       (A4)
000011F2  504F      1968          addq.w    #8,A7
000011F4  600C      1969          bra.s     Load_SRecordFile_26
                    1970   Load_SRecordFile_25:
                    1971   ; }
                    1972   ; else
                    1973   ; printf("\r\nSuccess: Downloaded %d bytes\r\n", ByteTotal) ;
000011F6  2F0D      1974          move.l    A5,-(A7)
000011F8  4879 0000 1975          pea       @m68kde~1_16.L
000011FC  520E      
000011FE  4E94      1976          jsr       (A4)
00001200  504F      1977          addq.w    #8,A7
                    1978   Load_SRecordFile_26:
                    1979   ; // pause at the end to wait for download to finish transmitting at the end of S8 etc
                    1980   ; for(i = 0; i < 400000; i ++)
00001202  4282      1981          clr.l     D2
                    1982   Load_SRecordFile_27:
00001204  0C82 0006 1983          cmp.l     #400000,D2
00001208  1A80      
0000120A  6C04      1984          bge.s     Load_SRecordFile_29
0000120C  5282      1985          addq.l    #1,D2
0000120E  60F4      1986          bra       Load_SRecordFile_27
                    1987   Load_SRecordFile_29:
                    1988   ; ;
                    1989   ; FlushKeyboard() ;
00001210  4EB8 0E08 1990          jsr       _FlushKeyboard
                    1991   ; Echo = 1;
00001214  23FC 0000 1992          move.l    #1,_Echo.L
00001218  0001 0B00 
0000121C  00E0      
                    1993   Load_SRecordFile_8:
0000121E  4CDF 3CFC 1994          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
00001222  4E5E      1995          unlk      A6
00001224  4E75      1996          rts
                    1997   ; }
                    1998   ; void MemoryChange(void)
                    1999   ; {
                    2000   _MemoryChange:
00001226  48E7 3820 2001          movem.l   D2/D3/D4/A2,-(A7)
0000122A  45F9 0000 2002          lea       _printf.L,A2
0000122E  3C28      
                    2003   ; unsigned char *RamPtr,c ; // pointer to memory
                    2004   ; int Data ;
                    2005   ; printf("\r\nExamine and Change Memory") ;
00001230  4879 0000 2006          pea       @m68kde~1_17.L
00001234  5230      
00001236  4E92      2007          jsr       (A2)
00001238  584F      2008          addq.w    #4,A7
                    2009   ; printf("\r\n<ESC> to Stop, <SPACE> to Advance, '-' to Go Back, <DATA> to change") ;
0000123A  4879 0000 2010          pea       @m68kde~1_18.L
0000123E  524C      
00001240  4E92      2011          jsr       (A2)
00001242  584F      2012          addq.w    #4,A7
                    2013   ; printf("\r\nEnter Address: ") ;
00001244  4879 0000 2014          pea       @m68kde~1_19.L
00001248  5292      
0000124A  4E92      2015          jsr       (A2)
0000124C  584F      2016          addq.w    #4,A7
                    2017   ; RamPtr = Get8HexDigits(0) ;
0000124E  42A7      2018          clr.l     -(A7)
00001250  4EB8 0F06 2019          jsr       _Get8HexDigits
00001254  584F      2020          addq.w    #4,A7
00001256  2600      2021          move.l    D0,D3
                    2022   ; while(1)    {
                    2023   MemoryChange_1:
                    2024   ; printf("\r\n[%08x] : %02x  ", RamPtr, *RamPtr) ;
00001258  2043      2025          move.l    D3,A0
0000125A  1210      2026          move.b    (A0),D1
0000125C  C2BC 0000 2027          and.l     #255,D1
00001260  00FF      
00001262  2F01      2028          move.l    D1,-(A7)
00001264  2F03      2029          move.l    D3,-(A7)
00001266  4879 0000 2030          pea       @m68kde~1_20.L
0000126A  52A4      
0000126C  4E92      2031          jsr       (A2)
0000126E  DEFC 000C 2032          add.w     #12,A7
                    2033   ; c = tolower(_getch()) ;
00001272  2F00      2034          move.l    D0,-(A7)
00001274  4EB8 0DCA 2035          jsr       __getch
00001278  2200      2036          move.l    D0,D1
0000127A  201F      2037          move.l    (A7)+,D0
0000127C  2F01      2038          move.l    D1,-(A7)
0000127E  4EB9 0000 2039          jsr       _tolower
00001282  3DB4      
00001284  584F      2040          addq.w    #4,A7
00001286  1400      2041          move.b    D0,D2
                    2042   ; if(c == (char)(0x1b))
00001288  0C02 001B 2043          cmp.b     #27,D2
0000128C  6604      2044          bne.s     MemoryChange_4
                    2045   ; return ;                                // abort on escape
0000128E  6000 0090 2046          bra       MemoryChange_6
                    2047   MemoryChange_4:
                    2048   ; else if((c >= '0' && c <= '9') || (c >= 'a' && c <= 'f')) {  // are we trying to change data at this location by entering a hex char
00001292  0C02 0030 2049          cmp.b     #48,D2
00001296  6506      2050          blo.s     MemoryChange_10
00001298  0C02 0039 2051          cmp.b     #57,D2
0000129C  6310      2052          bls.s     MemoryChange_9
                    2053   MemoryChange_10:
0000129E  0C02 0061 2054          cmp.b     #97,D2
000012A2  6500 006E 2055          blo       MemoryChange_7
000012A6  0C02 0066 2056          cmp.b     #102,D2
000012AA  6200 0066 2057          bhi       MemoryChange_7
                    2058   MemoryChange_9:
                    2059   ; Data = (xtod(c) << 4) | (xtod(_getch()));
000012AE  C4BC 0000 2060          and.l     #255,D2
000012B2  00FF      
000012B4  2F02      2061          move.l    D2,-(A7)
000012B6  4EB8 0E34 2062          jsr       _xtod
000012BA  584F      2063          addq.w    #4,A7
000012BC  C0BC 0000 2064          and.l     #255,D0
000012C0  00FF      
000012C2  E980      2065          asl.l     #4,D0
000012C4  2F00      2066          move.l    D0,-(A7)
000012C6  2F01      2067          move.l    D1,-(A7)
000012C8  4EB8 0DCA 2068          jsr       __getch
000012CC  221F      2069          move.l    (A7)+,D1
000012CE  2F00      2070          move.l    D0,-(A7)
000012D0  4EB8 0E34 2071          jsr       _xtod
000012D4  584F      2072          addq.w    #4,A7
000012D6  2200      2073          move.l    D0,D1
000012D8  201F      2074          move.l    (A7)+,D0
000012DA  C2BC 0000 2075          and.l     #255,D1
000012DE  00FF      
000012E0  8081      2076          or.l      D1,D0
000012E2  2800      2077          move.l    D0,D4
                    2078   ; *RamPtr = (char)(Data) ;
000012E4  2043      2079          move.l    D3,A0
000012E6  1084      2080          move.b    D4,(A0)
                    2081   ; if(*RamPtr != Data) {
000012E8  2043      2082          move.l    D3,A0
000012EA  1010      2083          move.b    (A0),D0
000012EC  C0BC 0000 2084          and.l     #255,D0
000012F0  00FF      
000012F2  B084      2085          cmp.l     D4,D0
000012F4  671A      2086          beq.s     MemoryChange_11
                    2087   ; printf("\r\nWarning Change Failed: Wrote [%02x], Read [%02x]", Data, *RamPtr) ;
000012F6  2043      2088          move.l    D3,A0
000012F8  1210      2089          move.b    (A0),D1
000012FA  C2BC 0000 2090          and.l     #255,D1
000012FE  00FF      
00001300  2F01      2091          move.l    D1,-(A7)
00001302  2F04      2092          move.l    D4,-(A7)
00001304  4879 0000 2093          pea       @m68kde~1_21.L
00001308  52B6      
0000130A  4E92      2094          jsr       (A2)
0000130C  DEFC 000C 2095          add.w     #12,A7
                    2096   MemoryChange_11:
00001310  6008      2097          bra.s     MemoryChange_13
                    2098   MemoryChange_7:
                    2099   ; }
                    2100   ; }
                    2101   ; else if(c == (char)('-'))
00001312  0C02 002D 2102          cmp.b     #45,D2
00001316  6602      2103          bne.s     MemoryChange_13
                    2104   ; RamPtr -= 2 ; ;
00001318  5583      2105          subq.l    #2,D3
                    2106   MemoryChange_13:
                    2107   ; RamPtr ++ ;
0000131A  5283      2108          addq.l    #1,D3
0000131C  6000 FF3A 2109          bra       MemoryChange_1
                    2110   MemoryChange_6:
00001320  4CDF 041C 2111          movem.l   (A7)+,D2/D3/D4/A2
00001324  4E75      2112          rts
                    2113   ; }
                    2114   ; }
                    2115   ; /******************************************************************************************
                    2116   ; ** The following code is for the SPI controller
                    2117   ; *******************************************************************************************/
                    2118   ; int SPISafeWrite(unsigned char data) {
                    2119   _SPISafeWrite:
00001326  4E56 FFFC 2120          link      A6,#-4
                    2121   ; unsigned char returnVal;
                    2122   ; // Wait while Write FIFO is full by checking WFFULL bit
                    2123   ; // while((SPI_Status & 0x08) == 0x08);
                    2124   ; SPI_Data = data;
0000132A  13EE 000B 2125          move.b    11(A6),4227108
0000132E  0040 8024 
                    2126   ; WaitForSPITransmitComplete();
00001332  4EB9 0000 2127          jsr       _WaitForSPITransmitComplete
00001336  137E      
                    2128   ; returnVal = SPI_Data;
00001338  1D79 0040 2129          move.b    4227108,-1(A6)
0000133C  8024 FFFF 
                    2130   ; return returnVal;
00001340  102E FFFF 2131          move.b    -1(A6),D0
00001344  C0BC 0000 2132          and.l     #255,D0
00001348  00FF      
0000134A  4E5E      2133          unlk      A6
0000134C  4E75      2134          rts
                    2135   ; }
                    2136   ; // return true if the SPI has finished transmitting a byte (to say the Flash chip) return false otherwise
                    2137   ; // this can be used in a polling algorithm to know when the controller is busy or idle.
                    2138   ; int TestForSPITransmitDataComplete(void) {
                    2139   _TestForSPITransmitDataComplete:
                    2140   ; /* TODO replace 0 below with a test for status register SPIF bit and if set, return true */
                    2141   ; return (SPI_Status >> 7);
0000134E  1039 0040 2142          move.b    4227106,D0
00001352  8022      
00001354  C0BC 0000 2143          and.l     #255,D0
00001358  00FF      
0000135A  EE88      2144          lsr.l     #7,D0
0000135C  4E75      2145          rts
                    2146   ; }
                    2147   ; /************************************************************************************
                    2148   ; ** initialises the SPI controller chip to set speed, interrupt capability etc.
                    2149   ; ************************************************************************************/
                    2150   ; void SPI_Init(void)
                    2151   ; {
                    2152   _SPI_Init:
                    2153   ; // TODO
                    2154   ; // Program the SPI Control, EXT, CS and Status registers to initialise the SPI controller
                    2155   ; // Don't forget to call this routine from main() before you do anything else with SPI
                    2156   ; //
                    2157   ; // Here are some settings we want to create
                    2158   ; //
                    2159   ; // Control Reg - interrupts disabled, core enabled, Master mode, Polarity and Phase of clock = [0,0], speed = divide by 32 (b'11) = approx 700Khz
                    2160   ; // Ext Reg - in conjunction with control reg, sets speed above and also sets interrupt flag after every completed transfer (each byte)
                    2161   ; // SPI_CS Reg - control selection of slave SPI chips via their CS# signals
                    2162   ; // Status Reg - status of SPI controller chip and used to clear any write collision and interrupt on transmit complete flag
                    2163   ; SPI_Control = 0x50; // 0101_0011 // This might need to be 0x53
0000135E  13FC 0050 2164          move.b    #80,4227104
00001362  0040 8020 
                    2165   ; SPI_Ext     = 0x0;  // 00_0000_00
00001366  4239 0040 2166          clr.b     4227110
0000136A  8026      
                    2167   ; SPI_CS      = 0xFF; // 1111_1111 // Set all CS inactive by default. We should set CS active when we want to write/read
0000136C  13FC 00FF 2168          move.b    #255,4227112
00001370  0040 8028 
                    2169   ; SPI_Status  = 0xC0; // 1100_0000 // Everything other than bits [7:6] are read only
00001374  13FC 00C0 2170          move.b    #192,4227106
00001378  0040 8022 
0000137C  4E75      2171          rts
                    2172   ; }
                    2173   ; /************************************************************************************
                    2174   ; ** return ONLY when the SPI controller has finished transmitting a byte
                    2175   ; ************************************************************************************/
                    2176   ; void WaitForSPITransmitComplete(void)
                    2177   ; {
                    2178   _WaitForSPITransmitComplete:
                    2179   ; // TODO : poll the status register SPIF bit looking for completion of transmission
                    2180   ; // once transmission is complete, clear the write collision and interrupt on transmit complete flags in the status register (read documentation)
                    2181   ; // just in case they were set
                    2182   ; while (TestForSPITransmitDataComplete() == 0);
                    2183   WaitForSPITransmitComplete_1:
0000137E  4EB8 134E 2184          jsr       _TestForSPITransmitDataComplete
00001382  4A80      2185          tst.l     D0
00001384  6602      2186          bne.s     WaitForSPITransmitComplete_3
00001386  60F6      2187          bra       WaitForSPITransmitComplete_1
                    2188   WaitForSPITransmitComplete_3:
                    2189   ; SPI_Status |= 0xC0;
00001388  0039 00C0 2190          or.b      #192,4227106
0000138C  0040 8022 
00001390  4E75      2191          rts
                    2192   ; }
                    2193   ; // Clear read FIFO by reading from SPI_Data until FIFO is empty
                    2194   ; void ClearSPIReadFIFO(void) {
                    2195   _ClearSPIReadFIFO:
00001392  4E56 FFFC 2196          link      A6,#-4
                    2197   ; volatile unsigned char dummy;
                    2198   ; while((SPI_Status & 0x01) == 0) {
                    2199   ClearSPIReadFIFO_1:
00001396  1039 0040 2200          move.b    4227106,D0
0000139A  8022      
0000139C  C03C 0001 2201          and.b     #1,D0
000013A0  660A      2202          bne.s     ClearSPIReadFIFO_3
                    2203   ; dummy = SPI_Data;
000013A2  1D79 0040 2204          move.b    4227108,-1(A6)
000013A6  8024 FFFF 
000013AA  60EA      2205          bra       ClearSPIReadFIFO_1
                    2206   ClearSPIReadFIFO_3:
000013AC  4E5E      2207          unlk      A6
000013AE  4E75      2208          rts
                    2209   ; }
                    2210   ; }
                    2211   ; void SPIFlashPollStatusWLE(void) {
                    2212   _SPIFlashPollStatusWLE:
000013B0  4E56 FFFC 2213          link      A6,#-4
                    2214   ; unsigned char status;
                    2215   ; unsigned char dummy;
                    2216   ; do {
                    2217   SPIFlashPollStatusWLE_1:
                    2218   ; // Start a new read status register command each time
                    2219   ; SPI_CS = 0xFE;
000013B4  13FC 00FE 2220          move.b    #254,4227112
000013B8  0040 8028 
                    2221   ; SPISafeWrite(0x05);  // Send Read Status Register command
000013BC  4878 0005 2222          pea       5
000013C0  4EB8 1326 2223          jsr       _SPISafeWrite
000013C4  584F      2224          addq.w    #4,A7
                    2225   ; status = SPISafeWrite(0xFF);  // Dummy write to clock in data
000013C6  4878 00FF 2226          pea       255
000013CA  4EB8 1326 2227          jsr       _SPISafeWrite
000013CE  584F      2228          addq.w    #4,A7
000013D0  1D40 FFFE 2229          move.b    D0,-2(A6)
                    2230   ; SPI_CS = 0xFF;           
000013D4  13FC 00FF 2231          move.b    #255,4227112
000013D8  0040 8028 
000013DC  102E FFFE 2232          move.b    -2(A6),D0
000013E0  C03C 0002 2233          and.b     #2,D0
000013E4  67CE      2234          beq       SPIFlashPollStatusWLE_1
000013E6  4E5E      2235          unlk      A6
000013E8  4E75      2236          rts
                    2237   ; // printf("\r\n WLE Status: %02x \n", status);
                    2238   ; } while ((status & 0x02) == 0);  // Continue polling until WEL bit (bit 1) is set and BUSY is not active
                    2239   ; }
                    2240   ; void SPIFlashPollStatusBusy(void) {
                    2241   _SPIFlashPollStatusBusy:
000013EA  4E56 FFFC 2242          link      A6,#-4
                    2243   ; unsigned char status;
                    2244   ; unsigned char dummy;
                    2245   ; do {
                    2246   SPIFlashPollStatusBusy_1:
                    2247   ; // Start a new read status register command each time
                    2248   ; SPI_CS = 0xFE;
000013EE  13FC 00FE 2249          move.b    #254,4227112
000013F2  0040 8028 
                    2250   ; SPISafeWrite(0x05);  // Send Read Status Register command
000013F6  4878 0005 2251          pea       5
000013FA  4EB8 1326 2252          jsr       _SPISafeWrite
000013FE  584F      2253          addq.w    #4,A7
                    2254   ; status = SPISafeWrite(0xFF);  // Dummy write to clock in data
00001400  4878 00FF 2255          pea       255
00001404  4EB8 1326 2256          jsr       _SPISafeWrite
00001408  584F      2257          addq.w    #4,A7
0000140A  1D40 FFFE 2258          move.b    D0,-2(A6)
                    2259   ; SPI_CS = 0xFF;
0000140E  13FC 00FF 2260          move.b    #255,4227112
00001412  0040 8028 
00001416  102E FFFE 2261          move.b    -2(A6),D0
0000141A  C03C 0001 2262          and.b     #1,D0
0000141E  66CE      2263          bne       SPIFlashPollStatusBusy_1
00001420  4E5E      2264          unlk      A6
00001422  4E75      2265          rts
                    2266   ; // printf("\r\n Busy Status: %02x \n", status);
                    2267   ; } while (status & 0x01);  // Continue polling until BUSY bit (bit 0) is cleared
                    2268   ; }
                    2269   ; /************************************************************************************
                    2270   ; ** Write a byte to the SPI flash chip via the controller and returns (reads) whatever was
                    2271   ; ** given back by SPI device at the same time (removes the read byte from the FIFO)
                    2272   ; ************************************************************************************/
                    2273   ; int WriteSPIChar(int c)
                    2274   ; {
                    2275   _WriteSPIChar:
00001424  4E56 0000 2276          link      A6,#0
                    2277   ; SPISafeWrite((unsigned char)c);
00001428  222E 0008 2278          move.l    8(A6),D1
0000142C  C2BC 0000 2279          and.l     #255,D1
00001430  00FF      
00001432  2F01      2280          move.l    D1,-(A7)
00001434  4EB8 1326 2281          jsr       _SPISafeWrite
00001438  584F      2282          addq.w    #4,A7
                    2283   ; return SPI_Data;
0000143A  1039 0040 2284          move.b    4227108,D0
0000143E  8024      
00001440  C0BC 0000 2285          and.l     #255,D0
00001444  00FF      
00001446  4E5E      2286          unlk      A6
00001448  4E75      2287          rts
                    2288   ; }
                    2289   ; void SPIFlashWriteEnable() {
                    2290   _SPIFlashWriteEnable:
                    2291   ; SPI_CS = 0xFE;
0000144A  13FC 00FE 2292          move.b    #254,4227112
0000144E  0040 8028 
                    2293   ; SPISafeWrite(0x06);
00001452  4878 0006 2294          pea       6
00001456  4EB8 1326 2295          jsr       _SPISafeWrite
0000145A  584F      2296          addq.w    #4,A7
                    2297   ; SPI_CS = 0xFF;
0000145C  13FC 00FF 2298          move.b    #255,4227112
00001460  0040 8028 
                    2299   ; // Read and Poll for the write enable latch (WEL) to wait until we finished write enable to exit this isntruction
                    2300   ; SPIFlashPollStatusWLE();
00001464  4EB8 13B0 2301          jsr       _SPIFlashPollStatusWLE
00001468  4E75      2302          rts
                    2303   ; }
                    2304   ; void SPISendAddress(int c) {
                    2305   _SPISendAddress:
0000146A  4E56 0000 2306          link      A6,#0
0000146E  48E7 2020 2307          movem.l   D2/A2,-(A7)
00001472  242E 0008 2308          move.l    8(A6),D2
00001476  45F8 1326 2309          lea       _SPISafeWrite.L,A2
                    2310   ; SPISafeWrite((c >> 16) & 0xFF);     // First byte
0000147A  2202      2311          move.l    D2,D1
0000147C  E081      2312          asr.l     #8,D1
0000147E  E081      2313          asr.l     #8,D1
00001480  C2BC 0000 2314          and.l     #255,D1
00001484  00FF      
00001486  C2BC 0000 2315          and.l     #255,D1
0000148A  00FF      
0000148C  2F01      2316          move.l    D1,-(A7)
0000148E  4E92      2317          jsr       (A2)
00001490  584F      2318          addq.w    #4,A7
                    2319   ; SPISafeWrite((c >> 8) & 0xFF);      // second byte
00001492  2202      2320          move.l    D2,D1
00001494  E081      2321          asr.l     #8,D1
00001496  C2BC 0000 2322          and.l     #255,D1
0000149A  00FF      
0000149C  C2BC 0000 2323          and.l     #255,D1
000014A0  00FF      
000014A2  2F01      2324          move.l    D1,-(A7)
000014A4  4E92      2325          jsr       (A2)
000014A6  584F      2326          addq.w    #4,A7
                    2327   ; SPISafeWrite(c & 0xFF);             // third byte
000014A8  2202      2328          move.l    D2,D1
000014AA  C2BC 0000 2329          and.l     #255,D1
000014AE  00FF      
000014B0  C2BC 0000 2330          and.l     #255,D1
000014B4  00FF      
000014B6  2F01      2331          move.l    D1,-(A7)
000014B8  4E92      2332          jsr       (A2)
000014BA  584F      2333          addq.w    #4,A7
000014BC  4CDF 0404 2334          movem.l   (A7)+,D2/A2
000014C0  4E5E      2335          unlk      A6
000014C2  4E75      2336          rts
                    2337   ; }
                    2338   ; void SPIFlashPageProgram(int addr) {
                    2339   _SPIFlashPageProgram:
000014C4  4E56 FFF8 2340          link      A6,#-8
000014C8  2F02      2341          move.l    D2,-(A7)
                    2342   ; unsigned char *sramMemoryPtr;
                    2343   ; int flashAddr = addr - 0x08000000;
000014CA  202E 0008 2344          move.l    8(A6),D0
000014CE  0480 0800 2345          sub.l     #134217728,D0
000014D2  0000      
000014D4  2D40 FFFC 2346          move.l    D0,-4(A6)
                    2347   ; int i;
                    2348   ; SPI_CS = 0xFE;
000014D8  13FC 00FE 2349          move.b    #254,4227112
000014DC  0040 8028 
                    2350   ; SPISafeWrite(0x02); // Write command so that we wait for write FIFO to not be full before giving a byte
000014E0  4878 0002 2351          pea       2
000014E4  4EB8 1326 2352          jsr       _SPISafeWrite
000014E8  584F      2353          addq.w    #4,A7
                    2354   ; SPISendAddress(flashAddr);
000014EA  2F2E FFFC 2355          move.l    -4(A6),-(A7)
000014EE  4EB8 146A 2356          jsr       _SPISendAddress
000014F2  584F      2357          addq.w    #4,A7
                    2358   ; for (i = 0; i < 256; i++) {
000014F4  4282      2359          clr.l     D2
                    2360   SPIFlashPageProgram_1:
000014F6  0C82 0000 2361          cmp.l     #256,D2
000014FA  0100      
000014FC  6C22      2362          bge.s     SPIFlashPageProgram_3
                    2363   ; sramMemoryPtr = (unsigned char*) (addr + i);
000014FE  202E 0008 2364          move.l    8(A6),D0
00001502  D082      2365          add.l     D2,D0
00001504  2D40 FFF8 2366          move.l    D0,-8(A6)
                    2367   ; WriteSPIChar(*sramMemoryPtr); // Random value for testing purposes
00001508  206E FFF8 2368          move.l    -8(A6),A0
0000150C  1210      2369          move.b    (A0),D1
0000150E  C2BC 0000 2370          and.l     #255,D1
00001512  00FF      
00001514  2F01      2371          move.l    D1,-(A7)
00001516  4EB8 1424 2372          jsr       _WriteSPIChar
0000151A  584F      2373          addq.w    #4,A7
0000151C  5282      2374          addq.l    #1,D2
0000151E  60D6      2375          bra       SPIFlashPageProgram_1
                    2376   SPIFlashPageProgram_3:
                    2377   ; // printf("%02x ", *sramMemoryPtr);
                    2378   ; }
                    2379   ; SPI_CS = 0xFF;
00001520  13FC 00FF 2380          move.b    #255,4227112
00001524  0040 8028 
                    2381   ; // Poll the status register to see when the flash write is finished before exiting this command fully
                    2382   ; SPIFlashPollStatusBusy();
00001528  4EB8 13EA 2383          jsr       _SPIFlashPollStatusBusy
0000152C  241F      2384          move.l    (A7)+,D2
0000152E  4E5E      2385          unlk      A6
00001530  4E75      2386          rts
                    2387   ; }
                    2388   ; void SPIFlashErase(void) {
                    2389   _SPIFlashErase:
                    2390   ; // TODO: Give a parameter for the sector to erase instead of hardcode
                    2391   ; printf("\nErasing...\n");
00001532  4879 0000 2392          pea       @m68kde~1_22.L
00001536  52EA      
00001538  4EB9 0000 2393          jsr       _printf
0000153C  3C28      
0000153E  584F      2394          addq.w    #4,A7
                    2395   ; SPI_CS = 0xFE;
00001540  13FC 00FE 2396          move.b    #254,4227112
00001544  0040 8028 
                    2397   ; SPISafeWrite(0xC7);
00001548  4878 00C7 2398          pea       199
0000154C  4EB8 1326 2399          jsr       _SPISafeWrite
00001550  584F      2400          addq.w    #4,A7
                    2401   ; SPI_CS = 0xFF;
00001552  13FC 00FF 2402          move.b    #255,4227112
00001556  0040 8028 
                    2403   ; SPIFlashPollStatusBusy();
0000155A  4EB8 13EA 2404          jsr       _SPIFlashPollStatusBusy
0000155E  4E75      2405          rts
                    2406   ; }
                    2407   ; int SPIFlashRead() {
                    2408   _SPIFlashRead:
00001560  4E56 FFFC 2409          link      A6,#-4
00001564  48E7 3000 2410          movem.l   D2/D3,-(A7)
                    2411   ; unsigned char readData;
                    2412   ; unsigned char *sramMemoryPtr;
                    2413   ; int addr;
                    2414   ; ClearSPIReadFIFO();
00001568  4EB8 1392 2415          jsr       _ClearSPIReadFIFO
                    2416   ; SPI_CS = 0xFE;
0000156C  13FC 00FE 2417          move.b    #254,4227112
00001570  0040 8028 
                    2418   ; SPISafeWrite(0x03);
00001574  4878 0003 2419          pea       3
00001578  4EB8 1326 2420          jsr       _SPISafeWrite
0000157C  584F      2421          addq.w    #4,A7
                    2422   ; SPISendAddress(0x0);
0000157E  42A7      2423          clr.l     -(A7)
00001580  4EB8 146A 2424          jsr       _SPISendAddress
00001584  584F      2425          addq.w    #4,A7
                    2426   ; for (addr = 0x08000000; addr < (0x08040000); addr ++) {
00001586  243C 0800 2427          move.l    #134217728,D2
0000158A  0000      
                    2428   SPIFlashRead_1:
0000158C  0C82 0804 2429          cmp.l     #134479872,D2
00001590  0000      
00001592  6C1A      2430          bge.s     SPIFlashRead_3
                    2431   ; sramMemoryPtr = (unsigned char*) addr;
00001594  2D42 FFFC 2432          move.l    D2,-4(A6)
                    2433   ; readData = SPISafeWrite(0xFF); // Dummy byte (1 dummy byte == 1 byte read)
00001598  4878 00FF 2434          pea       255
0000159C  4EB8 1326 2435          jsr       _SPISafeWrite
000015A0  584F      2436          addq.w    #4,A7
000015A2  1600      2437          move.b    D0,D3
                    2438   ; *sramMemoryPtr = readData;
000015A4  206E FFFC 2439          move.l    -4(A6),A0
000015A8  1083      2440          move.b    D3,(A0)
000015AA  5282      2441          addq.l    #1,D2
000015AC  60DE      2442          bra       SPIFlashRead_1
                    2443   SPIFlashRead_3:
                    2444   ; }
                    2445   ; SPI_CS = 0xFF;
000015AE  13FC 00FF 2446          move.b    #255,4227112
000015B2  0040 8028 
                    2447   ; SPIFlashPollStatusBusy();
000015B6  4EB8 13EA 2448          jsr       _SPIFlashPollStatusBusy
                    2449   ; return readData;
000015BA  C6BC 0000 2450          and.l     #255,D3
000015BE  00FF      
000015C0  2003      2451          move.l    D3,D0
000015C2  4CDF 000C 2452          movem.l   (A7)+,D2/D3
000015C6  4E5E      2453          unlk      A6
000015C8  4E75      2454          rts
                    2455   ; }
                    2456   ; /*******************************************************************
                    2457   ; ** Write a program to SPI Flash Chip from memory and verify by reading back
                    2458   ; ********************************************************************/
                    2459   ; void ProgramFlashChip(void)
                    2460   ; {
                    2461   _ProgramFlashChip:
000015CA  4E56 FFFC 2462          link      A6,#-4
                    2463   ; int addr;
                    2464   ; SPIFlashPollStatusBusy();
000015CE  4EB8 13EA 2465          jsr       _SPIFlashPollStatusBusy
                    2466   ; SPIFlashWriteEnable();
000015D2  4EB8 144A 2467          jsr       _SPIFlashWriteEnable
                    2468   ; SPIFlashErase();
000015D6  4EB8 1532 2469          jsr       _SPIFlashErase
                    2470   ; // 256KB = 262144 bytes (0x40000)
                    2471   ; // We need to write one page at a time (256 bytes at a time)
                    2472   ; // This code writes the user program from DRAM to FLASH
                    2473   ; // printf("\r\n Starting Programming...");
                    2474   ; // for (addr = 0x08000000; addr < (0x08040000); addr += 256) {
                    2475   ; //     SPIFlashWriteEnable(); 
                    2476   ; //     // printf("\r\n Addr: %08x \n", addr);
                    2477   ; //     SPIFlashPageProgram(addr);
                    2478   ; // }
                    2479   ; printf("\r\n Programming Complete!");
000015DA  4879 0000 2480          pea       @m68kde~1_23.L
000015DE  52F8      
000015E0  4EB9 0000 2481          jsr       _printf
000015E4  3C28      
000015E6  584F      2482          addq.w    #4,A7
000015E8  4E5E      2483          unlk      A6
000015EA  4E75      2484          rts
                    2485   ; }
                    2486   ; /*************************************************************************
                    2487   ; ** Load a program from SPI Flash Chip and copy to Dram
                    2488   ; **************************************************************************/
                    2489   ; void LoadFromFlashChip(void)
                    2490   ; {
                    2491   _LoadFromFlashChip:
000015EC  4E56 FFFC 2492          link      A6,#-4
                    2493   ; int readData;
                    2494   ; printf("\r\n Loading Program From SPI Flash....") ;
000015F0  4879 0000 2495          pea       @m68kde~1_24.L
000015F4  5312      
000015F6  4EB9 0000 2496          jsr       _printf
000015FA  3C28      
000015FC  584F      2497          addq.w    #4,A7
                    2498   ; SPIFlashPollStatusBusy();
000015FE  4EB8 13EA 2499          jsr       _SPIFlashPollStatusBusy
                    2500   ; readData = SPIFlashRead();
00001602  4EB8 1560 2501          jsr       _SPIFlashRead
00001606  2D40 FFFC 2502          move.l    D0,-4(A6)
                    2503   ; printf("\r\n Read Data: %08x \n", readData);
0000160A  2F2E FFFC 2504          move.l    -4(A6),-(A7)
0000160E  4879 0000 2505          pea       @m68kde~1_25.L
00001612  5338      
00001614  4EB9 0000 2506          jsr       _printf
00001618  3C28      
0000161A  504F      2507          addq.w    #8,A7
0000161C  4E5E      2508          unlk      A6
0000161E  4E75      2509          rts
                    2510   ; }
                    2511   ; void printBinary(unsigned char value) {
                    2512   _printBinary:
00001620  4E56 0000 2513          link      A6,#0
00001624  48E7 2020 2514          movem.l   D2/A2,-(A7)
00001628  45F9 0000 2515          lea       _printf.L,A2
0000162C  3C28      
                    2516   ; int i;
                    2517   ; printf("IIC_CRSR Transmit (Binary): ");
0000162E  4879 0000 2518          pea       @m68kde~1_26.L
00001632  534E      
00001634  4E92      2519          jsr       (A2)
00001636  584F      2520          addq.w    #4,A7
                    2521   ; for (i = 7; i >= 0; i--) { // Loop through each bit (from MSB to LSB)
00001638  7407      2522          moveq     #7,D2
                    2523   printBinary_1:
0000163A  0C82 0000 2524          cmp.l     #0,D2
0000163E  0000      
00001640  6D22      2525          blt.s     printBinary_3
                    2526   ; printf("%d", (value >> i) & 1); // Shift and mask to extract each bit
00001642  122E 000B 2527          move.b    11(A6),D1
00001646  C2BC 0000 2528          and.l     #255,D1
0000164A  00FF      
0000164C  E4A1      2529          asr.l     D2,D1
0000164E  C2BC 0000 2530          and.l     #1,D1
00001652  0001      
00001654  2F01      2531          move.l    D1,-(A7)
00001656  4879 0000 2532          pea       @m68kde~1_27.L
0000165A  536C      
0000165C  4E92      2533          jsr       (A2)
0000165E  504F      2534          addq.w    #8,A7
00001660  5382      2535          subq.l    #1,D2
00001662  60D6      2536          bra       printBinary_1
                    2537   printBinary_3:
                    2538   ; }
                    2539   ; printf("\n");
00001664  4879 0000 2540          pea       @m68kde~1_28.L
00001668  5370      
0000166A  4E92      2541          jsr       (A2)
0000166C  584F      2542          addq.w    #4,A7
0000166E  4CDF 0404 2543          movem.l   (A7)+,D2/A2
00001672  4E5E      2544          unlk      A6
00001674  4E75      2545          rts
                    2546   ; }
                    2547   ; void IICCoreEnable() {
                    2548   _IICCoreEnable:
                    2549   ; IIC_CTR |= 0x80;     // Enable I2C core in control register (1000_0000)
00001676  0039 0080 2550          or.b      #128,4227076
0000167A  0040 8004 
0000167E  4E75      2551          rts
                    2552   ; }
                    2553   ; void IICCoreDisable() {
                    2554   _IICCoreDisable:
                    2555   ; IIC_CTR &= 0x7F;    // Disable I2C core in control register (0011_1111)
00001680  0239 007F 2556          and.b     #127,4227076
00001684  0040 8004 
00001688  4E75      2557          rts
                    2558   ; }
                    2559   ; // I2C Driver Functions
                    2560   ; void IIC_Init(void) {
                    2561   _IIC_Init:
                    2562   ; IIC_PRER_LO = 0x59;  // Scale the I2C clock from 45 Mhz to 100 Khz
0000168A  13FC 0059 2563          move.b    #89,4227072
0000168E  0040 8000 
                    2564   ; IIC_PRER_HI = 0x00;  // Scale the I2C clock from 45 Mhz to 100 Khz
00001692  4239 0040 2565          clr.b     4227074
00001696  8002      
                    2566   ; IIC_CTR &= 0xBF;     // Disable interrupt in control register (1011_1111)
00001698  0239 00BF 2567          and.b     #191,4227076
0000169C  0040 8004 
                    2568   ; IICCoreEnable();
000016A0  4EB8 1676 2569          jsr       _IICCoreEnable
000016A4  4E75      2570          rts
                    2571   ; }
                    2572   ; void wait5ms(void) {
                    2573   _wait5ms:
000016A6  2F02      2574          move.l    D2,-(A7)
                    2575   ; int i;
                    2576   ; for (i = 0; i < 10000; i++); // Wait for 5 ms
000016A8  4282      2577          clr.l     D2
                    2578   wait5ms_1:
000016AA  0C82 0000 2579          cmp.l     #10000,D2
000016AE  2710      
000016B0  6C04      2580          bge.s     wait5ms_3
000016B2  5282      2581          addq.l    #1,D2
000016B4  60F4      2582          bra       wait5ms_1
                    2583   wait5ms_3:
000016B6  241F      2584          move.l    (A7)+,D2
000016B8  4E75      2585          rts
                    2586   ; }
                    2587   ; void checkTIP() {
                    2588   _checkTIP:
                    2589   ; while (IIC_CRSR & TIP);
                    2590   checkTIP_1:
000016BA  1039 0040 2591          move.b    4227080,D0
000016BE  8008      
000016C0  C03C 0002 2592          and.b     #2,D0
000016C4  6702      2593          beq.s     checkTIP_3
000016C6  60F2      2594          bra       checkTIP_1
                    2595   checkTIP_3:
000016C8  4E75      2596          rts
                    2597   ; }
                    2598   ; void checkAck() {
                    2599   _checkAck:
                    2600   ; while ((IIC_CRSR & RXACK) == 1);
                    2601   checkAck_1:
000016CA  1039 0040 2602          move.b    4227080,D0
000016CE  8008      
000016D0  C07C 00FF 2603          and.w     #255,D0
000016D4  C07C 0080 2604          and.w     #128,D0
000016D8  0C40 0001 2605          cmp.w     #1,D0
000016DC  6602      2606          bne.s     checkAck_3
000016DE  60EA      2607          bra       checkAck_1
                    2608   checkAck_3:
000016E0  4E75      2609          rts
                    2610   ; }
                    2611   ; void IICStopCondition() {
                    2612   _IICStopCondition:
                    2613   ; IIC_CRSR |= STOP | READ | IACK; // STOP + READ + IACK
000016E2  0039 0061 2614          or.b      #97,4227080
000016E6  0040 8008 
                    2615   ; checkTIP();
000016EA  4EB8 16BA 2616          jsr       _checkTIP
000016EE  4E75      2617          rts
                    2618   ; }
                    2619   ; void IICStartCondition(int rwBit) {
                    2620   _IICStartCondition:
000016F0  4E56 0000 2621          link      A6,#0
                    2622   ; if (rwBit == 0) {
000016F4  202E 0008 2623          move.l    8(A6),D0
000016F8  660A      2624          bne.s     IICStartCondition_1
                    2625   ; IIC_CRSR |= START | WRITE | IACK; // START + WRITE + IACK
000016FA  0039 0091 2626          or.b      #145,4227080
000016FE  0040 8008 
00001702  6008      2627          bra.s     IICStartCondition_2
                    2628   IICStartCondition_1:
                    2629   ; } else {
                    2630   ; IIC_CRSR |= START | READ | IACK; // Start condition with read bit set
00001704  0039 00A1 2631          or.b      #161,4227080
00001708  0040 8008 
                    2632   IICStartCondition_2:
                    2633   ; }
                    2634   ; checkTIP();
0000170C  4EB8 16BA 2635          jsr       _checkTIP
                    2636   ; checkAck();
00001710  4EB8 16CA 2637          jsr       _checkAck
00001714  4E5E      2638          unlk      A6
00001716  4E75      2639          rts
                    2640   ; }
                    2641   ; // EEPROM Address: 101000{B0} 
                    2642   ; // EEPROM Specific Functions
                    2643   ; void EEPROMByteWrite(unsigned int data, unsigned int deviceAddr, unsigned int memoryAddr) {
                    2644   _EEPROMByteWrite:
00001718  4E56 0000 2645          link      A6,#0
0000171C  48E7 3030 2646          movem.l   D2/D3/A2/A3,-(A7)
00001720  45F8 16BA 2647          lea       _checkTIP.L,A2
00001724  47F8 16CA 2648          lea       _checkAck.L,A3
00001728  242E 000C 2649          move.l    12(A6),D2
0000172C  262E 0010 2650          move.l    16(A6),D3
                    2651   ; // Check if there is a transmission in progress
                    2652   ; // IICCoreEnable();
                    2653   ; if (memoryAddr < 0x10000) {
00001730  0C83 0001 2654          cmp.l     #65536,D3
00001734  0000      
00001736  6404      2655          bhs.s     EEPROMByteWrite_1
                    2656   ; deviceAddr = EEPROM0;
00001738  7450      2657          moveq     #80,D2
0000173A  6002      2658          bra.s     EEPROMByteWrite_2
                    2659   EEPROMByteWrite_1:
                    2660   ; } else {
                    2661   ; deviceAddr = EEPROM1;
0000173C  7451      2662          moveq     #81,D2
                    2663   EEPROMByteWrite_2:
                    2664   ; }
                    2665   ; checkTIP();
0000173E  4E92      2666          jsr       (A2)
                    2667   ; // Set the start condition
                    2668   ; // IICStartCondition(0);
                    2669   ; // printf("Status Register 1: %x\n", IIC_CRSR);
                    2670   ; // printf("Status Register 1: %x\n", IIC_CRSR);
                    2671   ; // Control code, chip select, and block select (ie: Slave Address) and the R/W bit (== 0) are sent
                    2672   ; IIC_TXRX = ((deviceAddr << 1) & 0xFE);
00001740  2002      2673          move.l    D2,D0
00001742  E388      2674          lsl.l     #1,D0
00001744  C0BC 0000 2675          and.l     #254,D0
00001748  00FE      
0000174A  13C0 0040 2676          move.b    D0,4227078
0000174E  8006      
                    2677   ; IIC_CRSR = START | WRITE | IACK;
00001750  13FC 0091 2678          move.b    #145,4227080
00001754  0040 8008 
                    2679   ; // printf("Sent Slave Address: %02x\n", (deviceAddr << 1) & 0xFE);
                    2680   ; checkTIP();
00001758  4E92      2681          jsr       (A2)
                    2682   ; checkAck();
0000175A  4E93      2683          jsr       (A3)
                    2684   ; // printf("Status Register 2: %x\n", IIC_CRSR);
                    2685   ; // Check for ACK
                    2686   ; // printf("\r\n Slave Address Ack Status: : %d\n", checkAck()); //TIP is checked in checkAck function
                    2687   ; // Send the high-order byte of the address
                    2688   ; IIC_TXRX = (memoryAddr >> 8) & 0xFF;
0000175C  2003      2689          move.l    D3,D0
0000175E  E088      2690          lsr.l     #8,D0
00001760  C0BC 0000 2691          and.l     #255,D0
00001764  00FF      
00001766  13C0 0040 2692          move.b    D0,4227078
0000176A  8006      
                    2693   ; IIC_CRSR = WRITE | IACK;
0000176C  13FC 0011 2694          move.b    #17,4227080
00001770  0040 8008 
                    2695   ; checkTIP();
00001774  4E92      2696          jsr       (A2)
                    2697   ; checkAck();
00001776  4E93      2698          jsr       (A3)
                    2699   ; // printf("Sent Upper Memory Byte: %02x\n", memoryAddr >> 8);
                    2700   ; // Send the lower-order byte of the address
                    2701   ; IIC_TXRX = (memoryAddr & 0xFF);
00001778  2003      2702          move.l    D3,D0
0000177A  C0BC 0000 2703          and.l     #255,D0
0000177E  00FF      
00001780  13C0 0040 2704          move.b    D0,4227078
00001784  8006      
                    2705   ; IIC_CRSR = WRITE | IACK;
00001786  13FC 0011 2706          move.b    #17,4227080
0000178A  0040 8008 
                    2707   ; checkTIP();
0000178E  4E92      2708          jsr       (A2)
                    2709   ; checkAck();
00001790  4E93      2710          jsr       (A3)
                    2711   ; //printf("Sent Lower Memory Byte: %02x\n", memoryAddr & 0xFF);
                    2712   ; // printf("Status Register 4: %x\n", IIC_CRSR);
                    2713   ; // Transmit byte to be written
                    2714   ; IIC_TXRX = data;
00001792  202E 0008 2715          move.l    8(A6),D0
00001796  13C0 0040 2716          move.b    D0,4227078
0000179A  8006      
                    2717   ; IIC_CRSR = STOP | WRITE | IACK;
0000179C  13FC 0051 2718          move.b    #81,4227080
000017A0  0040 8008 
                    2719   ; checkTIP();
000017A4  4E92      2720          jsr       (A2)
                    2721   ; checkAck();
000017A6  4E93      2722          jsr       (A3)
                    2723   ; wait5ms();
000017A8  4EB8 16A6 2724          jsr       _wait5ms
000017AC  4CDF 0C0C 2725          movem.l   (A7)+,D2/D3/A2/A3
000017B0  4E5E      2726          unlk      A6
000017B2  4E75      2727          rts
                    2728   ; // printf("Sent Data: %02x\n", data);
                    2729   ; // printf("Sent Stop Condition");
                    2730   ; // printf("Status Register 6: %x\n", IIC_CRSR);
                    2731   ; // IICCoreDisable();
                    2732   ; //printf("\r\nI2C Byte Write Complete\n");
                    2733   ; }
                    2734   ; void EEPROMFlashPageWrite(int* data, unsigned int startingGlobalAddress, unsigned int numBytes, int fullMemory) {
                    2735   _EEPROMFlashPageWrite:
000017B4  4E56 0000 2736          link      A6,#0
000017B8  48E7 3F3C 2737          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
000017BC  282E 000C 2738          move.l    12(A6),D4
000017C0  45F8 16BA 2739          lea       _checkTIP.L,A2
000017C4  47F8 16CA 2740          lea       _checkAck.L,A3
000017C8  2A6E 0010 2741          move.l    16(A6),A5
                    2742   ; unsigned int currentAddress = startingGlobalAddress; 
000017CC  2404      2743          move.l    D4,D2
                    2744   ; unsigned int endAddress = startingGlobalAddress + numBytes;
000017CE  2004      2745          move.l    D4,D0
000017D0  D08D      2746          add.l     A5,D0
000017D2  2C00      2747          move.l    D0,D6
                    2748   ; unsigned int blockAddress;
                    2749   ; unsigned int deviceAddress;
                    2750   ; unsigned int pageFlag;
                    2751   ; unsigned int currIndex = 0;
000017D4  387C 0000 2752          move.w    #0,A4
                    2753   ; startingGlobalAddress = startingGlobalAddress & 0xFFFF; // Mask to 16 bits
000017D8  C8BC 0000 2754          and.l     #65535,D4
000017DC  FFFF      
                    2755   ; currentAddress = startingGlobalAddress; 
000017DE  2404      2756          move.l    D4,D2
                    2757   ; endAddress = startingGlobalAddress + numBytes;
000017E0  2004      2758          move.l    D4,D0
000017E2  D08D      2759          add.l     A5,D0
000017E4  2C00      2760          move.l    D0,D6
                    2761   ; printf("EEPROM Flash Page Write: Start Address: 0x%x, numbytes: %d\n", startingGlobalAddress, numBytes);
000017E6  2F0D      2762          move.l    A5,-(A7)
000017E8  2F04      2763          move.l    D4,-(A7)
000017EA  4879 0000 2764          pea       @m68kde~1_29.L
000017EE  5372      
000017F0  4EB9 0000 2765          jsr       _printf
000017F4  3C28      
000017F6  DEFC 000C 2766          add.w     #12,A7
                    2767   ; if (currentAddress < 0x10000) {
000017FA  0C82 0001 2768          cmp.l     #65536,D2
000017FE  0000      
00001800  6406      2769          bhs.s     EEPROMFlashPageWrite_1
                    2770   ; blockAddress = startingGlobalAddress; // Lower 64KB block
00001802  2604      2771          move.l    D4,D3
                    2772   ; deviceAddress = EEPROM0;
00001804  7A50      2773          moveq     #80,D5
00001806  600C      2774          bra.s     EEPROMFlashPageWrite_2
                    2775   EEPROMFlashPageWrite_1:
                    2776   ; } else {
                    2777   ; blockAddress = startingGlobalAddress - 0x10000; // Upper 64KB block
00001808  2004      2778          move.l    D4,D0
0000180A  0480 0001 2779          sub.l     #65536,D0
0000180E  0000      
00001810  2600      2780          move.l    D0,D3
                    2781   ; deviceAddress = EEPROM1;
00001812  7A51      2782          moveq     #81,D5
                    2783   EEPROMFlashPageWrite_2:
                    2784   ; }
                    2785   ; checkTIP();
00001814  4E92      2786          jsr       (A2)
                    2787   ; while (currentAddress < endAddress) {
                    2788   EEPROMFlashPageWrite_3:
00001816  B486      2789          cmp.l     D6,D2
00001818  6400 0106 2790          bhs       EEPROMFlashPageWrite_5
                    2791   ; // printf("Entered New Page, Current Address: %d, End Address: %d\n", currentAddress, endAddress);
                    2792   ; if (currentAddress == 0x10000) {
0000181C  0C82 0001 2793          cmp.l     #65536,D2
00001820  0000      
00001822  6604      2794          bne.s     EEPROMFlashPageWrite_6
                    2795   ; blockAddress = 0; // Reset to beginning of Block 1
00001824  4283      2796          clr.l     D3
00001826  6016      2797          bra.s     EEPROMFlashPageWrite_7
                    2798   EEPROMFlashPageWrite_6:
                    2799   ; } 
                    2800   ; else {
                    2801   ; blockAddress = (currentAddress < 0x10000) ? currentAddress : (currentAddress - 0x10000);
00001828  0C82 0001 2802          cmp.l     #65536,D2
0000182C  0000      
0000182E  6404      2803          bhs.s     EEPROMFlashPageWrite_8
00001830  2002      2804          move.l    D2,D0
00001832  6008      2805          bra.s     EEPROMFlashPageWrite_9
                    2806   EEPROMFlashPageWrite_8:
00001834  2002      2807          move.l    D2,D0
00001836  0480 0001 2808          sub.l     #65536,D0
0000183A  0000      
                    2809   EEPROMFlashPageWrite_9:
0000183C  2600      2810          move.l    D0,D3
                    2811   EEPROMFlashPageWrite_7:
                    2812   ; }    
                    2813   ; pageFlag = 1;
0000183E  7E01      2814          moveq     #1,D7
                    2815   ; // START condition
                    2816   ; IIC_TXRX = (deviceAddress << 1) & 0xFE;    // Upper 64KB block
00001840  2005      2817          move.l    D5,D0
00001842  E388      2818          lsl.l     #1,D0
00001844  C0BC 0000 2819          and.l     #254,D0
00001848  00FE      
0000184A  13C0 0040 2820          move.b    D0,4227078
0000184E  8006      
                    2821   ; IIC_CRSR = START | WRITE | IACK;
00001850  13FC 0091 2822          move.b    #145,4227080
00001854  0040 8008 
                    2823   ; checkTIP();
00001858  4E92      2824          jsr       (A2)
                    2825   ; checkAck();
0000185A  4E93      2826          jsr       (A3)
                    2827   ; // Send the two address bytes
                    2828   ; // Send the high-order byte of the address
                    2829   ; IIC_TXRX = (blockAddress >> 8) & 0xFF;
0000185C  2003      2830          move.l    D3,D0
0000185E  E088      2831          lsr.l     #8,D0
00001860  C0BC 0000 2832          and.l     #255,D0
00001864  00FF      
00001866  13C0 0040 2833          move.b    D0,4227078
0000186A  8006      
                    2834   ; IIC_CRSR = WRITE | IACK;
0000186C  13FC 0011 2835          move.b    #17,4227080
00001870  0040 8008 
                    2836   ; checkTIP();
00001874  4E92      2837          jsr       (A2)
                    2838   ; checkAck();
00001876  4E93      2839          jsr       (A3)
                    2840   ; // printf("Sent Upper Memory Byte: %02x\n", memoryAddr >> 8);
                    2841   ; // Send the lower-order byte of the address
                    2842   ; IIC_TXRX = (blockAddress & 0xFF);
00001878  2003      2843          move.l    D3,D0
0000187A  C0BC 0000 2844          and.l     #255,D0
0000187E  00FF      
00001880  13C0 0040 2845          move.b    D0,4227078
00001884  8006      
                    2846   ; IIC_CRSR = WRITE | IACK;
00001886  13FC 0011 2847          move.b    #17,4227080
0000188A  0040 8008 
                    2848   ; checkTIP();
0000188E  4E92      2849          jsr       (A2)
                    2850   ; checkAck();
00001890  4E93      2851          jsr       (A3)
                    2852   ; while (pageFlag) {
                    2853   EEPROMFlashPageWrite_10:
00001892  4A87      2854          tst.l     D7
00001894  6700 0086 2855          beq       EEPROMFlashPageWrite_12
                    2856   ; if (fullMemory) {        
00001898  4AAE 0014 2857          tst.l     20(A6)
0000189C  670E      2858          beq.s     EEPROMFlashPageWrite_13
                    2859   ; IIC_TXRX = data[0];
0000189E  206E 0008 2860          move.l    8(A6),A0
000018A2  2010      2861          move.l    (A0),D0
000018A4  13C0 0040 2862          move.b    D0,4227078
000018A8  8006      
000018AA  6012      2863          bra.s     EEPROMFlashPageWrite_14
                    2864   EEPROMFlashPageWrite_13:
                    2865   ; } else {
                    2866   ; IIC_TXRX = data[currIndex];
000018AC  206E 0008 2867          move.l    8(A6),A0
000018B0  200C      2868          move.l    A4,D0
000018B2  E588      2869          lsl.l     #2,D0
000018B4  2030 0800 2870          move.l    0(A0,D0.L),D0
000018B8  13C0 0040 2871          move.b    D0,4227078
000018BC  8006      
                    2872   EEPROMFlashPageWrite_14:
                    2873   ; }
                    2874   ; if (currentAddress == 0xFFFF) {
000018BE  0C82 0000 2875          cmp.l     #65535,D2
000018C2  FFFF      
000018C4  6602      2876          bne.s     EEPROMFlashPageWrite_15
                    2877   ; deviceAddress = EEPROM1;  // Switch to next device for next byte
000018C6  7A51      2878          moveq     #81,D5
                    2879   EEPROMFlashPageWrite_15:
                    2880   ; }
                    2881   ; if (blockAddress % 128 == 127 || currentAddress == endAddress - 1 || currentAddress == 0xFFFF) {
000018C8  2F03      2882          move.l    D3,-(A7)
000018CA  4878 0080 2883          pea       128
000018CE  4EB9 0000 2884          jsr       ULDIV
000018D2  3C6A      
000018D4  202F 0004 2885          move.l    4(A7),D0
000018D8  504F      2886          addq.w    #8,A7
000018DA  0C80 0000 2887          cmp.l     #127,D0
000018DE  007F      
000018E0  6710      2888          beq.s     EEPROMFlashPageWrite_19
000018E2  2006      2889          move.l    D6,D0
000018E4  5380      2890          subq.l    #1,D0
000018E6  B480      2891          cmp.l     D0,D2
000018E8  6708      2892          beq.s     EEPROMFlashPageWrite_19
000018EA  0C82 0000 2893          cmp.l     #65535,D2
000018EE  FFFF      
000018F0  6614      2894          bne.s     EEPROMFlashPageWrite_17
                    2895   EEPROMFlashPageWrite_19:
                    2896   ; IIC_CRSR = STOP | WRITE | IACK;
000018F2  13FC 0051 2897          move.b    #81,4227080
000018F6  0040 8008 
                    2898   ; pageFlag = 0;
000018FA  7E00      2899          moveq     #0,D7
                    2900   ; checkTIP();
000018FC  4E92      2901          jsr       (A2)
                    2902   ; checkAck();
000018FE  4E93      2903          jsr       (A3)
                    2904   ; wait5ms();
00001900  4EB8 16A6 2905          jsr       _wait5ms
00001904  600C      2906          bra.s     EEPROMFlashPageWrite_18
                    2907   EEPROMFlashPageWrite_17:
                    2908   ; } else {
                    2909   ; IIC_CRSR = WRITE | IACK;
00001906  13FC 0011 2910          move.b    #17,4227080
0000190A  0040 8008 
                    2911   ; checkTIP();
0000190E  4E92      2912          jsr       (A2)
                    2913   ; checkAck();
00001910  4E93      2914          jsr       (A3)
                    2915   EEPROMFlashPageWrite_18:
                    2916   ; }
                    2917   ; // ("Current Address: %d, End Address: %d, Block Address: %d\n", currentAddress, endAddress, blockAddress);
                    2918   ; currIndex++;
00001912  524C      2919          addq.w    #1,A4
                    2920   ; currentAddress++;
00001914  5282      2921          addq.l    #1,D2
                    2922   ; blockAddress++;  // Increment blockAddress WITH currentAddress
00001916  5283      2923          addq.l    #1,D3
00001918  6000 FF78 2924          bra       EEPROMFlashPageWrite_10
                    2925   EEPROMFlashPageWrite_12:
0000191C  6000 FEF8 2926          bra       EEPROMFlashPageWrite_3
                    2927   EEPROMFlashPageWrite_5:
00001920  4CDF 3CFC 2928          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
00001924  4E5E      2929          unlk      A6
00001926  4E75      2930          rts
                    2931   ; }
                    2932   ; }
                    2933   ; }
                    2934   ; int EEPROMRandomRead(unsigned int deviceAddr, unsigned readAddr) {
                    2935   _EEPROMRandomRead:
00001928  4E56 FFFC 2936          link      A6,#-4
0000192C  48E7 3030 2937          movem.l   D2/D3/A2/A3,-(A7)
00001930  45F8 16BA 2938          lea       _checkTIP.L,A2
00001934  47F8 16CA 2939          lea       _checkAck.L,A3
00001938  242E 0008 2940          move.l    8(A6),D2
0000193C  262E 000C 2941          move.l    12(A6),D3
                    2942   ; unsigned int readData;
                    2943   ; if (readAddr < 0x10000) {
00001940  0C83 0001 2944          cmp.l     #65536,D3
00001944  0000      
00001946  6404      2945          bhs.s     EEPROMRandomRead_1
                    2946   ; deviceAddr = EEPROM0;
00001948  7450      2947          moveq     #80,D2
0000194A  6002      2948          bra.s     EEPROMRandomRead_2
                    2949   EEPROMRandomRead_1:
                    2950   ; } else {
                    2951   ; deviceAddr = EEPROM1;
0000194C  7451      2952          moveq     #81,D2
                    2953   EEPROMRandomRead_2:
                    2954   ; }
                    2955   ; // Wait for bus to be idle
                    2956   ; // IICCoreEnable(); 
                    2957   ; checkTIP(); 
0000194E  4E92      2958          jsr       (A2)
                    2959   ; // Print TXRX register
                    2960   ; // Send start condition for a write
                    2961   ; IIC_TXRX = ((deviceAddr << 1) & 0xFE);
00001950  2002      2962          move.l    D2,D0
00001952  E388      2963          lsl.l     #1,D0
00001954  C0BC 0000 2964          and.l     #254,D0
00001958  00FE      
0000195A  13C0 0040 2965          move.b    D0,4227078
0000195E  8006      
                    2966   ; IIC_CRSR = START | WRITE | IACK;
00001960  13FC 0091 2967          move.b    #145,4227080
00001964  0040 8008 
                    2968   ; checkTIP();
00001968  4E92      2969          jsr       (A2)
                    2970   ; checkAck();
0000196A  4E93      2971          jsr       (A3)
                    2972   ; //printf("Sending Slave Address: %02x\n", (deviceAddr << 1) & 0xFE);
                    2973   ; // Send the high-order byte of the address
                    2974   ; IIC_TXRX = (readAddr >> 8) & 0xFF;
0000196C  2003      2975          move.l    D3,D0
0000196E  E088      2976          lsr.l     #8,D0
00001970  C0BC 0000 2977          and.l     #255,D0
00001974  00FF      
00001976  13C0 0040 2978          move.b    D0,4227078
0000197A  8006      
                    2979   ; IIC_CRSR = WRITE | IACK;
0000197C  13FC 0011 2980          move.b    #17,4227080
00001980  0040 8008 
                    2981   ; //printf("Sent Upper Memory Byte: %02x\n", readAddr >> 8);
                    2982   ; checkTIP();
00001984  4E92      2983          jsr       (A2)
                    2984   ; checkAck();
00001986  4E93      2985          jsr       (A3)
                    2986   ; // Send the low-order byte of the address
                    2987   ; IIC_TXRX = (readAddr & 0xFF);
00001988  2003      2988          move.l    D3,D0
0000198A  C0BC 0000 2989          and.l     #255,D0
0000198E  00FF      
00001990  13C0 0040 2990          move.b    D0,4227078
00001994  8006      
                    2991   ; IIC_CRSR = WRITE | IACK;
00001996  13FC 0011 2992          move.b    #17,4227080
0000199A  0040 8008 
                    2993   ; //printf("Sent Lower Memory Byte: %02x\n", readAddr & 0xFF);
                    2994   ; checkTIP();
0000199E  4E92      2995          jsr       (A2)
                    2996   ; checkAck();
000019A0  4E93      2997          jsr       (A3)
                    2998   ; // send START condition again followed by slave address with R/W set to 1
                    2999   ; IIC_TXRX = ((deviceAddr << 1) | 0x01);
000019A2  2002      3000          move.l    D2,D0
000019A4  E388      3001          lsl.l     #1,D0
000019A6  80BC 0000 3002          or.l      #1,D0
000019AA  0001      
000019AC  13C0 0040 3003          move.b    D0,4227078
000019B0  8006      
                    3004   ; IIC_CRSR = START | WRITE | IACK;
000019B2  13FC 0091 3005          move.b    #145,4227080
000019B6  0040 8008 
                    3006   ; checkTIP();
000019BA  4E92      3007          jsr       (A2)
                    3008   ; checkAck();
000019BC  4E93      3009          jsr       (A3)
                    3010   ; // IICStopCondition();
                    3011   ; IIC_CRSR = STOP | READ | IACK | NACK; // STOP + READ + IACK + NACK
000019BE  13FC 0069 3012          move.b    #105,4227080
000019C2  0040 8008 
                    3013   ; checkTIP();
000019C6  4E92      3014          jsr       (A2)
                    3015   ; // Check if IF flag is sent, and if so read the data
                    3016   ; while (!(IIC_CRSR & 0x1));
                    3017   EEPROMRandomRead_3:
000019C8  1039 0040 3018          move.b    4227080,D0
000019CC  8008      
000019CE  C03C 0001 3019          and.b     #1,D0
000019D2  6602      3020          bne.s     EEPROMRandomRead_5
000019D4  60F2      3021          bra       EEPROMRandomRead_3
                    3022   EEPROMRandomRead_5:
                    3023   ; IIC_CRSR = 0;
000019D6  4239 0040 3024          clr.b     4227080
000019DA  8008      
                    3025   ; readData = IIC_TXRX;
000019DC  1039 0040 3026          move.b    4227078,D0
000019E0  8006      
000019E2  C0BC 0000 3027          and.l     #255,D0
000019E6  00FF      
000019E8  2D40 FFFC 3028          move.l    D0,-4(A6)
                    3029   ; return readData;    
000019EC  202E FFFC 3030          move.l    -4(A6),D0
000019F0  4CDF 0C0C 3031          movem.l   (A7)+,D2/D3/A2/A3
000019F4  4E5E      3032          unlk      A6
000019F6  4E75      3033          rts
                    3034   ; }
                    3035   ; void EEPROMReadBlock0(unsigned int startAddr, int* readLen) {
                    3036   _EEPROMReadBlock0:
000019F8  4E56 FFFC 3037          link      A6,#-4
000019FC  48E7 3C30 3038          movem.l   D2/D3/D4/D5/A2/A3,-(A7)
00001A00  45F8 16BA 3039          lea       _checkTIP.L,A2
00001A04  47F8 16CA 3040          lea       _checkAck.L,A3
00001A08  262E 0008 3041          move.l    8(A6),D3
                    3042   ; unsigned int currAddr;
                    3043   ; unsigned int endAddr;
                    3044   ; unsigned int readData;
                    3045   ; int exitFlag = 0;
00001A0C  4285      3046          clr.l     D5
                    3047   ; startAddr = startAddr & 0xFFFF; // Mask to 16 bits
00001A0E  C6BC 0000 3048          and.l     #65535,D3
00001A12  FFFF      
                    3049   ; currAddr = startAddr;
00001A14  2403      3050          move.l    D3,D2
                    3051   ; endAddr = startAddr + *readLen;
00001A16  2003      3052          move.l    D3,D0
00001A18  206E 000C 3053          move.l    12(A6),A0
00001A1C  D090      3054          add.l     (A0),D0
00001A1E  2800      3055          move.l    D0,D4
                    3056   ; //printf("Start Addr: %d\n Curr Addr: %d, Read Len: %d\n", startAddr, currAddr, *readLen);
                    3057   ; checkTIP();
00001A20  4E92      3058          jsr       (A2)
                    3059   ; IIC_TXRX = ((EEPROM0 << 1) & 0xFE); // Send EEPROM address with write bit
00001A22  13FC 00A0 3060          move.b    #160,4227078
00001A26  0040 8006 
                    3061   ; IIC_CRSR = START | WRITE | IACK; // Start condition with write bit
00001A2A  13FC 0091 3062          move.b    #145,4227080
00001A2E  0040 8008 
                    3063   ; checkTIP();
00001A32  4E92      3064          jsr       (A2)
                    3065   ; checkAck(); 
00001A34  4E93      3066          jsr       (A3)
                    3067   ; IIC_TXRX = (currAddr >> 8) & 0xFF; // Send high byte of address
00001A36  2002      3068          move.l    D2,D0
00001A38  E088      3069          lsr.l     #8,D0
00001A3A  C0BC 0000 3070          and.l     #255,D0
00001A3E  00FF      
00001A40  13C0 0040 3071          move.b    D0,4227078
00001A44  8006      
                    3072   ; IIC_CRSR = WRITE | IACK; // Write command
00001A46  13FC 0011 3073          move.b    #17,4227080
00001A4A  0040 8008 
                    3074   ; checkTIP();
00001A4E  4E92      3075          jsr       (A2)
                    3076   ; checkAck();
00001A50  4E93      3077          jsr       (A3)
                    3078   ; IIC_TXRX = (currAddr & 0xFF); // Send low byte of address
00001A52  2002      3079          move.l    D2,D0
00001A54  C0BC 0000 3080          and.l     #255,D0
00001A58  00FF      
00001A5A  13C0 0040 3081          move.b    D0,4227078
00001A5E  8006      
                    3082   ; IIC_CRSR = WRITE | IACK; // Write command
00001A60  13FC 0011 3083          move.b    #17,4227080
00001A64  0040 8008 
                    3084   ; checkTIP();
00001A68  4E92      3085          jsr       (A2)
                    3086   ; checkAck();
00001A6A  4E93      3087          jsr       (A3)
                    3088   ; // Repeated start condition here:
                    3089   ; IIC_TXRX = ((EEPROM0 << 1) | 0x01); // (A3) Send EEPROM address with read bit
00001A6C  13FC 00A1 3090          move.b    #161,4227078
00001A70  0040 8006 
                    3091   ; IIC_CRSR = START | WRITE | IACK; // Start condition with read bit
00001A74  13FC 0091 3092          move.b    #145,4227080
00001A78  0040 8008 
                    3093   ; checkTIP();
00001A7C  4E92      3094          jsr       (A2)
                    3095   ; checkAck();
00001A7E  4E93      3096          jsr       (A3)
                    3097   ; // Evaluate data here
                    3098   ; for (currAddr = startAddr; currAddr < endAddr; currAddr++) {
00001A80  2403      3099          move.l    D3,D2
                    3100   EEPROMReadBlock0_1:
00001A82  B484      3101          cmp.l     D4,D2
00001A84  6400 009A 3102          bhs       EEPROMReadBlock0_3
                    3103   ; if (currAddr == 0xFFFF || currAddr == endAddr - 1) {
00001A88  0C82 0000 3104          cmp.l     #65535,D2
00001A8C  FFFF      
00001A8E  6708      3105          beq.s     EEPROMReadBlock0_6
00001A90  2004      3106          move.l    D4,D0
00001A92  5380      3107          subq.l    #1,D0
00001A94  B480      3108          cmp.l     D0,D2
00001A96  660C      3109          bne.s     EEPROMReadBlock0_4
                    3110   EEPROMReadBlock0_6:
                    3111   ; IIC_CRSR = STOP | READ | IACK | NACK; // Stop condition with read bit
00001A98  13FC 0069 3112          move.b    #105,4227080
00001A9C  0040 8008 
                    3113   ; exitFlag = 1;
00001AA0  7A01      3114          moveq     #1,D5
00001AA2  6008      3115          bra.s     EEPROMReadBlock0_5
                    3116   EEPROMReadBlock0_4:
                    3117   ; } else {
                    3118   ; IIC_CRSR = (READ | IACK) & (~NACK); // Read command
00001AA4  13FC 0021 3119          move.b    #33,4227080
00001AA8  0040 8008 
                    3120   EEPROMReadBlock0_5:
                    3121   ; }
                    3122   ; (*readLen)--;
00001AAC  206E 000C 3123          move.l    12(A6),A0
00001AB0  5390      3124          subq.l    #1,(A0)
                    3125   ; checkTIP();
00001AB2  4E92      3126          jsr       (A2)
                    3127   ; checkAck(); // Check for ACK
00001AB4  4E93      3128          jsr       (A3)
                    3129   ; // Read data from EEPROM
                    3130   ; while (!(IIC_CRSR & 0x1)); // Wait for IF flag to be set
                    3131   EEPROMReadBlock0_7:
00001AB6  1039 0040 3132          move.b    4227080,D0
00001ABA  8008      
00001ABC  C03C 0001 3133          and.b     #1,D0
00001AC0  6602      3134          bne.s     EEPROMReadBlock0_9
00001AC2  60F2      3135          bra       EEPROMReadBlock0_7
                    3136   EEPROMReadBlock0_9:
                    3137   ; IIC_CRSR = 0; // Clear IF flag
00001AC4  4239 0040 3138          clr.b     4227080
00001AC8  8008      
                    3139   ; readData = IIC_TXRX; // Read data from EEPROM
00001ACA  1039 0040 3140          move.b    4227078,D0
00001ACE  8006      
00001AD0  C0BC 0000 3141          and.l     #255,D0
00001AD4  00FF      
00001AD6  2D40 FFFC 3142          move.l    D0,-4(A6)
                    3143   ; if ((currAddr % 1000) == 0) {
00001ADA  2F02      3144          move.l    D2,-(A7)
00001ADC  4878 03E8 3145          pea       1000
00001AE0  4EB9 0000 3146          jsr       ULDIV
00001AE4  3C6A      
00001AE6  202F 0004 3147          move.l    4(A7),D0
00001AEA  504F      3148          addq.w    #8,A7
00001AEC  4A80      3149          tst.l     D0
00001AEE  6616      3150          bne.s     EEPROMReadBlock0_10
                    3151   ; printf("\r\n Block 0 Address: 0x%04X: %d\n", currAddr, readData);
00001AF0  2F2E FFFC 3152          move.l    -4(A6),-(A7)
00001AF4  2F02      3153          move.l    D2,-(A7)
00001AF6  4879 0000 3154          pea       @m68kde~1_30.L
00001AFA  53AE      
00001AFC  4EB9 0000 3155          jsr       _printf
00001B00  3C28      
00001B02  DEFC 000C 3156          add.w     #12,A7
                    3157   EEPROMReadBlock0_10:
                    3158   ; }
                    3159   ; if (exitFlag) {
00001B06  4A85      3160          tst.l     D5
00001B08  6710      3161          beq.s     EEPROMReadBlock0_12
                    3162   ; printf("\r\n Exiting EEPROM Read Block 0\n");
00001B0A  4879 0000 3163          pea       @m68kde~1_31.L
00001B0E  53CE      
00001B10  4EB9 0000 3164          jsr       _printf
00001B14  3C28      
00001B16  584F      3165          addq.w    #4,A7
                    3166   ; break;
00001B18  6006      3167          bra.s     EEPROMReadBlock0_3
                    3168   EEPROMReadBlock0_12:
00001B1A  5282      3169          addq.l    #1,D2
00001B1C  6000 FF64 3170          bra       EEPROMReadBlock0_1
                    3171   EEPROMReadBlock0_3:
00001B20  4CDF 0C3C 3172          movem.l   (A7)+,D2/D3/D4/D5/A2/A3
00001B24  4E5E      3173          unlk      A6
00001B26  4E75      3174          rts
                    3175   ; }
                    3176   ; }
                    3177   ; }
                    3178   ; // STILL NEED TO TEST BLOCK 1 MORE AND CROSSING THE BLOCK BOUNDARY
                    3179   ; void EEPROMReadBlock1(int startAddr, int* readLen) {
                    3180   _EEPROMReadBlock1:
00001B28  4E56 FFF8 3181          link      A6,#-8
00001B2C  48E7 3030 3182          movem.l   D2/D3/A2/A3,-(A7)
00001B30  45F8 16BA 3183          lea       _checkTIP.L,A2
00001B34  47F8 16CA 3184          lea       _checkAck.L,A3
                    3185   ; unsigned int currAddr = startAddr & 0xFFFF; // Mask to 16 bits
00001B38  202E 0008 3186          move.l    8(A6),D0
00001B3C  C0BC 0000 3187          and.l     #65535,D0
00001B40  FFFF      
00001B42  2400      3188          move.l    D0,D2
                    3189   ; unsigned int endAddr = currAddr + *readLen;
00001B44  2002      3190          move.l    D2,D0
00001B46  206E 000C 3191          move.l    12(A6),A0
00001B4A  D090      3192          add.l     (A0),D0
00001B4C  2D40 FFF8 3193          move.l    D0,-8(A6)
                    3194   ; unsigned int readData;
                    3195   ; int exitFlag = 0;
00001B50  4283      3196          clr.l     D3
                    3197   ; checkTIP();
00001B52  4E92      3198          jsr       (A2)
                    3199   ; IIC_TXRX = ((EEPROM1 << 1) & 0xFE); // Send EEPROM address with write bit
00001B54  13FC 00A2 3200          move.b    #162,4227078
00001B58  0040 8006 
                    3201   ; IIC_CRSR = START | WRITE | IACK; // Start condition with write bit
00001B5C  13FC 0091 3202          move.b    #145,4227080
00001B60  0040 8008 
                    3203   ; checkTIP();
00001B64  4E92      3204          jsr       (A2)
                    3205   ; checkAck(); 
00001B66  4E93      3206          jsr       (A3)
                    3207   ; IIC_TXRX = (currAddr >> 8) & 0xFF; // Send high byte of address
00001B68  2002      3208          move.l    D2,D0
00001B6A  E088      3209          lsr.l     #8,D0
00001B6C  C0BC 0000 3210          and.l     #255,D0
00001B70  00FF      
00001B72  13C0 0040 3211          move.b    D0,4227078
00001B76  8006      
                    3212   ; IIC_CRSR = WRITE | IACK; // Write command
00001B78  13FC 0011 3213          move.b    #17,4227080
00001B7C  0040 8008 
                    3214   ; checkTIP();
00001B80  4E92      3215          jsr       (A2)
                    3216   ; checkAck();
00001B82  4E93      3217          jsr       (A3)
                    3218   ; IIC_TXRX = (currAddr & 0xFF); // Send low byte of address
00001B84  2002      3219          move.l    D2,D0
00001B86  C0BC 0000 3220          and.l     #255,D0
00001B8A  00FF      
00001B8C  13C0 0040 3221          move.b    D0,4227078
00001B90  8006      
                    3222   ; IIC_CRSR = WRITE | IACK; // Write command
00001B92  13FC 0011 3223          move.b    #17,4227080
00001B96  0040 8008 
                    3224   ; checkTIP();
00001B9A  4E92      3225          jsr       (A2)
                    3226   ; checkAck();
00001B9C  4E93      3227          jsr       (A3)
                    3228   ; // Repeated start condition here:
                    3229   ; IIC_TXRX = ((EEPROM1 << 1) | 0x01); // (A3) Send EEPROM address with read bit
00001B9E  13FC 00A3 3230          move.b    #163,4227078
00001BA2  0040 8006 
                    3231   ; IIC_CRSR = START | WRITE | IACK; // Start condition with read bit
00001BA6  13FC 0091 3232          move.b    #145,4227080
00001BAA  0040 8008 
                    3233   ; checkTIP();
00001BAE  4E92      3234          jsr       (A2)
                    3235   ; checkAck();
00001BB0  4E93      3236          jsr       (A3)
                    3237   ; // Evaluate data here
                    3238   ; for (currAddr = startAddr & 0xFFFF; currAddr < endAddr; currAddr++) {
00001BB2  202E 0008 3239          move.l    8(A6),D0
00001BB6  C0BC 0000 3240          and.l     #65535,D0
00001BBA  FFFF      
00001BBC  2400      3241          move.l    D0,D2
                    3242   EEPROMReadBlock1_1:
00001BBE  B4AE FFF8 3243          cmp.l     -8(A6),D2
00001BC2  6400 009A 3244          bhs       EEPROMReadBlock1_3
                    3245   ; if (currAddr == 0xFFFF) {
00001BC6  0C82 0000 3246          cmp.l     #65535,D2
00001BCA  FFFF      
00001BCC  660C      3247          bne.s     EEPROMReadBlock1_4
                    3248   ; IIC_CRSR = STOP | READ | IACK | NACK; // Stop condition with read bit
00001BCE  13FC 0069 3249          move.b    #105,4227080
00001BD2  0040 8008 
                    3250   ; exitFlag = 1;
00001BD6  7601      3251          moveq     #1,D3
00001BD8  6008      3252          bra.s     EEPROMReadBlock1_5
                    3253   EEPROMReadBlock1_4:
                    3254   ; } else {
                    3255   ; IIC_CRSR = (READ | IACK) & (~NACK); // Read command
00001BDA  13FC 0021 3256          move.b    #33,4227080
00001BDE  0040 8008 
                    3257   EEPROMReadBlock1_5:
                    3258   ; }
                    3259   ; (*readLen)--;
00001BE2  206E 000C 3260          move.l    12(A6),A0
00001BE6  5390      3261          subq.l    #1,(A0)
                    3262   ; checkTIP();
00001BE8  4E92      3263          jsr       (A2)
                    3264   ; checkAck(); // Check for ACK
00001BEA  4E93      3265          jsr       (A3)
                    3266   ; // Read data from EEPROM
                    3267   ; while (!IIC_CRSR & 0x1); // Wait for IF flag to be set
                    3268   EEPROMReadBlock1_6:
00001BEC  4A39 0040 3269          tst.b     4227080
00001BF0  8008      
00001BF2  6604      3270          bne.s     EEPROMReadBlock1_9
00001BF4  7001      3271          moveq     #1,D0
00001BF6  6002      3272          bra.s     EEPROMReadBlock1_10
                    3273   EEPROMReadBlock1_9:
00001BF8  4280      3274          clr.l     D0
                    3275   EEPROMReadBlock1_10:
00001BFA  C03C 0001 3276          and.b     #1,D0
00001BFE  6702      3277          beq.s     EEPROMReadBlock1_8
00001C00  60EA      3278          bra       EEPROMReadBlock1_6
                    3279   EEPROMReadBlock1_8:
                    3280   ; IIC_CRSR = 0; // Clear IF flag
00001C02  4239 0040 3281          clr.b     4227080
00001C06  8008      
                    3282   ; readData = IIC_TXRX; // Read data from EEPROM
00001C08  1039 0040 3283          move.b    4227078,D0
00001C0C  8006      
00001C0E  C0BC 0000 3284          and.l     #255,D0
00001C12  00FF      
00001C14  2D40 FFFC 3285          move.l    D0,-4(A6)
                    3286   ; if ((currAddr % 1000) == 0) {
00001C18  2F02      3287          move.l    D2,-(A7)
00001C1A  4878 03E8 3288          pea       1000
00001C1E  4EB9 0000 3289          jsr       ULDIV
00001C22  3C6A      
00001C24  202F 0004 3290          move.l    4(A7),D0
00001C28  504F      3291          addq.w    #8,A7
00001C2A  4A80      3292          tst.l     D0
00001C2C  6616      3293          bne.s     EEPROMReadBlock1_11
                    3294   ; printf("\r\n Block 1 Address: 0x%04X: %d\n", currAddr, readData);
00001C2E  2F2E FFFC 3295          move.l    -4(A6),-(A7)
00001C32  2F02      3296          move.l    D2,-(A7)
00001C34  4879 0000 3297          pea       @m68kde~1_32.L
00001C38  53EE      
00001C3A  4EB9 0000 3298          jsr       _printf
00001C3E  3C28      
00001C40  DEFC 000C 3299          add.w     #12,A7
                    3300   EEPROMReadBlock1_11:
                    3301   ; }
                    3302   ; if (exitFlag) {
00001C44  4A83      3303          tst.l     D3
00001C46  6710      3304          beq.s     EEPROMReadBlock1_13
                    3305   ; printf("\r\n Exiting EEPROM Read Block 1\n");
00001C48  4879 0000 3306          pea       @m68kde~1_33.L
00001C4C  540E      
00001C4E  4EB9 0000 3307          jsr       _printf
00001C52  3C28      
00001C54  584F      3308          addq.w    #4,A7
                    3309   ; break;
00001C56  6006      3310          bra.s     EEPROMReadBlock1_3
                    3311   EEPROMReadBlock1_13:
00001C58  5282      3312          addq.l    #1,D2
00001C5A  6000 FF62 3313          bra       EEPROMReadBlock1_1
                    3314   EEPROMReadBlock1_3:
00001C5E  4CDF 0C0C 3315          movem.l   (A7)+,D2/D3/A2/A3
00001C62  4E5E      3316          unlk      A6
00001C64  4E75      3317          rts
                    3318   ; }
                    3319   ; }
                    3320   ; }
                    3321   ; int EEPROMSequentialRead(unsigned int startGlobalAddr, int readLen) {
                    3322   _EEPROMSequentialRead:
00001C66  4E56 0000 3323          link      A6,#0
00001C6A  48E7 2020 3324          movem.l   D2/A2,-(A7)
00001C6E  45EE 000C 3325          lea       12(A6),A2
00001C72  242E 0008 3326          move.l    8(A6),D2
                    3327   ; // REMOVE THIS: startGlobalAddr = startGlobalAddr & 0xFFFF;
                    3328   ; if (startGlobalAddr <= 0xFFFF) {
00001C76  0C82 0000 3329          cmp.l     #65535,D2
00001C7A  FFFF      
00001C7C  6220      3330          bhi.s     EEPROMSequentialRead_1
                    3331   ; EEPROMReadBlock0(startGlobalAddr, &readLen);
00001C7E  2F0A      3332          move.l    A2,-(A7)
00001C80  2F02      3333          move.l    D2,-(A7)
00001C82  4EB8 19F8 3334          jsr       _EEPROMReadBlock0
00001C86  504F      3335          addq.w    #8,A7
                    3336   ; if (readLen > 0) {
00001C88  2012      3337          move.l    (A2),D0
00001C8A  0C80 0000 3338          cmp.l     #0,D0
00001C8E  0000      
00001C90  6F0A      3339          ble.s     EEPROMSequentialRead_3
                    3340   ; EEPROMReadBlock1(0, &readLen);
00001C92  2F0A      3341          move.l    A2,-(A7)
00001C94  42A7      3342          clr.l     -(A7)
00001C96  4EB8 1B28 3343          jsr       _EEPROMReadBlock1
00001C9A  504F      3344          addq.w    #8,A7
                    3345   EEPROMSequentialRead_3:
00001C9C  6012      3346          bra.s     EEPROMSequentialRead_2
                    3347   EEPROMSequentialRead_1:
                    3348   ; }
                    3349   ; } else {
                    3350   ; EEPROMReadBlock1(startGlobalAddr - 0x10000, &readLen);
00001C9E  2F0A      3351          move.l    A2,-(A7)
00001CA0  2202      3352          move.l    D2,D1
00001CA2  0481 0001 3353          sub.l     #65536,D1
00001CA6  0000      
00001CA8  2F01      3354          move.l    D1,-(A7)
00001CAA  4EB8 1B28 3355          jsr       _EEPROMReadBlock1
00001CAE  504F      3356          addq.w    #8,A7
                    3357   EEPROMSequentialRead_2:
00001CB0  4CDF 0404 3358          movem.l   (A7)+,D2/A2
00001CB4  4E5E      3359          unlk      A6
00001CB6  4E75      3360          rts
                    3361   ; }
                    3362   ; }
                    3363   ; // I2CTest() {
                    3364   ; //     unsigned int i, j;
                    3365   ; //     unsigned int readData;
                    3366   ; //     char c, text[150];
                    3367   ; //     unsigned char dataByte;
                    3368   ; //     unsigned int address, size, intBuffer;
                    3369   ; //     unsigned int testChoice = 0;
                    3370   ; //     unsigned char startAddress;
                    3371   ; //     unsigned int dataPattern = 0;
                    3372   ; //     printf("\r\n I2C Test\n");
                    3373   ; //     printf("\r\nInitializing I2C...\n");
                    3374   ; //     IIC_Init();
                    3375   ; //     scanflush();
                    3376   ; //     memset(text, 0, sizeof(text));  // fills with zeros
                    3377   ; //     printf("\r\nChoose option:\n");  // Fixed missing \n
                    3378   ; //     printf("1 Read Single Byte from EEPROM\n");
                    3379   ; //     printf("2 Write Single Byte to EEPROM\n");
                    3380   ; //     printf("3 Read Block of Data from EEPROM\n");
                    3381   ; //     printf("4 Write Block of Data to EEPROM\n");
                    3382   ; //     testChoice = _getch() - 48;    
                    3383   ; //     // Option 1: Read Single Byte
                    3384   ; //     if (testChoice == 1) {
                    3385   ; //         printf("\r\nRead Single Byte\n");
                    3386   ; //         printf("Enter address: 0x");
                    3387   ; //         address = Get8HexDigits(0);
                    3388   ; //         dataByte = EEPROMRandomRead(EEPROM0, address);
                    3389   ; //         printf("Read from address 0x%X: 0x%02X\n", address, dataByte);
                    3390   ; //     }
                    3391   ; //     // Option 2: Write Single Byte
                    3392   ; //     if (testChoice == 2) {
                    3393   ; //         printf("\r\nWrite Single Byte\n"); 
                    3394   ; //         printf("Enter address: 0x");
                    3395   ; //         address = Get8HexDigits(0);
                    3396   ; //         printf("\nEnter which data pattern you want to write into memory\n 0x00 = 0\n 0xB2 = 1\n 0xC3 = 2\n 0xD4 = 3\n");
                    3397   ; //         intBuffer = _getch() - 48;
                    3398   ; //         // scanf("%d", &intBuffer);
                    3399   ; //         switch (intBuffer) {
                    3400   ; //             case(0):
                    3401   ; //                 dataPattern = 0x00; break;
                    3402   ; //             case(1):
                    3403   ; //                 dataPattern = 0xB2; break;
                    3404   ; //             case(2):
                    3405   ; //                 dataPattern = 0xC3; break;
                    3406   ; //             case(3):
                    3407   ; //                 dataPattern = 0xD4; break;
                    3408   ; //         }
                    3409   ; //         dataPattern &= 0xFF;
                    3410   ; //         EEPROMByteWrite(dataPattern, EEPROM0, address);
                    3411   ; //         printf("Wrote 0x%02X to address 0x%X\n", dataPattern, address);
                    3412   ; //         readData = EEPROMRandomRead(EEPROM0, address);
                    3413   ; //         printf("Read back: 0x%02X\n", readData);
                    3414   ; //     }
                    3415   ; //     // Option 3: Read Block of Data
                    3416   ; //     if (testChoice == 3) {
                    3417   ; //         printf("\r\nRead Block of Data\n");
                    3418   ; //         printf("Enter start address (hex): 0x");
                    3419   ; //         startAddress = Get8HexDigits(0);
                    3420   ; //         switch (intBuffer) {
                    3421   ; //             case(0):
                    3422   ; //                 dataPattern = 0x00; break;
                    3423   ; //             case(1):
                    3424   ; //                 dataPattern = 0xB2; break;
                    3425   ; //             case(2):
                    3426   ; //                 dataPattern = 0xC3; break;
                    3427   ; //             case(3):
                    3428   ; //                 dataPattern = 0xD4; break;
                    3429   ; //         }
                    3430   ; //         printf("\nReading %d bytes starting from address 0x%X...\n", numBytes, startAddress);
                    3431   ; //         EEPROMSequentialRead(startAddress, numBytes);
                    3432   ; //     }
                    3433   ; //     // Option 4: Write Block of Data
                    3434   ; //     if (testChoice == 4) {
                    3435   ; //     }
                    3436   ; // Updated I2CTest function with improved EEPROM read and write functionality
                    3437   ; int I2CTest() {
                    3438   _I2CTest:
00001CB8  4E56 FF4C 3439          link      A6,#-180
00001CBC  48E7 3F3C 3440          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
00001CC0  45F9 0000 3441          lea       _printf.L,A2
00001CC4  3C28      
00001CC6  47F8 0F06 3442          lea       _Get8HexDigits.L,A3
00001CCA  49F8 1C66 3443          lea       _EEPROMSequentialRead.L,A4
00001CCE  4BF8 0DCA 3444          lea       __getch.L,A5
                    3445   ; unsigned int i, j;
                    3446   ; unsigned int readData;
                    3447   ; char c, text[150];
                    3448   ; unsigned char dataByte;
                    3449   ; unsigned int address, size, intBuffer;
                    3450   ; unsigned int testChoice = 0;
00001CD2  4285      3451          clr.l     D5
                    3452   ; unsigned int startAddress;
                    3453   ; unsigned int dataPattern = 0;
00001CD4  4282      3454          clr.l     D2
                    3455   ; unsigned int numBytes = 0;
00001CD6  4283      3456          clr.l     D3
                    3457   ; unsigned int totalsize = 0;
00001CD8  42AE FFF8 3458          clr.l     -8(A6)
                    3459   ; int arr[1];
                    3460   ; printf("\r\n I2C Test\n");
00001CDC  4879 0000 3461          pea       @m68kde~1_34.L
00001CE0  542E      
00001CE2  4E92      3462          jsr       (A2)
00001CE4  584F      3463          addq.w    #4,A7
                    3464   ; printf("\r\nInitializing I2C...\n");
00001CE6  4879 0000 3465          pea       @m68kde~1_35.L
00001CEA  543C      
00001CEC  4E92      3466          jsr       (A2)
00001CEE  584F      3467          addq.w    #4,A7
                    3468   ; IIC_Init();
00001CF0  4EB8 168A 3469          jsr       _IIC_Init
                    3470   ; scanflush();
00001CF4  4EB9 0000 3471          jsr       _scanflush
00001CF8  40FA      
                    3472   ; memset(text, 0, sizeof(text));  // fills with zeros
00001CFA  4878 0096 3473          pea       150
00001CFE  42A7      3474          clr.l     -(A7)
00001D00  486E FF5C 3475          pea       -164(A6)
00001D04  4EB9 0000 3476          jsr       _memset
00001D08  3E14      
00001D0A  DEFC 000C 3477          add.w     #12,A7
                    3478   ; printf("\r\nChoose option:\n");
00001D0E  4879 0000 3479          pea       @m68kde~1_36.L
00001D12  5454      
00001D14  4E92      3480          jsr       (A2)
00001D16  584F      3481          addq.w    #4,A7
                    3482   ; printf("1 Read Single Byte from EEPROM\n");
00001D18  4879 0000 3483          pea       @m68kde~1_37.L
00001D1C  5466      
00001D1E  4E92      3484          jsr       (A2)
00001D20  584F      3485          addq.w    #4,A7
                    3486   ; printf("2 Write Single Byte to EEPROM\n");
00001D22  4879 0000 3487          pea       @m68kde~1_38.L
00001D26  5486      
00001D28  4E92      3488          jsr       (A2)
00001D2A  584F      3489          addq.w    #4,A7
                    3490   ; printf("3 Read Block of Data from EEPROM\n");
00001D2C  4879 0000 3491          pea       @m68kde~1_39.L
00001D30  54A6      
00001D32  4E92      3492          jsr       (A2)
00001D34  584F      3493          addq.w    #4,A7
                    3494   ; printf("4 Write Block of Data to EEPROM\n");
00001D36  4879 0000 3495          pea       @m68kde~1_40.L
00001D3A  54C8      
00001D3C  4E92      3496          jsr       (A2)
00001D3E  584F      3497          addq.w    #4,A7
                    3498   ; testChoice = _getch() - 48;    
00001D40  4E95      3499          jsr       (A5)
00001D42  0480 0000 3500          sub.l     #48,D0
00001D46  0030      
00001D48  2A00      3501          move.l    D0,D5
                    3502   ; // Option 1: Read Single Byte
                    3503   ; if (testChoice == 1) {
00001D4A  0C85 0000 3504          cmp.l     #1,D5
00001D4E  0001      
00001D50  6600 004C 3505          bne       I2CTest_1
                    3506   ; printf("\r\nRead Single Byte\n");
00001D54  4879 0000 3507          pea       @m68kde~1_41.L
00001D58  54EA      
00001D5A  4E92      3508          jsr       (A2)
00001D5C  584F      3509          addq.w    #4,A7
                    3510   ; printf("Enter address (hex): 0x");
00001D5E  4879 0000 3511          pea       @m68kde~1_42.L
00001D62  54FE      
00001D64  4E92      3512          jsr       (A2)
00001D66  584F      3513          addq.w    #4,A7
                    3514   ; address = Get8HexDigits(0);
00001D68  42A7      3515          clr.l     -(A7)
00001D6A  4E93      3516          jsr       (A3)
00001D6C  584F      3517          addq.w    #4,A7
00001D6E  2800      3518          move.l    D0,D4
                    3519   ; dataByte = EEPROMRandomRead(EEPROM0, address);
00001D70  2F04      3520          move.l    D4,-(A7)
00001D72  4878 0050 3521          pea       80
00001D76  4EB8 1928 3522          jsr       _EEPROMRandomRead
00001D7A  504F      3523          addq.w    #8,A7
00001D7C  1D40 FFF3 3524          move.b    D0,-13(A6)
                    3525   ; printf("\r\nRead from address 0x%X: 0x%02X\n", address, dataByte);
00001D80  122E FFF3 3526          move.b    -13(A6),D1
00001D84  C2BC 0000 3527          and.l     #255,D1
00001D88  00FF      
00001D8A  2F01      3528          move.l    D1,-(A7)
00001D8C  2F04      3529          move.l    D4,-(A7)
00001D8E  4879 0000 3530          pea       @m68kde~1_43.L
00001D92  5516      
00001D94  4E92      3531          jsr       (A2)
00001D96  DEFC 000C 3532          add.w     #12,A7
00001D9A  6000 0220 3533          bra       I2CTest_17
                    3534   I2CTest_1:
                    3535   ; }
                    3536   ; // Option 2: Write Single Byte
                    3537   ; else if (testChoice == 2) {
00001D9E  0C85 0000 3538          cmp.l     #2,D5
00001DA2  0002      
00001DA4  6600 00DE 3539          bne       I2CTest_3
                    3540   ; printf("\r\nWrite Single Byte\n"); 
00001DA8  4879 0000 3541          pea       @m68kde~1_44.L
00001DAC  5538      
00001DAE  4E92      3542          jsr       (A2)
00001DB0  584F      3543          addq.w    #4,A7
                    3544   ; printf("\r\nEnter address (hex): 0x");
00001DB2  4879 0000 3545          pea       @m68kde~1_45.L
00001DB6  554E      
00001DB8  4E92      3546          jsr       (A2)
00001DBA  584F      3547          addq.w    #4,A7
                    3548   ; address = Get8HexDigits(0);
00001DBC  42A7      3549          clr.l     -(A7)
00001DBE  4E93      3550          jsr       (A3)
00001DC0  584F      3551          addq.w    #4,A7
00001DC2  2800      3552          move.l    D0,D4
                    3553   ; printf("\nEnter which data pattern you want to write into memory:\n");
00001DC4  4879 0000 3554          pea       @m68kde~1_46.L
00001DC8  5568      
00001DCA  4E92      3555          jsr       (A2)
00001DCC  584F      3556          addq.w    #4,A7
                    3557   ; printf(" 0: 0x00\n 1: 0xB2\n 2: 0xC3\n 3: 0xD4\n 4: Custom value\n");
00001DCE  4879 0000 3558          pea       @m68kde~1_47.L
00001DD2  55A2      
00001DD4  4E92      3559          jsr       (A2)
00001DD6  584F      3560          addq.w    #4,A7
                    3561   ; intBuffer = _getch() - 48;
00001DD8  4E95      3562          jsr       (A5)
00001DDA  0480 0000 3563          sub.l     #48,D0
00001DDE  0030      
00001DE0  2E00      3564          move.l    D0,D7
                    3565   ; if (intBuffer == 4) {
00001DE2  0C87 0000 3566          cmp.l     #4,D7
00001DE6  0004      
00001DE8  6618      3567          bne.s     I2CTest_5
                    3568   ; printf("Select pattern");
00001DEA  4879 0000 3569          pea       @m68kde~1_48.L
00001DEE  55D8      
00001DF0  4E92      3570          jsr       (A2)
00001DF2  584F      3571          addq.w    #4,A7
                    3572   ; dataPattern = Get2HexDigits(0);
00001DF4  42A7      3573          clr.l     -(A7)
00001DF6  4EB8 0E66 3574          jsr       _Get2HexDigits
00001DFA  584F      3575          addq.w    #4,A7
00001DFC  2400      3576          move.l    D0,D2
00001DFE  6000 003C 3577          bra       I2CTest_8
                    3578   I2CTest_5:
                    3579   ; } else {
                    3580   ; switch (intBuffer) {
00001E02  2007      3581          move.l    D7,D0
00001E04  0C80 0000 3582          cmp.l     #4,D0
00001E08  0004      
00001E0A  642E      3583          bhs.s     I2CTest_7
00001E0C  E380      3584          asl.l     #1,D0
00001E0E  303B 0806 3585          move.w    I2CTest_9(PC,D0.L),D0
00001E12  4EFB 0002 3586          jmp       I2CTest_9(PC,D0.W)
                    3587   I2CTest_9:
00001E16  0008      3588          dc.w      I2CTest_10-I2CTest_9
00001E18  000C      3589          dc.w      I2CTest_11-I2CTest_9
00001E1A  0014      3590          dc.w      I2CTest_12-I2CTest_9
00001E1C  001C      3591          dc.w      I2CTest_13-I2CTest_9
                    3592   I2CTest_10:
                    3593   ; case 0:
                    3594   ; dataPattern = 0x00; break;
00001E1E  4282      3595          clr.l     D2
00001E20  601A      3596          bra.s     I2CTest_8
                    3597   I2CTest_11:
                    3598   ; case 1:
                    3599   ; dataPattern = 0xB2; break;
00001E22  243C 0000 3600          move.l    #178,D2
00001E26  00B2      
00001E28  6012      3601          bra.s     I2CTest_8
                    3602   I2CTest_12:
                    3603   ; case 2:
                    3604   ; dataPattern = 0xC3; break;
00001E2A  243C 0000 3605          move.l    #195,D2
00001E2E  00C3      
00001E30  600A      3606          bra.s     I2CTest_8
                    3607   I2CTest_13:
                    3608   ; case 3:
                    3609   ; dataPattern = 0xD4; break;
00001E32  243C 0000 3610          move.l    #212,D2
00001E36  00D4      
00001E38  6002      3611          bra.s     I2CTest_8
                    3612   I2CTest_7:
                    3613   ; default:
                    3614   ; dataPattern = 0x00; break;
00001E3A  4282      3615          clr.l     D2
                    3616   I2CTest_8:
                    3617   ; }
                    3618   ; }
                    3619   ; dataPattern &= 0xFF;
00001E3C  C4BC 0000 3620          and.l     #255,D2
00001E40  00FF      
                    3621   ; EEPROMByteWrite(dataPattern, EEPROM0, address);
00001E42  2F04      3622          move.l    D4,-(A7)
00001E44  4878 0050 3623          pea       80
00001E48  2F02      3624          move.l    D2,-(A7)
00001E4A  4EB8 1718 3625          jsr       _EEPROMByteWrite
00001E4E  DEFC 000C 3626          add.w     #12,A7
                    3627   ; printf("Wrote 0x%02X to address 0x%X\n", dataPattern, address);
00001E52  2F04      3628          move.l    D4,-(A7)
00001E54  2F02      3629          move.l    D2,-(A7)
00001E56  4879 0000 3630          pea       @m68kde~1_49.L
00001E5A  55E8      
00001E5C  4E92      3631          jsr       (A2)
00001E5E  DEFC 000C 3632          add.w     #12,A7
                    3633   ; readData = EEPROMRandomRead(EEPROM0, address);
00001E62  2F04      3634          move.l    D4,-(A7)
00001E64  4878 0050 3635          pea       80
00001E68  4EB8 1928 3636          jsr       _EEPROMRandomRead
00001E6C  504F      3637          addq.w    #8,A7
00001E6E  2D40 FF56 3638          move.l    D0,-170(A6)
                    3639   ; printf("Read back: 0x%02X\n", readData);
00001E72  2F2E FF56 3640          move.l    -170(A6),-(A7)
00001E76  4879 0000 3641          pea       @m68kde~1_50.L
00001E7A  5606      
00001E7C  4E92      3642          jsr       (A2)
00001E7E  504F      3643          addq.w    #8,A7
00001E80  6000 013A 3644          bra       I2CTest_17
                    3645   I2CTest_3:
                    3646   ; }
                    3647   ; // Option 3: Read Block of Data
                    3648   ; else if (testChoice == 3) {
00001E84  0C85 0000 3649          cmp.l     #3,D5
00001E88  0003      
00001E8A  6600 004E 3650          bne       I2CTest_15
                    3651   ; printf("\r\nRead Block of Data\n");
00001E8E  4879 0000 3652          pea       @m68kde~1_51.L
00001E92  561A      
00001E94  4E92      3653          jsr       (A2)
00001E96  584F      3654          addq.w    #4,A7
                    3655   ; printf("Enter start address (hex): 0x");
00001E98  4879 0000 3656          pea       @m68kde~1_52.L
00001E9C  5630      
00001E9E  4E92      3657          jsr       (A2)
00001EA0  584F      3658          addq.w    #4,A7
                    3659   ; startAddress = Get8HexDigits(0);
00001EA2  42A7      3660          clr.l     -(A7)
00001EA4  4E93      3661          jsr       (A3)
00001EA6  584F      3662          addq.w    #4,A7
00001EA8  2C00      3663          move.l    D0,D6
                    3664   ; printf("\r\nEnter number of bytes to read (hex): 0x");
00001EAA  4879 0000 3665          pea       @m68kde~1_53.L
00001EAE  564E      
00001EB0  4E92      3666          jsr       (A2)
00001EB2  584F      3667          addq.w    #4,A7
                    3668   ; numBytes = Get8HexDigits(0);
00001EB4  42A7      3669          clr.l     -(A7)
00001EB6  4E93      3670          jsr       (A3)
00001EB8  584F      3671          addq.w    #4,A7
00001EBA  2600      3672          move.l    D0,D3
                    3673   ; printf("\r\nReading 0x%X (%d) bytes starting from address 0x%X...\n", numBytes, numBytes, startAddress);
00001EBC  2F06      3674          move.l    D6,-(A7)
00001EBE  2F03      3675          move.l    D3,-(A7)
00001EC0  2F03      3676          move.l    D3,-(A7)
00001EC2  4879 0000 3677          pea       @m68kde~1_54.L
00001EC6  5678      
00001EC8  4E92      3678          jsr       (A2)
00001ECA  DEFC 0010 3679          add.w     #16,A7
                    3680   ; EEPROMSequentialRead(startAddress, numBytes);
00001ECE  2F03      3681          move.l    D3,-(A7)
00001ED0  2F06      3682          move.l    D6,-(A7)
00001ED2  4E94      3683          jsr       (A4)
00001ED4  504F      3684          addq.w    #8,A7
00001ED6  6000 00E4 3685          bra       I2CTest_17
                    3686   I2CTest_15:
                    3687   ; }
                    3688   ; // Option 4: Write Block of Data
                    3689   ; else if (testChoice == 4) {
00001EDA  0C85 0000 3690          cmp.l     #4,D5
00001EDE  0004      
00001EE0  6600 00DA 3691          bne       I2CTest_17
                    3692   ; printf("\r\nWrite Block of Data\n");
00001EE4  4879 0000 3693          pea       @m68kde~1_55.L
00001EE8  56B2      
00001EEA  4E92      3694          jsr       (A2)
00001EEC  584F      3695          addq.w    #4,A7
                    3696   ; printf("Enter start address (hex): 0x");
00001EEE  4879 0000 3697          pea       @m68kde~1_52.L
00001EF2  5630      
00001EF4  4E92      3698          jsr       (A2)
00001EF6  584F      3699          addq.w    #4,A7
                    3700   ; startAddress = Get8HexDigits(0);
00001EF8  42A7      3701          clr.l     -(A7)
00001EFA  4E93      3702          jsr       (A3)
00001EFC  584F      3703          addq.w    #4,A7
00001EFE  2C00      3704          move.l    D0,D6
                    3705   ; printf("\r\nEnter number of bytes to write (hex): 0x");
00001F00  4879 0000 3706          pea       @m68kde~1_56.L
00001F04  56CA      
00001F06  4E92      3707          jsr       (A2)
00001F08  584F      3708          addq.w    #4,A7
                    3709   ; numBytes = Get8HexDigits(0);
00001F0A  42A7      3710          clr.l     -(A7)
00001F0C  4E93      3711          jsr       (A3)
00001F0E  584F      3712          addq.w    #4,A7
00001F10  2600      3713          move.l    D0,D3
                    3714   ; printf("\r\nEnter which data pattern you want to write into memory:\n");
00001F12  4879 0000 3715          pea       @m68kde~1_57.L
00001F16  56F6      
00001F18  4E92      3716          jsr       (A2)
00001F1A  584F      3717          addq.w    #4,A7
                    3718   ; printf(" 0: 0x00\n 1: 0xB2\n 2: 0xC3\n 3: 0xD4\n 4: Incrementing pattern\n");
00001F1C  4879 0000 3719          pea       @m68kde~1_58.L
00001F20  5732      
00001F22  4E92      3720          jsr       (A2)
00001F24  584F      3721          addq.w    #4,A7
                    3722   ; intBuffer = _getch() - 48;
00001F26  4E95      3723          jsr       (A5)
00001F28  0480 0000 3724          sub.l     #48,D0
00001F2C  0030      
00001F2E  2E00      3725          move.l    D0,D7
                    3726   ; if (intBuffer == 4) {
00001F30  0C87 0000 3727          cmp.l     #4,D7
00001F34  0004      
00001F36  6614      3728          bne.s     I2CTest_19
                    3729   ; printf("Selected incrementing pattern (address & 0xFF)\n");
00001F38  4879 0000 3730          pea       @m68kde~1_59.L
00001F3C  5770      
00001F3E  4E92      3731          jsr       (A2)
00001F40  584F      3732          addq.w    #4,A7
                    3733   ; dataPattern = 0xFF;  // Special marker for incrementing pattern
00001F42  243C 0000 3734          move.l    #255,D2
00001F46  00FF      
00001F48  6000 0048 3735          bra       I2CTest_20
                    3736   I2CTest_19:
                    3737   ; } else {
                    3738   ; switch (intBuffer) {
00001F4C  2007      3739          move.l    D7,D0
00001F4E  0C80 0000 3740          cmp.l     #4,D0
00001F52  0004      
00001F54  642E      3741          bhs.s     I2CTest_21
00001F56  E380      3742          asl.l     #1,D0
00001F58  303B 0806 3743          move.w    I2CTest_23(PC,D0.L),D0
00001F5C  4EFB 0002 3744          jmp       I2CTest_23(PC,D0.W)
                    3745   I2CTest_23:
00001F60  0008      3746          dc.w      I2CTest_24-I2CTest_23
00001F62  000C      3747          dc.w      I2CTest_25-I2CTest_23
00001F64  0014      3748          dc.w      I2CTest_26-I2CTest_23
00001F66  001C      3749          dc.w      I2CTest_27-I2CTest_23
                    3750   I2CTest_24:
                    3751   ; case 0:
                    3752   ; dataPattern = 0x00; break;
00001F68  4282      3753          clr.l     D2
00001F6A  601A      3754          bra.s     I2CTest_22
                    3755   I2CTest_25:
                    3756   ; case 1:
                    3757   ; dataPattern = 0xB2; break;
00001F6C  243C 0000 3758          move.l    #178,D2
00001F70  00B2      
00001F72  6012      3759          bra.s     I2CTest_22
                    3760   I2CTest_26:
                    3761   ; case 2:
                    3762   ; dataPattern = 0xC3; break;
00001F74  243C 0000 3763          move.l    #195,D2
00001F78  00C3      
00001F7A  600A      3764          bra.s     I2CTest_22
                    3765   I2CTest_27:
                    3766   ; case 3:
                    3767   ; dataPattern = 0xD4; break;
00001F7C  243C 0000 3768          move.l    #212,D2
00001F80  00D4      
00001F82  6002      3769          bra.s     I2CTest_22
                    3770   I2CTest_21:
                    3771   ; default:
                    3772   ; dataPattern = 0x00; break;
00001F84  4282      3773          clr.l     D2
                    3774   I2CTest_22:
                    3775   ; }
                    3776   ; printf("Selected pattern: 0x%02X\n", dataPattern);
00001F86  2F02      3777          move.l    D2,-(A7)
00001F88  4879 0000 3778          pea       @m68kde~1_60.L
00001F8C  57A0      
00001F8E  4E92      3779          jsr       (A2)
00001F90  504F      3780          addq.w    #8,A7
                    3781   I2CTest_20:
                    3782   ; }
                    3783   ; printf("\r\nPreparing to write 0x%X (%d) bytes of data starting at address 0x%X...\n", numBytes, numBytes, startAddress);
00001F92  2F06      3784          move.l    D6,-(A7)
00001F94  2F03      3785          move.l    D3,-(A7)
00001F96  2F03      3786          move.l    D3,-(A7)
00001F98  4879 0000 3787          pea       @m68kde~1_61.L
00001F9C  57BA      
00001F9E  4E92      3788          jsr       (A2)
00001FA0  DEFC 0010 3789          add.w     #16,A7
                    3790   ; arr[0] = dataPattern; // Initialize the first byte of the array
00001FA4  2D42 FFFC 3791          move.l    D2,-4+0(A6)
                    3792   ; EEPROMFlashPageWrite(arr, startAddress, numBytes, 1);
00001FA8  4878 0001 3793          pea       1
00001FAC  2F03      3794          move.l    D3,-(A7)
00001FAE  2F06      3795          move.l    D6,-(A7)
00001FB0  486E FFFC 3796          pea       -4(A6)
00001FB4  4EB8 17B4 3797          jsr       _EEPROMFlashPageWrite
00001FB8  DEFC 0010 3798          add.w     #16,A7
                    3799   I2CTest_17:
                    3800   ; }
                    3801   ; if (testChoice == 5) {
00001FBC  0C85 0000 3802          cmp.l     #5,D5
00001FC0  0005      
00001FC2  6600 003E 3803          bne       I2CTest_29
                    3804   ; printf("\r\Printing Entire EEPROM\n");
00001FC6  4879 0000 3805          pea       @m68kde~1_62.L
00001FCA  5804      
00001FCC  4E92      3806          jsr       (A2)
00001FCE  584F      3807          addq.w    #4,A7
                    3808   ; EEPROMSequentialRead(0x0000, 32768);  // First 32KB
00001FD0  4878 8000 3809          pea       32768
00001FD4  42A7      3810          clr.l     -(A7)
00001FD6  4E94      3811          jsr       (A4)
00001FD8  504F      3812          addq.w    #8,A7
                    3813   ; EEPROMSequentialRead(0x8000, 32768);  // Second 32KB
00001FDA  4878 8000 3814          pea       32768
00001FDE  4878 8000 3815          pea       32768
00001FE2  4E94      3816          jsr       (A4)
00001FE4  504F      3817          addq.w    #8,A7
                    3818   ; EEPROMSequentialRead(0x10000, 32768); // Third 32KB
00001FE6  4878 8000 3819          pea       32768
00001FEA  4879 0001 3820          pea       65536
00001FEE  0000      
00001FF0  4E94      3821          jsr       (A4)
00001FF2  504F      3822          addq.w    #8,A7
                    3823   ; EEPROMSequentialRead(0x18000, 32768); // Fourth 32KB
00001FF4  4878 8000 3824          pea       32768
00001FF8  4879 0001 3825          pea       98304
00001FFC  8000      
00001FFE  4E94      3826          jsr       (A4)
00002000  504F      3827          addq.w    #8,A7
                    3828   I2CTest_29:
00002002  4CDF 3CFC 3829          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
00002006  4E5E      3830          unlk      A6
00002008  4E75      3831          rts
                    3832   ; }
                    3833   ; }
                    3834   ; // I2CTest() {
                    3835   ; //   unsigned int arraySize = 512;
                    3836   ; //   unsigned int IICData[512];
                    3837   ; //   unsigned int i;
                    3838   ; //   unsigned int writeData = 0xAB;
                    3839   ; //   unsigned int readData;
                    3840   ; //   unsigned int totalBytes = 0x20000;
                    3841   ; //   for (i = 0; i < arraySize; i++) {
                    3842   ; //     IICData[i] = (i % 50) + 1;
                    3843   ; //     IICData[i] = 0xAA;
                    3844   ; //   } 
                    3845   ; //   printf("\r\n I2C Test\n");
                    3846   ; //   IIC_Init();  
                    3847   ; //   printf("Page Write\n");
                    3848   ; //   EEPROMFlashPageWrite(IICData, 0x0, totalBytes); // Write data to EEPROM
                    3849   ; //   printf("Sequential Read\n");
                    3850   ; //   EEPROMSequentialRead(0x0000, 32768);  // First 32KB
                    3851   ; //   EEPROMSequentialRead(0x8000, 32768);  // Second 32KB
                    3852   ; //   EEPROMSequentialRead(0x10000, 32768); // Third 32KB
                    3853   ; //   EEPROMSequentialRead(0x18000, 32768); // Fourth 32KB
                    3854   ; //   printf("\r\n Starting EEPROM Write: Writing 0x%.2x to address 0x00\n", writeData); // Debug: Indicate the start of EEPROM write
                    3855   ; //   for (i = 0x0; i < 0x5; i++) {
                    3856   ; //     printf("\r\n Writing %d to address %d\n", i * 5, i);
                    3857   ; //     EEPROMByteWrite(i * 5, EEPROM1, i); // Write data to EEPROM
                    3858   ; //   }
                    3859   ; //   printf("\r\nFinished write, Starting EEPROM Read\n");
                    3860   ; //   for (i = 0; i < 5; i++) {
                    3861   ; //     readData = EEPROMRandomRead(EEPROM1, i); // Read data from EEPROM
                    3862   ; //     printf("\r\n Address: %d: %d\n", i, readData); // Debug: Indicate the address being read and the data read
                    3863   ; //   }
                    3864   ; //   // readData = EEPROMRandomRead(EEPROM0, 0x0);
                    3865   ; //   IICCoreDisable();
                    3866   ; // }
                    3867   ; // Initialize and enable I2C controller
                    3868   ; // No interrupts and set clock frequency to 100Khz
                    3869   ; // Connect controller to 25 or 45 Mhz CPU clock
                    3870   ; // Check if device is ready before writing anything over I2C bus ie) TX register has written previous command.
                    3871   ; // Check the status register TIP bit to see when transmission has finished
                    3872   ; // Wait for ACK from slave after each write
                    3873   ; // Transmit a byte to the I2C bus
                    3874   ; // write the data to be transmitted into TX register and then write something to the command register that indiciates that you want to write
                    3875   ; // If you want to generate a start or stop condition, set the STA or STO bits in command register when you write to it,
                    3876   ; // Clear the ACK bit if you want to generate an ACK when reading data back from the slave
                    3877   ; // DAC Functions
                    3878   ; // DAC/ADC Address: 1001001 + R/W
                    3879   ; // Control Byte: Set bit6 on to activate unity gain buffer. lower nibble selects the input channel (For DAC ignored once you enter DAC mode)
                    3880   ; // Calculate sine wave values between 0 and 255 
                    3881   ; // Pseudo code process
                    3882   ; // Init I2C 
                    3883   ; // Control byte sent after the slave address. COnfigure this properly
                    3884   ; // Remaining bits can select input channel mode
                    3885   ; // Generate sine wave
                    3886   ; // WRITE THIS FUNCTION FR FR
                    3887   ; void ADCRead() {
                    3888   _ADCRead:
0000200A  4E56 FFFC 3889          link      A6,#-4
0000200E  48E7 0030 3890          movem.l   A2/A3,-(A7)
00002012  45F9 0B00 3891          lea       _i.L,A2
00002016  00C4      
00002018  47F8 16BA 3892          lea       _checkTIP.L,A3
                    3893   ; unsigned int readData;
                    3894   ; IIC_Init();
0000201C  4EB8 168A 3895          jsr       _IIC_Init
                    3896   ; checkTIP();
00002020  4E93      3897          jsr       (A3)
                    3898   ; IIC_TXRX = ((PCF8591 << 1) | 0x1); // Send EEPROM address with read bit
00002022  13FC 0093 3899          move.b    #147,4227078
00002026  0040 8006 
                    3900   ; IIC_CRSR = START | WRITE | IACK; // Start condition with write bit
0000202A  13FC 0091 3901          move.b    #145,4227080
0000202E  0040 8008 
                    3902   ; checkTIP();
00002032  4E93      3903          jsr       (A3)
                    3904   ; checkAck();
00002034  4EB8 16CA 3905          jsr       _checkAck
                    3906   ; // Read data from ADC continously 
                    3907   ; while(1) {  // Loop continuously
                    3908   ADCRead_1:
                    3909   ; for (i = 0; i < NUM_SAMPLES; i++) {
00002038  4292      3910          clr.l     (A2)
                    3911   ADCRead_4:
0000203A  2012      3912          move.l    (A2),D0
0000203C  0C80 0000 3913          cmp.l     #512,D0
00002040  0200      
00002042  6400 0056 3914          bhs       ADCRead_6
                    3915   ; // Load the triangle wave sample into the I2C transmit register
                    3916   ; IIC_CRSR = (READ | IACK) & (~NACK);  // Initiate I2C write for the data byte
00002046  13FC 0021 3917          move.b    #33,4227080
0000204A  0040 8008 
                    3918   ; checkTIP();  // Wait until the transmission is complete
0000204E  4E93      3919          jsr       (A3)
                    3920   ; while (!IIC_CRSR & 0x1); // Wait for IF flag to be set
                    3921   ADCRead_7:
00002050  4A39 0040 3922          tst.b     4227080
00002054  8008      
00002056  6604      3923          bne.s     ADCRead_10
00002058  7001      3924          moveq     #1,D0
0000205A  6002      3925          bra.s     ADCRead_11
                    3926   ADCRead_10:
0000205C  4280      3927          clr.l     D0
                    3928   ADCRead_11:
0000205E  C03C 0001 3929          and.b     #1,D0
00002062  6702      3930          beq.s     ADCRead_9
00002064  60EA      3931          bra       ADCRead_7
                    3932   ADCRead_9:
                    3933   ; IIC_CRSR = 0; // Clear IF flag
00002066  4239 0040 3934          clr.b     4227080
0000206A  8008      
                    3935   ; readData = IIC_TXRX; // Read data from EEPROM
0000206C  1039 0040 3936          move.b    4227078,D0
00002070  8006      
00002072  C0BC 0000 3937          and.l     #255,D0
00002076  00FF      
00002078  2D40 FFFC 3938          move.l    D0,-4(A6)
                    3939   ; printf("\r\n ADC Read: %d\n", readData); // Debug: Indicate the address being read and the data read
0000207C  2F2E FFFC 3940          move.l    -4(A6),-(A7)
00002080  4879 0000 3941          pea       @m68kde~1_63.L
00002084  581E      
00002086  4EB9 0000 3942          jsr       _printf
0000208A  3C28      
0000208C  504F      3943          addq.w    #8,A7
                    3944   ; wait5ms(); Wait3ms();
0000208E  4EB8 16A6 3945          jsr       _wait5ms
00002092  4EB8 0BA8 3946          jsr       _Wait3ms
00002096  5292      3947          addq.l    #1,(A2)
00002098  60A0      3948          bra       ADCRead_4
                    3949   ADCRead_6:
0000209A  609C      3950          bra       ADCRead_1
                    3951   ; }
                    3952   ; }
                    3953   ; }
                    3954   ; void DACWave() {
                    3955   _DACWave:
0000209C  4E56 F800 3956          link      A6,#-2048
000020A0  48E7 2038 3957          movem.l   D2/A2/A3/A4,-(A7)
000020A4  45F8 16BA 3958          lea       _checkTIP.L,A2
000020A8  47F8 16CA 3959          lea       _checkAck.L,A3
000020AC  49EE F800 3960          lea       -2048(A6),A4
                    3961   ; int triangle_table[NUM_SAMPLES];
                    3962   ; int i;
                    3963   ; // Generate triangle wave samples
                    3964   ; // Ascending part: from 0 to 255
                    3965   ; for(i = 0; i < HALF_SAMPLES; i++) {
000020B0  4282      3966          clr.l     D2
                    3967   DACWave_1:
000020B2  0C82 0000 3968          cmp.l     #256,D2
000020B6  0100      
000020B8  6C0C      3969          bge.s     DACWave_3
                    3970   ; triangle_table[i] = i;  // 0 to 255
000020BA  2002      3971          move.l    D2,D0
000020BC  E588      3972          lsl.l     #2,D0
000020BE  2982 0800 3973          move.l    D2,0(A4,D0.L)
000020C2  5282      3974          addq.l    #1,D2
000020C4  60EC      3975          bra       DACWave_1
                    3976   DACWave_3:
                    3977   ; }
                    3978   ; // Descending part: from 255 back to 0
                    3979   ; for(i = HALF_SAMPLES; i < NUM_SAMPLES; i++) {
000020C6  243C 0000 3980          move.l    #256,D2
000020CA  0100      
                    3981   DACWave_4:
000020CC  0C82 0000 3982          cmp.l     #512,D2
000020D0  0200      
000020D2  6C1C      3983          bge.s     DACWave_6
                    3984   ; triangle_table[i] = 255 - (i - HALF_SAMPLES);
000020D4  303C 00FF 3985          move.w    #255,D0
000020D8  48C0      3986          ext.l     D0
000020DA  2202      3987          move.l    D2,D1
000020DC  0481 0000 3988          sub.l     #256,D1
000020E0  0100      
000020E2  9081      3989          sub.l     D1,D0
000020E4  2202      3990          move.l    D2,D1
000020E6  E589      3991          lsl.l     #2,D1
000020E8  2980 1800 3992          move.l    D0,0(A4,D1.L)
000020EC  5282      3993          addq.l    #1,D2
000020EE  60DC      3994          bra       DACWave_4
                    3995   DACWave_6:
                    3996   ; }
                    3997   ; IIC_Init();
000020F0  4EB8 168A 3998          jsr       _IIC_Init
                    3999   ; checkTIP();
000020F4  4E92      4000          jsr       (A2)
                    4001   ; // START condition with slave address
                    4002   ; IIC_TXRX = ((PCF8591 << 1) & 0xFE); // Send EEPROM address with write bit
000020F6  13FC 0092 4003          move.b    #146,4227078
000020FA  0040 8006 
                    4004   ; IIC_CRSR = START | WRITE | IACK; // Start condition with write bit
000020FE  13FC 0091 4005          move.b    #145,4227080
00002102  0040 8008 
                    4006   ; checkTIP();
00002106  4E92      4007          jsr       (A2)
                    4008   ; checkAck();
00002108  4E93      4009          jsr       (A3)
                    4010   ; // DAC Control Byte: Send 01XX0XXX
                    4011   ; IIC_TXRX = 0x40; // Send EEPROM address with write bit
0000210A  13FC 0040 4012          move.b    #64,4227078
0000210E  0040 8006 
                    4013   ; IIC_CRSR = WRITE | IACK; // Start condition with write bit
00002112  13FC 0011 4014          move.b    #17,4227080
00002116  0040 8008 
                    4015   ; checkTIP();
0000211A  4E92      4016          jsr       (A2)
                    4017   ; checkAck();
0000211C  4E93      4018          jsr       (A3)
                    4019   ; // Go up and down from 0 to 255 to create effects
                    4020   ; while(1) {  // Loop continuously
                    4021   DACWave_7:
                    4022   ; for (i = 0; i < NUM_SAMPLES; i++) {
0000211E  4282      4023          clr.l     D2
                    4024   DACWave_10:
00002120  0C82 0000 4025          cmp.l     #512,D2
00002124  0200      
00002126  6C22      4026          bge.s     DACWave_12
                    4027   ; // Load the triangle wave sample into the I2C transmit register
                    4028   ; IIC_TXRX = triangle_table[i];
00002128  2002      4029          move.l    D2,D0
0000212A  E588      4030          lsl.l     #2,D0
0000212C  2034 0800 4031          move.l    0(A4,D0.L),D0
00002130  13C0 0040 4032          move.b    D0,4227078
00002134  8006      
                    4033   ; IIC_CRSR = WRITE | IACK;  // Initiate I2C write for the data byte
00002136  13FC 0011 4034          move.b    #17,4227080
0000213A  0040 8008 
                    4035   ; checkTIP();  // Wait until the transmission is complete
0000213E  4E92      4036          jsr       (A2)
                    4037   ; checkAck();  // Check for acknowledgment from the DAC
00002140  4E93      4038          jsr       (A3)
                    4039   ; Wait1ms();
00002142  4EB8 0B94 4040          jsr       _Wait1ms
00002146  5282      4041          addq.l    #1,D2
00002148  60D6      4042          bra       DACWave_10
                    4043   DACWave_12:
0000214A  60D2      4044          bra       DACWave_7
                    4045   ; }
                    4046   ; }
                    4047   ; }
                    4048   ; //////////////////////////////////////////////////////////////////////////////////////////////////
                    4049   ; // IMPORTANT
                    4050   ; // TG68 does not support the Native Trace mode of the original 68000 so tracing
                    4051   ; // has to be done with an interrupt (IRQ Level 6)
                    4052   ; //
                    4053   ; // To allow the 68000 to execute one more instruction after each pseudo trace (IRQ6)
                    4054   ; // the IRQ is removed in hardware once the TG68 reads the IRQ autovector (i.e. acknowledges the IRQ)
                    4055   ; //
                    4056   ; // on return from the IRQ service handler, the first access to the user memory program space
                    4057   ; // generates a fresh IRQ (in hardware) to generate a new trace, this allows the tg68 to
                    4058   ; // execute one more new instruction (without it the TG68 would trace on the same instruction
                    4059   ; // each time and not after the next one). It also means it doesn't simgle step outside the user
                    4060   ; // program area
                    4061   ; //
                    4062   ; // The bottom line is the Trace handler, which includes the Dump registers below
                    4063   ; // cannot access the user memory to display for example the Instruction Opcode or to disassemble etc
                    4064   ; // as this would lead to a new IRQ being reset and the TG68 would trace on same instruction
                    4065   ; // NOT SURE THIS IS TRUE NOW THAT TRACE HANDLER HAS BEEN MODIVIED TO NOT AUTOMATICALLY GENERATE A TRACE EXCEPTION
                    4066   ; // INSTEAD IT IS DONE IN THE 'N' COMMAND FOR NEXT
                    4067   ; /////////////////////////////////////////////////////////////////////////////////////////////////////
                    4068   ; void DumpRegisters()
                    4069   ; {
                    4070   _DumpRegisters:
0000214C  48E7 3F3C 4071          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
00002150  45F9 0000 4072          lea       _putch.L,A2
00002154  3D48      
00002156  47F9 0000 4073          lea       _printf.L,A3
0000215A  3C28      
0000215C  49F9 0B00 4074          lea       _SR.L,A4
00002160  012C      
00002162  4BF9 0B00 4075          lea       _WatchPointString.L,A5
00002166  01C2      
                    4076   ; short i, x, j, k ;
                    4077   ; unsigned char c, *BytePointer;
                    4078   ; // buld up strings for displaying watchpoints
                    4079   ; for(x = 0; x < (short)(8); x++)
00002168  4242      4080          clr.w     D2
                    4081   DumpRegisters_1:
0000216A  0C42 0008 4082          cmp.w     #8,D2
0000216E  6C00 01C6 4083          bge       DumpRegisters_3
                    4084   ; {
                    4085   ; if(WatchPointSetOrCleared[x] == 1)
00002172  48C2      4086          ext.l     D2
00002174  2002      4087          move.l    D2,D0
00002176  E588      4088          lsl.l     #2,D0
00002178  41F9 0B00 4089          lea       _WatchPointSetOrCleared.L,A0
0000217C  01A2      
0000217E  2030 0800 4090          move.l    0(A0,D0.L),D0
00002182  0C80 0000 4091          cmp.l     #1,D0
00002186  0001      
00002188  6600 0186 4092          bne       DumpRegisters_4
                    4093   ; {
                    4094   ; sprintf(WatchPointString[x], "$%08X  ", WatchPointAddress[x]) ;
0000218C  48C2      4095          ext.l     D2
0000218E  2202      4096          move.l    D2,D1
00002190  E589      4097          lsl.l     #2,D1
00002192  41F9 0B00 4098          lea       _WatchPointAddress.L,A0
00002196  0182      
00002198  2F30 1800 4099          move.l    0(A0,D1.L),-(A7)
0000219C  4879 0000 4100          pea       @m68kde~1_64.L
000021A0  5830      
000021A2  220D      4101          move.l    A5,D1
000021A4  48C2      4102          ext.l     D2
000021A6  2F00      4103          move.l    D0,-(A7)
000021A8  2002      4104          move.l    D2,D0
000021AA  C1FC 0064 4105          muls      #100,D0
000021AE  D280      4106          add.l     D0,D1
000021B0  201F      4107          move.l    (A7)+,D0
000021B2  2F01      4108          move.l    D1,-(A7)
000021B4  4EB9 0000 4109          jsr       _sprintf
000021B8  3DE0      
000021BA  DEFC 000C 4110          add.w     #12,A7
                    4111   ; BytePointer = (char *)(WatchPointAddress[x]) ;
000021BE  48C2      4112          ext.l     D2
000021C0  2002      4113          move.l    D2,D0
000021C2  E588      4114          lsl.l     #2,D0
000021C4  41F9 0B00 4115          lea       _WatchPointAddress.L,A0
000021C8  0182      
000021CA  2A30 0800 4116          move.l    0(A0,D0.L),D5
                    4117   ; for(j = 0; j < (short)(16); j+=2)
000021CE  4243      4118          clr.w     D3
                    4119   DumpRegisters_6:
000021D0  0C43 0010 4120          cmp.w     #16,D3
000021D4  6C00 0082 4121          bge       DumpRegisters_8
                    4122   ; {
                    4123   ; for(k = 0; k < (short)(2); k++)
000021D8  4246      4124          clr.w     D6
                    4125   DumpRegisters_9:
000021DA  0C46 0002 4126          cmp.w     #2,D6
000021DE  6C00 0052 4127          bge       DumpRegisters_11
                    4128   ; {
                    4129   ; sprintf(TempString, "%02X", BytePointer[j+k]) ;
000021E2  2045      4130          move.l    D5,A0
000021E4  48C3      4131          ext.l     D3
000021E6  2203      4132          move.l    D3,D1
000021E8  48C6      4133          ext.l     D6
000021EA  D286      4134          add.l     D6,D1
000021EC  1230 1800 4135          move.b    0(A0,D1.L),D1
000021F0  C2BC 0000 4136          and.l     #255,D1
000021F4  00FF      
000021F6  2F01      4137          move.l    D1,-(A7)
000021F8  4879 0000 4138          pea       @m68kde~1_8.L
000021FC  5140      
000021FE  4879 0B00 4139          pea       _TempString.L
00002202  04E2      
00002204  4EB9 0000 4140          jsr       _sprintf
00002208  3DE0      
0000220A  DEFC 000C 4141          add.w     #12,A7
                    4142   ; strcat(WatchPointString[x], TempString) ;
0000220E  4879 0B00 4143          pea       _TempString.L
00002212  04E2      
00002214  220D      4144          move.l    A5,D1
00002216  48C2      4145          ext.l     D2
00002218  2F00      4146          move.l    D0,-(A7)
0000221A  2002      4147          move.l    D2,D0
0000221C  C1FC 0064 4148          muls      #100,D0
00002220  D280      4149          add.l     D0,D1
00002222  201F      4150          move.l    (A7)+,D0
00002224  2F01      4151          move.l    D1,-(A7)
00002226  4EB9 0000 4152          jsr       _strcat
0000222A  3E2C      
0000222C  504F      4153          addq.w    #8,A7
0000222E  5246      4154          addq.w    #1,D6
00002230  60A8      4155          bra       DumpRegisters_9
                    4156   DumpRegisters_11:
                    4157   ; }
                    4158   ; strcat(WatchPointString[x]," ") ;
00002232  4879 0000 4159          pea       @m68kde~1_65.L
00002236  5838      
00002238  220D      4160          move.l    A5,D1
0000223A  48C2      4161          ext.l     D2
0000223C  2F00      4162          move.l    D0,-(A7)
0000223E  2002      4163          move.l    D2,D0
00002240  C1FC 0064 4164          muls      #100,D0
00002244  D280      4165          add.l     D0,D1
00002246  201F      4166          move.l    (A7)+,D0
00002248  2F01      4167          move.l    D1,-(A7)
0000224A  4EB9 0000 4168          jsr       _strcat
0000224E  3E2C      
00002250  504F      4169          addq.w    #8,A7
00002252  5443      4170          addq.w    #2,D3
00002254  6000 FF7A 4171          bra       DumpRegisters_6
                    4172   DumpRegisters_8:
                    4173   ; }
                    4174   ; strcat(WatchPointString[x], "  ") ;
00002258  4879 0000 4175          pea       @m68kde~1_9.L
0000225C  5146      
0000225E  220D      4176          move.l    A5,D1
00002260  48C2      4177          ext.l     D2
00002262  2F00      4178          move.l    D0,-(A7)
00002264  2002      4179          move.l    D2,D0
00002266  C1FC 0064 4180          muls      #100,D0
0000226A  D280      4181          add.l     D0,D1
0000226C  201F      4182          move.l    (A7)+,D0
0000226E  2F01      4183          move.l    D1,-(A7)
00002270  4EB9 0000 4184          jsr       _strcat
00002274  3E2C      
00002276  504F      4185          addq.w    #8,A7
                    4186   ; BytePointer = (char *)(WatchPointAddress[x]) ;
00002278  48C2      4187          ext.l     D2
0000227A  2002      4188          move.l    D2,D0
0000227C  E588      4189          lsl.l     #2,D0
0000227E  41F9 0B00 4190          lea       _WatchPointAddress.L,A0
00002282  0182      
00002284  2A30 0800 4191          move.l    0(A0,D0.L),D5
                    4192   ; for(j = 0; j < (short)(16); j++)
00002288  4243      4193          clr.w     D3
                    4194   DumpRegisters_12:
0000228A  0C43 0010 4195          cmp.w     #16,D3
0000228E  6C00 007E 4196          bge       DumpRegisters_14
                    4197   ; {
                    4198   ; c = ((char)(BytePointer[j]) & 0x7f) ;
00002292  2045      4199          move.l    D5,A0
00002294  48C3      4200          ext.l     D3
00002296  1030 3800 4201          move.b    0(A0,D3.L),D0
0000229A  C03C 007F 4202          and.b     #127,D0
0000229E  1E00      4203          move.b    D0,D7
                    4204   ; if((c > (char)(0x7f)) || (c < (char)(' ')))
000022A0  0C07 007F 4205          cmp.b     #127,D7
000022A4  6206      4206          bhi.s     DumpRegisters_17
000022A6  0C07 0020 4207          cmp.b     #32,D7
000022AA  6416      4208          bhs.s     DumpRegisters_15
                    4209   DumpRegisters_17:
                    4210   ; sprintf(TempString, ".") ;
000022AC  4879 0000 4211          pea       @m68kde~1_66.L
000022B0  583A      
000022B2  4879 0B00 4212          pea       _TempString.L
000022B6  04E2      
000022B8  4EB9 0000 4213          jsr       _sprintf
000022BC  3DE0      
000022BE  504F      4214          addq.w    #8,A7
000022C0  6026      4215          bra.s     DumpRegisters_16
                    4216   DumpRegisters_15:
                    4217   ; else
                    4218   ; sprintf(TempString, "%c", BytePointer[j]) ;
000022C2  2045      4219          move.l    D5,A0
000022C4  48C3      4220          ext.l     D3
000022C6  1230 3800 4221          move.b    0(A0,D3.L),D1
000022CA  C2BC 0000 4222          and.l     #255,D1
000022CE  00FF      
000022D0  2F01      4223          move.l    D1,-(A7)
000022D2  4879 0000 4224          pea       @m68kde~1_67.L
000022D6  583C      
000022D8  4879 0B00 4225          pea       _TempString.L
000022DC  04E2      
000022DE  4EB9 0000 4226          jsr       _sprintf
000022E2  3DE0      
000022E4  DEFC 000C 4227          add.w     #12,A7
                    4228   DumpRegisters_16:
                    4229   ; strcat(WatchPointString[x], TempString) ;
000022E8  4879 0B00 4230          pea       _TempString.L
000022EC  04E2      
000022EE  220D      4231          move.l    A5,D1
000022F0  48C2      4232          ext.l     D2
000022F2  2F00      4233          move.l    D0,-(A7)
000022F4  2002      4234          move.l    D2,D0
000022F6  C1FC 0064 4235          muls      #100,D0
000022FA  D280      4236          add.l     D0,D1
000022FC  201F      4237          move.l    (A7)+,D0
000022FE  2F01      4238          move.l    D1,-(A7)
00002300  4EB9 0000 4239          jsr       _strcat
00002304  3E2C      
00002306  504F      4240          addq.w    #8,A7
00002308  5243      4241          addq.w    #1,D3
0000230A  6000 FF7E 4242          bra       DumpRegisters_12
                    4243   DumpRegisters_14:
0000230E  6020      4244          bra.s     DumpRegisters_5
                    4245   DumpRegisters_4:
                    4246   ; }
                    4247   ; }
                    4248   ; else
                    4249   ; strcpy(WatchPointString[x], "") ;
00002310  4879 0000 4250          pea       @m68kde~1_68.L
00002314  5840      
00002316  220D      4251          move.l    A5,D1
00002318  48C2      4252          ext.l     D2
0000231A  2F00      4253          move.l    D0,-(A7)
0000231C  2002      4254          move.l    D2,D0
0000231E  C1FC 0064 4255          muls      #100,D0
00002322  D280      4256          add.l     D0,D1
00002324  201F      4257          move.l    (A7)+,D0
00002326  2F01      4258          move.l    D1,-(A7)
00002328  4EB9 0000 4259          jsr       _strcpy
0000232C  3C5A      
0000232E  504F      4260          addq.w    #8,A7
                    4261   DumpRegisters_5:
00002330  5242      4262          addq.w    #1,D2
00002332  6000 FE36 4263          bra       DumpRegisters_1
                    4264   DumpRegisters_3:
                    4265   ; }
                    4266   ; printf("\r\n\r\n D0 = $%08X  A0 = $%08X",d0,a0) ;
00002336  2F39 0B00 4267          move.l    _a0.L,-(A7)
0000233A  0104      
0000233C  2F39 0B00 4268          move.l    _d0.L,-(A7)
00002340  00E4      
00002342  4879 0000 4269          pea       @m68kde~1_69.L
00002346  5842      
00002348  4E93      4270          jsr       (A3)
0000234A  DEFC 000C 4271          add.w     #12,A7
                    4272   ; printf("\r\n D1 = $%08X  A1 = $%08X",d1,a1) ;
0000234E  2F39 0B00 4273          move.l    _a1.L,-(A7)
00002352  0108      
00002354  2F39 0B00 4274          move.l    _d1.L,-(A7)
00002358  00E8      
0000235A  4879 0000 4275          pea       @m68kde~1_70.L
0000235E  585E      
00002360  4E93      4276          jsr       (A3)
00002362  DEFC 000C 4277          add.w     #12,A7
                    4278   ; printf("\r\n D2 = $%08X  A2 = $%08X",d2,a2) ;
00002366  2F39 0B00 4279          move.l    _a2.L,-(A7)
0000236A  010C      
0000236C  2F39 0B00 4280          move.l    _d2.L,-(A7)
00002370  00EC      
00002372  4879 0000 4281          pea       @m68kde~1_71.L
00002376  5878      
00002378  4E93      4282          jsr       (A3)
0000237A  DEFC 000C 4283          add.w     #12,A7
                    4284   ; printf("\r\n D3 = $%08X  A3 = $%08X",d3,a3) ;
0000237E  2F39 0B00 4285          move.l    _a3.L,-(A7)
00002382  0110      
00002384  2F39 0B00 4286          move.l    _d3.L,-(A7)
00002388  00F0      
0000238A  4879 0000 4287          pea       @m68kde~1_72.L
0000238E  5892      
00002390  4E93      4288          jsr       (A3)
00002392  DEFC 000C 4289          add.w     #12,A7
                    4290   ; printf("\r\n D4 = $%08X  A4 = $%08X",d4,a4) ;
00002396  2F39 0B00 4291          move.l    _a4.L,-(A7)
0000239A  0114      
0000239C  2F39 0B00 4292          move.l    _d4.L,-(A7)
000023A0  00F4      
000023A2  4879 0000 4293          pea       @m68kde~1_73.L
000023A6  58AC      
000023A8  4E93      4294          jsr       (A3)
000023AA  DEFC 000C 4295          add.w     #12,A7
                    4296   ; printf("\r\n D5 = $%08X  A5 = $%08X",d5,a5) ;
000023AE  2F39 0B00 4297          move.l    _a5.L,-(A7)
000023B2  0118      
000023B4  2F39 0B00 4298          move.l    _d5.L,-(A7)
000023B8  00F8      
000023BA  4879 0000 4299          pea       @m68kde~1_74.L
000023BE  58C6      
000023C0  4E93      4300          jsr       (A3)
000023C2  DEFC 000C 4301          add.w     #12,A7
                    4302   ; printf("\r\n D6 = $%08X  A6 = $%08X",d6,a6) ;
000023C6  2F39 0B00 4303          move.l    _a6.L,-(A7)
000023CA  011C      
000023CC  2F39 0B00 4304          move.l    _d6.L,-(A7)
000023D0  00FC      
000023D2  4879 0000 4305          pea       @m68kde~1_75.L
000023D6  58E0      
000023D8  4E93      4306          jsr       (A3)
000023DA  DEFC 000C 4307          add.w     #12,A7
                    4308   ; printf("\r\n D7 = $%08X  A7 = $%08X",d7,((SR & (unsigned short int)(0x2000)) == ((unsigned short int)(0x2000))) ? SSP : USP) ;
000023DE  3214      4309          move.w    (A4),D1
000023E0  C27C 2000 4310          and.w     #8192,D1
000023E4  0C41 2000 4311          cmp.w     #8192,D1
000023E8  6608      4312          bne.s     DumpRegisters_18
000023EA  2239 0B00 4313          move.l    _SSP.L,D1
000023EE  0124      
000023F0  6006      4314          bra.s     DumpRegisters_19
                    4315   DumpRegisters_18:
000023F2  2239 0B00 4316          move.l    _USP.L,D1
000023F6  0128      
                    4317   DumpRegisters_19:
000023F8  2F01      4318          move.l    D1,-(A7)
000023FA  2F39 0B00 4319          move.l    _d7.L,-(A7)
000023FE  0100      
00002400  4879 0000 4320          pea       @m68kde~1_76.L
00002404  58FA      
00002406  4E93      4321          jsr       (A3)
00002408  DEFC 000C 4322          add.w     #12,A7
                    4323   ; printf("\r\n\r\nUSP = $%08X  (A7) User SP", USP ) ;
0000240C  2F39 0B00 4324          move.l    _USP.L,-(A7)
00002410  0128      
00002412  4879 0000 4325          pea       @m68kde~1_77.L
00002416  5914      
00002418  4E93      4326          jsr       (A3)
0000241A  504F      4327          addq.w    #8,A7
                    4328   ; printf("\r\nSSP = $%08X  (A7) Supervisor SP", SSP) ;
0000241C  2F39 0B00 4329          move.l    _SSP.L,-(A7)
00002420  0124      
00002422  4879 0000 4330          pea       @m68kde~1_78.L
00002426  5932      
00002428  4E93      4331          jsr       (A3)
0000242A  504F      4332          addq.w    #8,A7
                    4333   ; printf("\r\n SR = $%04X   ",SR) ;
0000242C  3214      4334          move.w    (A4),D1
0000242E  C2BC 0000 4335          and.l     #65535,D1
00002432  FFFF      
00002434  2F01      4336          move.l    D1,-(A7)
00002436  4879 0000 4337          pea       @m68kde~1_79.L
0000243A  5954      
0000243C  4E93      4338          jsr       (A3)
0000243E  504F      4339          addq.w    #8,A7
                    4340   ; // display the status word in characters etc.
                    4341   ; printf("   [") ;
00002440  4879 0000 4342          pea       @m68kde~1_80.L
00002444  5966      
00002446  4E93      4343          jsr       (A3)
00002448  584F      4344          addq.w    #4,A7
                    4345   ; if((SR & (unsigned short int)(0x8000)) == (unsigned short int)(0x8000)) putchar('T') ; else putchar('-') ;      // Trace bit(bit 15)
0000244A  3014      4346          move.w    (A4),D0
0000244C  C07C 8000 4347          and.w     #32768,D0
00002450  0C40 8000 4348          cmp.w     #32768,D0
00002454  660A      4349          bne.s     DumpRegisters_20
00002456  4878 0054 4350          pea       84
0000245A  4E92      4351          jsr       (A2)
0000245C  584F      4352          addq.w    #4,A7
0000245E  6008      4353          bra.s     DumpRegisters_21
                    4354   DumpRegisters_20:
00002460  4878 002D 4355          pea       45
00002464  4E92      4356          jsr       (A2)
00002466  584F      4357          addq.w    #4,A7
                    4358   DumpRegisters_21:
                    4359   ; if((SR & (unsigned short int)(0x2000)) == (unsigned short int)(0x2000)) putchar('S') ; else putchar('U') ;      // supervisor bit  (bit 13)
00002468  3014      4360          move.w    (A4),D0
0000246A  C07C 2000 4361          and.w     #8192,D0
0000246E  0C40 2000 4362          cmp.w     #8192,D0
00002472  660A      4363          bne.s     DumpRegisters_22
00002474  4878 0053 4364          pea       83
00002478  4E92      4365          jsr       (A2)
0000247A  584F      4366          addq.w    #4,A7
0000247C  6008      4367          bra.s     DumpRegisters_23
                    4368   DumpRegisters_22:
0000247E  4878 0055 4369          pea       85
00002482  4E92      4370          jsr       (A2)
00002484  584F      4371          addq.w    #4,A7
                    4372   DumpRegisters_23:
                    4373   ; if((SR & (unsigned short int)(0x0400)) == (unsigned short int)(0x0400)) putchar('1') ; else putchar('0') ;      // IRQ2 Bit (bit 10)
00002486  3014      4374          move.w    (A4),D0
00002488  C07C 0400 4375          and.w     #1024,D0
0000248C  0C40 0400 4376          cmp.w     #1024,D0
00002490  660A      4377          bne.s     DumpRegisters_24
00002492  4878 0031 4378          pea       49
00002496  4E92      4379          jsr       (A2)
00002498  584F      4380          addq.w    #4,A7
0000249A  6008      4381          bra.s     DumpRegisters_25
                    4382   DumpRegisters_24:
0000249C  4878 0030 4383          pea       48
000024A0  4E92      4384          jsr       (A2)
000024A2  584F      4385          addq.w    #4,A7
                    4386   DumpRegisters_25:
                    4387   ; if((SR & (unsigned short int)(0x0200)) == (unsigned short int)(0x0200)) putchar('1') ; else putchar('0') ;      // IRQ1 Bit (bit 9)
000024A4  3014      4388          move.w    (A4),D0
000024A6  C07C 0200 4389          and.w     #512,D0
000024AA  0C40 0200 4390          cmp.w     #512,D0
000024AE  660A      4391          bne.s     DumpRegisters_26
000024B0  4878 0031 4392          pea       49
000024B4  4E92      4393          jsr       (A2)
000024B6  584F      4394          addq.w    #4,A7
000024B8  6008      4395          bra.s     DumpRegisters_27
                    4396   DumpRegisters_26:
000024BA  4878 0030 4397          pea       48
000024BE  4E92      4398          jsr       (A2)
000024C0  584F      4399          addq.w    #4,A7
                    4400   DumpRegisters_27:
                    4401   ; if((SR & (unsigned short int)(0x0100)) == (unsigned short int)(0x0100)) putchar('1') ; else putchar('0') ;      // IRQ0 Bit (bit 8)
000024C2  3014      4402          move.w    (A4),D0
000024C4  C07C 0100 4403          and.w     #256,D0
000024C8  0C40 0100 4404          cmp.w     #256,D0
000024CC  660A      4405          bne.s     DumpRegisters_28
000024CE  4878 0031 4406          pea       49
000024D2  4E92      4407          jsr       (A2)
000024D4  584F      4408          addq.w    #4,A7
000024D6  6008      4409          bra.s     DumpRegisters_29
                    4410   DumpRegisters_28:
000024D8  4878 0030 4411          pea       48
000024DC  4E92      4412          jsr       (A2)
000024DE  584F      4413          addq.w    #4,A7
                    4414   DumpRegisters_29:
                    4415   ; if((SR & (unsigned short int)(0x0010)) == (unsigned short int)(0x0010)) putchar('X') ; else putchar('-') ;      // X Bit (bit 4)
000024E0  3014      4416          move.w    (A4),D0
000024E2  C07C 0010 4417          and.w     #16,D0
000024E6  0C40 0010 4418          cmp.w     #16,D0
000024EA  660A      4419          bne.s     DumpRegisters_30
000024EC  4878 0058 4420          pea       88
000024F0  4E92      4421          jsr       (A2)
000024F2  584F      4422          addq.w    #4,A7
000024F4  6008      4423          bra.s     DumpRegisters_31
                    4424   DumpRegisters_30:
000024F6  4878 002D 4425          pea       45
000024FA  4E92      4426          jsr       (A2)
000024FC  584F      4427          addq.w    #4,A7
                    4428   DumpRegisters_31:
                    4429   ; if((SR & (unsigned short int)(0x0008)) == (unsigned short int)(0x0008)) putchar('N') ; else putchar('-') ;      // N Bit (bit 3)
000024FE  3014      4430          move.w    (A4),D0
00002500  C07C 0008 4431          and.w     #8,D0
00002504  0C40 0008 4432          cmp.w     #8,D0
00002508  660A      4433          bne.s     DumpRegisters_32
0000250A  4878 004E 4434          pea       78
0000250E  4E92      4435          jsr       (A2)
00002510  584F      4436          addq.w    #4,A7
00002512  6008      4437          bra.s     DumpRegisters_33
                    4438   DumpRegisters_32:
00002514  4878 002D 4439          pea       45
00002518  4E92      4440          jsr       (A2)
0000251A  584F      4441          addq.w    #4,A7
                    4442   DumpRegisters_33:
                    4443   ; if((SR & (unsigned short int)(0x0004)) == (unsigned short int)(0x0004)) putchar('Z') ; else putchar('-') ;      // Z Bit (bit 2)
0000251C  3014      4444          move.w    (A4),D0
0000251E  C07C 0004 4445          and.w     #4,D0
00002522  0C40 0004 4446          cmp.w     #4,D0
00002526  660A      4447          bne.s     DumpRegisters_34
00002528  4878 005A 4448          pea       90
0000252C  4E92      4449          jsr       (A2)
0000252E  584F      4450          addq.w    #4,A7
00002530  6008      4451          bra.s     DumpRegisters_35
                    4452   DumpRegisters_34:
00002532  4878 002D 4453          pea       45
00002536  4E92      4454          jsr       (A2)
00002538  584F      4455          addq.w    #4,A7
                    4456   DumpRegisters_35:
                    4457   ; if((SR & (unsigned short int)(0x0002)) == (unsigned short int)(0x0002)) putchar('V') ; else putchar('-') ;      // V Bit (bit 1)
0000253A  3014      4458          move.w    (A4),D0
0000253C  C07C 0002 4459          and.w     #2,D0
00002540  0C40 0002 4460          cmp.w     #2,D0
00002544  660A      4461          bne.s     DumpRegisters_36
00002546  4878 0056 4462          pea       86
0000254A  4E92      4463          jsr       (A2)
0000254C  584F      4464          addq.w    #4,A7
0000254E  6008      4465          bra.s     DumpRegisters_37
                    4466   DumpRegisters_36:
00002550  4878 002D 4467          pea       45
00002554  4E92      4468          jsr       (A2)
00002556  584F      4469          addq.w    #4,A7
                    4470   DumpRegisters_37:
                    4471   ; if((SR & (unsigned short int)(0x0001)) == (unsigned short int)(0x0001)) putchar('C') ; else putchar('-') ;      // C Bit (bit 0)
00002558  3014      4472          move.w    (A4),D0
0000255A  C07C 0001 4473          and.w     #1,D0
0000255E  0C40 0001 4474          cmp.w     #1,D0
00002562  660A      4475          bne.s     DumpRegisters_38
00002564  4878 0043 4476          pea       67
00002568  4E92      4477          jsr       (A2)
0000256A  584F      4478          addq.w    #4,A7
0000256C  6008      4479          bra.s     DumpRegisters_39
                    4480   DumpRegisters_38:
0000256E  4878 002D 4481          pea       45
00002572  4E92      4482          jsr       (A2)
00002574  584F      4483          addq.w    #4,A7
                    4484   DumpRegisters_39:
                    4485   ; putchar(']') ;
00002576  4878 005D 4486          pea       93
0000257A  4E92      4487          jsr       (A2)
0000257C  584F      4488          addq.w    #4,A7
                    4489   ; printf("\r\n PC = $%08X  ", PC) ;
0000257E  2F39 0B00 4490          move.l    _PC.L,-(A7)
00002582  0120      
00002584  4879 0000 4491          pea       @m68kde~1_81.L
00002588  596C      
0000258A  4E93      4492          jsr       (A3)
0000258C  504F      4493          addq.w    #8,A7
                    4494   ; if(*(unsigned short int *)(PC) == 0x4e4e)
0000258E  2039 0B00 4495          move.l    _PC.L,D0
00002592  0120      
00002594  2040      4496          move.l    D0,A0
00002596  3010      4497          move.w    (A0),D0
00002598  0C40 4E4E 4498          cmp.w     #20046,D0
0000259C  660A      4499          bne.s     DumpRegisters_40
                    4500   ; printf("[@ BREAKPOINT]") ;
0000259E  4879 0000 4501          pea       @m68kde~1_82.L
000025A2  597C      
000025A4  4E93      4502          jsr       (A3)
000025A6  584F      4503          addq.w    #4,A7
                    4504   DumpRegisters_40:
                    4505   ; printf("\r\n") ;
000025A8  4879 0000 4506          pea       @m68kde~1_1.L
000025AC  50C8      
000025AE  4E93      4507          jsr       (A3)
000025B0  584F      4508          addq.w    #4,A7
                    4509   ; for(i=0; i < 8; i++)    {
000025B2  4244      4510          clr.w     D4
                    4511   DumpRegisters_42:
000025B4  0C44 0008 4512          cmp.w     #8,D4
000025B8  6C00 0040 4513          bge       DumpRegisters_44
                    4514   ; if(WatchPointSetOrCleared[i] == 1)
000025BC  48C4      4515          ext.l     D4
000025BE  2004      4516          move.l    D4,D0
000025C0  E588      4517          lsl.l     #2,D0
000025C2  41F9 0B00 4518          lea       _WatchPointSetOrCleared.L,A0
000025C6  01A2      
000025C8  2030 0800 4519          move.l    0(A0,D0.L),D0
000025CC  0C80 0000 4520          cmp.l     #1,D0
000025D0  0001      
000025D2  6622      4521          bne.s     DumpRegisters_45
                    4522   ; printf("\r\nWP%d = %s", i, WatchPointString[i]) ;
000025D4  220D      4523          move.l    A5,D1
000025D6  48C4      4524          ext.l     D4
000025D8  2F00      4525          move.l    D0,-(A7)
000025DA  2004      4526          move.l    D4,D0
000025DC  C1FC 0064 4527          muls      #100,D0
000025E0  D280      4528          add.l     D0,D1
000025E2  201F      4529          move.l    (A7)+,D0
000025E4  2F01      4530          move.l    D1,-(A7)
000025E6  48C4      4531          ext.l     D4
000025E8  2F04      4532          move.l    D4,-(A7)
000025EA  4879 0000 4533          pea       @m68kde~1_83.L
000025EE  598C      
000025F0  4E93      4534          jsr       (A3)
000025F2  DEFC 000C 4535          add.w     #12,A7
                    4536   DumpRegisters_45:
000025F6  5244      4537          addq.w    #1,D4
000025F8  60BA      4538          bra       DumpRegisters_42
                    4539   DumpRegisters_44:
000025FA  4CDF 3CFC 4540          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
000025FE  4E75      4541          rts
                    4542   ; }
                    4543   ; }
                    4544   ; // Trace Exception Handler
                    4545   ; void DumpRegistersandPause(void)
                    4546   ; {
                    4547   _DumpRegistersandPause:
00002600  2F0A      4548          move.l    A2,-(A7)
00002602  45F9 0000 4549          lea       _printf.L,A2
00002606  3C28      
                    4550   ; printf("\r\n\r\n\r\n\r\n\r\n\r\nSingle Step  :[ON]") ;
00002608  4879 0000 4551          pea       @m68kde~1_84.L
0000260C  5998      
0000260E  4E92      4552          jsr       (A2)
00002610  584F      4553          addq.w    #4,A7
                    4554   ; printf("\r\nBreak Points :[Disabled]") ;
00002612  4879 0000 4555          pea       @m68kde~1_85.L
00002616  59B8      
00002618  4E92      4556          jsr       (A2)
0000261A  584F      4557          addq.w    #4,A7
                    4558   ; DumpRegisters() ;
0000261C  4EB8 214C 4559          jsr       _DumpRegisters
                    4560   ; printf("\r\nPress <SPACE> to Execute Next Instruction");
00002620  4879 0000 4561          pea       @m68kde~1_86.L
00002624  59D4      
00002626  4E92      4562          jsr       (A2)
00002628  584F      4563          addq.w    #4,A7
                    4564   ; printf("\r\nPress <ESC> to Resume Program") ;
0000262A  4879 0000 4565          pea       @m68kde~1_87.L
0000262E  5A00      
00002630  4E92      4566          jsr       (A2)
00002632  584F      4567          addq.w    #4,A7
                    4568   ; menu() ;
00002634  4EB9 0000 4569          jsr       _menu
00002638  31E4      
0000263A  245F      4570          move.l    (A7)+,A2
0000263C  4E75      4571          rts
                    4572   ; }
                    4573   ; void ChangeRegisters(void)
                    4574   ; {
                    4575   _ChangeRegisters:
0000263E  4E56 FFFC 4576          link      A6,#-4
00002642  48E7 303C 4577          movem.l   D2/D3/A2/A3/A4/A5,-(A7)
00002646  45F9 0000 4578          lea       _printf.L,A2
0000264A  3C28      
0000264C  47EE FFFC 4579          lea       -4(A6),A3
00002650  49F8 0F06 4580          lea       _Get8HexDigits.L,A4
00002654  4BF8 0DCA 4581          lea       __getch.L,A5
                    4582   ; // get register name d0-d7, a0-a7, up, sp, sr, pc
                    4583   ; int reg_val ;
                    4584   ; char c, reg[3] ;
                    4585   ; reg[0] = tolower(_getch()) ;
00002658  2F00      4586          move.l    D0,-(A7)
0000265A  4E95      4587          jsr       (A5)
0000265C  2200      4588          move.l    D0,D1
0000265E  201F      4589          move.l    (A7)+,D0
00002660  2F01      4590          move.l    D1,-(A7)
00002662  4EB9 0000 4591          jsr       _tolower
00002666  3DB4      
00002668  584F      4592          addq.w    #4,A7
0000266A  1680      4593          move.b    D0,(A3)
                    4594   ; reg[1] = c = tolower(_getch()) ;
0000266C  2F00      4595          move.l    D0,-(A7)
0000266E  4E95      4596          jsr       (A5)
00002670  2200      4597          move.l    D0,D1
00002672  201F      4598          move.l    (A7)+,D0
00002674  2F01      4599          move.l    D1,-(A7)
00002676  4EB9 0000 4600          jsr       _tolower
0000267A  3DB4      
0000267C  584F      4601          addq.w    #4,A7
0000267E  1400      4602          move.b    D0,D2
00002680  1740 0001 4603          move.b    D0,1(A3)
                    4604   ; if(reg[0] == (char)('d'))  {    // change data register
00002684  1013      4605          move.b    (A3),D0
00002686  0C00 0064 4606          cmp.b     #100,D0
0000268A  6600 00AE 4607          bne       ChangeRegisters_1
                    4608   ; if((reg[1] > (char)('7')) || (reg[1] < (char)('0'))) {
0000268E  102B 0001 4609          move.b    1(A3),D0
00002692  0C00 0037 4610          cmp.b     #55,D0
00002696  6E0A      4611          bgt.s     ChangeRegisters_5
00002698  102B 0001 4612          move.b    1(A3),D0
0000269C  0C00 0030 4613          cmp.b     #48,D0
000026A0  6C0E      4614          bge.s     ChangeRegisters_3
                    4615   ChangeRegisters_5:
                    4616   ; printf("\r\nIllegal Data Register : Use D0-D7.....\r\n") ;
000026A2  4879 0000 4617          pea       @m68kde~1_88.L
000026A6  5A20      
000026A8  4E92      4618          jsr       (A2)
000026AA  584F      4619          addq.w    #4,A7
                    4620   ; return ;
000026AC  6000 0244 4621          bra       ChangeRegisters_6
                    4622   ChangeRegisters_3:
                    4623   ; }
                    4624   ; else {
                    4625   ; printf("\r\nD%c = ", c) ;
000026B0  4882      4626          ext.w     D2
000026B2  48C2      4627          ext.l     D2
000026B4  2F02      4628          move.l    D2,-(A7)
000026B6  4879 0000 4629          pea       @m68kde~1_89.L
000026BA  5A4C      
000026BC  4E92      4630          jsr       (A2)
000026BE  504F      4631          addq.w    #8,A7
                    4632   ; reg_val = Get8HexDigits(0) ;    // read 32 bit value from user keyboard
000026C0  42A7      4633          clr.l     -(A7)
000026C2  4E94      4634          jsr       (A4)
000026C4  584F      4635          addq.w    #4,A7
000026C6  2600      4636          move.l    D0,D3
                    4637   ; }
                    4638   ; // bit cludgy but d0-d7 not stored as an array for good reason
                    4639   ; if(c == (char)('0'))
000026C8  0C02 0030 4640          cmp.b     #48,D2
000026CC  660A      4641          bne.s     ChangeRegisters_7
                    4642   ; d0 = reg_val ;
000026CE  23C3 0B00 4643          move.l    D3,_d0.L
000026D2  00E4      
000026D4  6000 0060 4644          bra       ChangeRegisters_20
                    4645   ChangeRegisters_7:
                    4646   ; else if(c == (char)('1'))
000026D8  0C02 0031 4647          cmp.b     #49,D2
000026DC  660A      4648          bne.s     ChangeRegisters_9
                    4649   ; d1 = reg_val ;
000026DE  23C3 0B00 4650          move.l    D3,_d1.L
000026E2  00E8      
000026E4  6000 0050 4651          bra       ChangeRegisters_20
                    4652   ChangeRegisters_9:
                    4653   ; else if(c == (char)('2'))
000026E8  0C02 0032 4654          cmp.b     #50,D2
000026EC  660A      4655          bne.s     ChangeRegisters_11
                    4656   ; d2 = reg_val ;
000026EE  23C3 0B00 4657          move.l    D3,_d2.L
000026F2  00EC      
000026F4  6000 0040 4658          bra       ChangeRegisters_20
                    4659   ChangeRegisters_11:
                    4660   ; else if(c == (char)('3'))
000026F8  0C02 0033 4661          cmp.b     #51,D2
000026FC  6608      4662          bne.s     ChangeRegisters_13
                    4663   ; d3 = reg_val ;
000026FE  23C3 0B00 4664          move.l    D3,_d3.L
00002702  00F0      
00002704  6030      4665          bra.s     ChangeRegisters_20
                    4666   ChangeRegisters_13:
                    4667   ; else if(c == (char)('4'))
00002706  0C02 0034 4668          cmp.b     #52,D2
0000270A  6608      4669          bne.s     ChangeRegisters_15
                    4670   ; d4 = reg_val ;
0000270C  23C3 0B00 4671          move.l    D3,_d4.L
00002710  00F4      
00002712  6022      4672          bra.s     ChangeRegisters_20
                    4673   ChangeRegisters_15:
                    4674   ; else if(c == (char)('5'))
00002714  0C02 0035 4675          cmp.b     #53,D2
00002718  6608      4676          bne.s     ChangeRegisters_17
                    4677   ; d5 = reg_val ;
0000271A  23C3 0B00 4678          move.l    D3,_d5.L
0000271E  00F8      
00002720  6014      4679          bra.s     ChangeRegisters_20
                    4680   ChangeRegisters_17:
                    4681   ; else if(c == (char)('6'))
00002722  0C02 0036 4682          cmp.b     #54,D2
00002726  6608      4683          bne.s     ChangeRegisters_19
                    4684   ; d6 = reg_val ;
00002728  23C3 0B00 4685          move.l    D3,_d6.L
0000272C  00FC      
0000272E  6006      4686          bra.s     ChangeRegisters_20
                    4687   ChangeRegisters_19:
                    4688   ; else
                    4689   ; d7 = reg_val ;
00002730  23C3 0B00 4690          move.l    D3,_d7.L
00002734  0100      
                    4691   ChangeRegisters_20:
00002736  6000 01B6 4692          bra       ChangeRegisters_51
                    4693   ChangeRegisters_1:
                    4694   ; }
                    4695   ; else if(reg[0] == (char)('a'))  {    // change address register, a7 is the user stack pointer, sp is the system stack pointer
0000273A  1013      4696          move.b    (A3),D0
0000273C  0C00 0061 4697          cmp.b     #97,D0
00002740  6600 00A6 4698          bne       ChangeRegisters_21
                    4699   ; if((c > (char)('7')) || (c < (char)('0'))) {
00002744  0C02 0037 4700          cmp.b     #55,D2
00002748  6E06      4701          bgt.s     ChangeRegisters_25
0000274A  0C02 0030 4702          cmp.b     #48,D2
0000274E  6C0E      4703          bge.s     ChangeRegisters_23
                    4704   ChangeRegisters_25:
                    4705   ; printf("\r\nIllegal Address Register : Use A0-A7.....\r\n") ;
00002750  4879 0000 4706          pea       @m68kde~1_90.L
00002754  5A56      
00002756  4E92      4707          jsr       (A2)
00002758  584F      4708          addq.w    #4,A7
                    4709   ; return ;
0000275A  6000 0196 4710          bra       ChangeRegisters_6
                    4711   ChangeRegisters_23:
                    4712   ; }
                    4713   ; else {
                    4714   ; printf("\r\nA%c = ", c) ;
0000275E  4882      4715          ext.w     D2
00002760  48C2      4716          ext.l     D2
00002762  2F02      4717          move.l    D2,-(A7)
00002764  4879 0000 4718          pea       @m68kde~1_91.L
00002768  5A84      
0000276A  4E92      4719          jsr       (A2)
0000276C  504F      4720          addq.w    #8,A7
                    4721   ; reg_val = Get8HexDigits(0) ;    // read 32 bit value from user keyboard
0000276E  42A7      4722          clr.l     -(A7)
00002770  4E94      4723          jsr       (A4)
00002772  584F      4724          addq.w    #4,A7
00002774  2600      4725          move.l    D0,D3
                    4726   ; }
                    4727   ; // bit cludgy but a0-a7 not stored as an array for good reason
                    4728   ; if(c == (char)('0'))
00002776  0C02 0030 4729          cmp.b     #48,D2
0000277A  660A      4730          bne.s     ChangeRegisters_26
                    4731   ; a0 = reg_val ;
0000277C  23C3 0B00 4732          move.l    D3,_a0.L
00002780  0104      
00002782  6000 0060 4733          bra       ChangeRegisters_39
                    4734   ChangeRegisters_26:
                    4735   ; else if(c == (char)('1'))
00002786  0C02 0031 4736          cmp.b     #49,D2
0000278A  660A      4737          bne.s     ChangeRegisters_28
                    4738   ; a1 = reg_val ;
0000278C  23C3 0B00 4739          move.l    D3,_a1.L
00002790  0108      
00002792  6000 0050 4740          bra       ChangeRegisters_39
                    4741   ChangeRegisters_28:
                    4742   ; else if(c == (char)('2'))
00002796  0C02 0032 4743          cmp.b     #50,D2
0000279A  660A      4744          bne.s     ChangeRegisters_30
                    4745   ; a2 = reg_val ;
0000279C  23C3 0B00 4746          move.l    D3,_a2.L
000027A0  010C      
000027A2  6000 0040 4747          bra       ChangeRegisters_39
                    4748   ChangeRegisters_30:
                    4749   ; else if(c == (char)('3'))
000027A6  0C02 0033 4750          cmp.b     #51,D2
000027AA  6608      4751          bne.s     ChangeRegisters_32
                    4752   ; a3 = reg_val ;
000027AC  23C3 0B00 4753          move.l    D3,_a3.L
000027B0  0110      
000027B2  6030      4754          bra.s     ChangeRegisters_39
                    4755   ChangeRegisters_32:
                    4756   ; else if(c == (char)('4'))
000027B4  0C02 0034 4757          cmp.b     #52,D2
000027B8  6608      4758          bne.s     ChangeRegisters_34
                    4759   ; a4 = reg_val ;
000027BA  23C3 0B00 4760          move.l    D3,_a4.L
000027BE  0114      
000027C0  6022      4761          bra.s     ChangeRegisters_39
                    4762   ChangeRegisters_34:
                    4763   ; else if(c == (char)('5'))
000027C2  0C02 0035 4764          cmp.b     #53,D2
000027C6  6608      4765          bne.s     ChangeRegisters_36
                    4766   ; a5 = reg_val ;
000027C8  23C3 0B00 4767          move.l    D3,_a5.L
000027CC  0118      
000027CE  6014      4768          bra.s     ChangeRegisters_39
                    4769   ChangeRegisters_36:
                    4770   ; else if(c == (char)('6'))
000027D0  0C02 0036 4771          cmp.b     #54,D2
000027D4  6608      4772          bne.s     ChangeRegisters_38
                    4773   ; a6 = reg_val ;
000027D6  23C3 0B00 4774          move.l    D3,_a6.L
000027DA  011C      
000027DC  6006      4775          bra.s     ChangeRegisters_39
                    4776   ChangeRegisters_38:
                    4777   ; else
                    4778   ; USP = reg_val ;
000027DE  23C3 0B00 4779          move.l    D3,_USP.L
000027E2  0128      
                    4780   ChangeRegisters_39:
000027E4  6000 0108 4781          bra       ChangeRegisters_51
                    4782   ChangeRegisters_21:
                    4783   ; }
                    4784   ; else if((reg[0] == (char)('u')) && (c == (char)('s')))  {
000027E8  1013      4785          move.b    (A3),D0
000027EA  0C00 0075 4786          cmp.b     #117,D0
000027EE  6600 004E 4787          bne       ChangeRegisters_40
000027F2  0C02 0073 4788          cmp.b     #115,D2
000027F6  6600 0046 4789          bne       ChangeRegisters_40
                    4790   ; if(tolower(_getch()) == 'p')  {    // change user stack pointer
000027FA  2F00      4791          move.l    D0,-(A7)
000027FC  4E95      4792          jsr       (A5)
000027FE  2200      4793          move.l    D0,D1
00002800  201F      4794          move.l    (A7)+,D0
00002802  2F01      4795          move.l    D1,-(A7)
00002804  4EB9 0000 4796          jsr       _tolower
00002808  3DB4      
0000280A  584F      4797          addq.w    #4,A7
0000280C  0C80 0000 4798          cmp.l     #112,D0
00002810  0070      
00002812  6618      4799          bne.s     ChangeRegisters_42
                    4800   ; printf("\r\nUser SP = ") ;
00002814  4879 0000 4801          pea       @m68kde~1_92.L
00002818  5A8E      
0000281A  4E92      4802          jsr       (A2)
0000281C  584F      4803          addq.w    #4,A7
                    4804   ; USP = Get8HexDigits(0) ;    // read 32 bit value from user keyboard
0000281E  42A7      4805          clr.l     -(A7)
00002820  4E94      4806          jsr       (A4)
00002822  584F      4807          addq.w    #4,A7
00002824  23C0 0B00 4808          move.l    D0,_USP.L
00002828  0128      
0000282A  600E      4809          bra.s     ChangeRegisters_43
                    4810   ChangeRegisters_42:
                    4811   ; }
                    4812   ; else {
                    4813   ; printf("\r\nIllegal Register....") ;
0000282C  4879 0000 4814          pea       @m68kde~1_93.L
00002830  5A9C      
00002832  4E92      4815          jsr       (A2)
00002834  584F      4816          addq.w    #4,A7
                    4817   ; return ;
00002836  6000 00BA 4818          bra       ChangeRegisters_6
                    4819   ChangeRegisters_43:
0000283A  6000 00B2 4820          bra       ChangeRegisters_51
                    4821   ChangeRegisters_40:
                    4822   ; }
                    4823   ; }
                    4824   ; else if((reg[0] == (char)('s')) && (c == (char)('s')))  {
0000283E  1013      4825          move.b    (A3),D0
00002840  0C00 0073 4826          cmp.b     #115,D0
00002844  6600 004E 4827          bne       ChangeRegisters_44
00002848  0C02 0073 4828          cmp.b     #115,D2
0000284C  6600 0046 4829          bne       ChangeRegisters_44
                    4830   ; if(tolower(_getch()) == 'p')  {    // change system stack pointer
00002850  2F00      4831          move.l    D0,-(A7)
00002852  4E95      4832          jsr       (A5)
00002854  2200      4833          move.l    D0,D1
00002856  201F      4834          move.l    (A7)+,D0
00002858  2F01      4835          move.l    D1,-(A7)
0000285A  4EB9 0000 4836          jsr       _tolower
0000285E  3DB4      
00002860  584F      4837          addq.w    #4,A7
00002862  0C80 0000 4838          cmp.l     #112,D0
00002866  0070      
00002868  6618      4839          bne.s     ChangeRegisters_46
                    4840   ; printf("\r\nSystem SP = ") ;
0000286A  4879 0000 4841          pea       @m68kde~1_94.L
0000286E  5AB4      
00002870  4E92      4842          jsr       (A2)
00002872  584F      4843          addq.w    #4,A7
                    4844   ; SSP = Get8HexDigits(0) ;    // read 32 bit value from user keyboard
00002874  42A7      4845          clr.l     -(A7)
00002876  4E94      4846          jsr       (A4)
00002878  584F      4847          addq.w    #4,A7
0000287A  23C0 0B00 4848          move.l    D0,_SSP.L
0000287E  0124      
00002880  600E      4849          bra.s     ChangeRegisters_47
                    4850   ChangeRegisters_46:
                    4851   ; }
                    4852   ; else {
                    4853   ; printf("\r\nIllegal Register....") ;
00002882  4879 0000 4854          pea       @m68kde~1_93.L
00002886  5A9C      
00002888  4E92      4855          jsr       (A2)
0000288A  584F      4856          addq.w    #4,A7
                    4857   ; return ;
0000288C  6000 0064 4858          bra       ChangeRegisters_6
                    4859   ChangeRegisters_47:
00002890  6000 005C 4860          bra       ChangeRegisters_51
                    4861   ChangeRegisters_44:
                    4862   ; }
                    4863   ; }
                    4864   ; else if((reg[0] == (char)('p')) && (c == (char)('c')))  {    // change program counter
00002894  1013      4865          move.b    (A3),D0
00002896  0C00 0070 4866          cmp.b     #112,D0
0000289A  6620      4867          bne.s     ChangeRegisters_48
0000289C  0C02 0063 4868          cmp.b     #99,D2
000028A0  661A      4869          bne.s     ChangeRegisters_48
                    4870   ; printf("\r\nPC = ") ;
000028A2  4879 0000 4871          pea       @m68kde~1_95.L
000028A6  5AC4      
000028A8  4E92      4872          jsr       (A2)
000028AA  584F      4873          addq.w    #4,A7
                    4874   ; PC = Get8HexDigits(0) ;    // read 32 bit value from user keyboard
000028AC  42A7      4875          clr.l     -(A7)
000028AE  4E94      4876          jsr       (A4)
000028B0  584F      4877          addq.w    #4,A7
000028B2  23C0 0B00 4878          move.l    D0,_PC.L
000028B6  0120      
000028B8  6000 0034 4879          bra       ChangeRegisters_51
                    4880   ChangeRegisters_48:
                    4881   ; }
                    4882   ; else if((reg[0] == (char)('s')) && (c == (char)('r')))  {    // change status register
000028BC  1013      4883          move.b    (A3),D0
000028BE  0C00 0073 4884          cmp.b     #115,D0
000028C2  6620      4885          bne.s     ChangeRegisters_50
000028C4  0C02 0072 4886          cmp.b     #114,D2
000028C8  661A      4887          bne.s     ChangeRegisters_50
                    4888   ; printf("\r\nSR = ") ;
000028CA  4879 0000 4889          pea       @m68kde~1_96.L
000028CE  5ACC      
000028D0  4E92      4890          jsr       (A2)
000028D2  584F      4891          addq.w    #4,A7
                    4892   ; SR = Get4HexDigits(0) ;    // read 16 bit value from user keyboard
000028D4  42A7      4893          clr.l     -(A7)
000028D6  4EB8 0EBA 4894          jsr       _Get4HexDigits
000028DA  584F      4895          addq.w    #4,A7
000028DC  33C0 0B00 4896          move.w    D0,_SR.L
000028E0  012C      
000028E2  600A      4897          bra.s     ChangeRegisters_51
                    4898   ChangeRegisters_50:
                    4899   ; }
                    4900   ; else
                    4901   ; printf("\r\nIllegal Register: Use A0-A7, D0-D7, SSP, USP, PC or SR\r\n") ;
000028E4  4879 0000 4902          pea       @m68kde~1_97.L
000028E8  5AD4      
000028EA  4E92      4903          jsr       (A2)
000028EC  584F      4904          addq.w    #4,A7
                    4905   ChangeRegisters_51:
                    4906   ; DumpRegisters() ;
000028EE  4EB8 214C 4907          jsr       _DumpRegisters
                    4908   ChangeRegisters_6:
000028F2  4CDF 3C0C 4909          movem.l   (A7)+,D2/D3/A2/A3/A4/A5
000028F6  4E5E      4910          unlk      A6
000028F8  4E75      4911          rts
                    4912   ; }
                    4913   ; void BreakPointDisplay(void)
                    4914   ; {
                    4915   _BreakPointDisplay:
000028FA  48E7 3030 4916          movem.l   D2/D3/A2/A3,-(A7)
000028FE  45F9 0000 4917          lea       _printf.L,A2
00002902  3C28      
00002904  47F9 0B00 4918          lea       _BreakPointAddress.L,A3
00002908  012E      
                    4919   ; int i, BreakPointsSet = 0 ;
0000290A  4283      4920          clr.l     D3
                    4921   ; // any break points  set
                    4922   ; for(i = 0; i < 8; i++)  {
0000290C  4282      4923          clr.l     D2
                    4924   BreakPointDisplay_1:
0000290E  0C82 0000 4925          cmp.l     #8,D2
00002912  0008      
00002914  6C1C      4926          bge.s     BreakPointDisplay_3
                    4927   ; if(BreakPointSetOrCleared[i] == 1)
00002916  2002      4928          move.l    D2,D0
00002918  E588      4929          lsl.l     #2,D0
0000291A  41F9 0B00 4930          lea       _BreakPointSetOrCleared.L,A0
0000291E  015E      
00002920  2030 0800 4931          move.l    0(A0,D0.L),D0
00002924  0C80 0000 4932          cmp.l     #1,D0
00002928  0001      
0000292A  6602      4933          bne.s     BreakPointDisplay_4
                    4934   ; BreakPointsSet = 1;
0000292C  7601      4935          moveq     #1,D3
                    4936   BreakPointDisplay_4:
0000292E  5282      4937          addq.l    #1,D2
00002930  60DC      4938          bra       BreakPointDisplay_1
                    4939   BreakPointDisplay_3:
                    4940   ; }
                    4941   ; if(BreakPointsSet == 1) {
00002932  0C83 0000 4942          cmp.l     #1,D3
00002936  0001      
00002938  6616      4943          bne.s     BreakPointDisplay_6
                    4944   ; printf("\r\n\r\nNum     Address      Instruction") ;
0000293A  4879 0000 4945          pea       @m68kde~1_98.L
0000293E  5B10      
00002940  4E92      4946          jsr       (A2)
00002942  584F      4947          addq.w    #4,A7
                    4948   ; printf("\r\n---     ---------    -----------") ;
00002944  4879 0000 4949          pea       @m68kde~1_99.L
00002948  5B36      
0000294A  4E92      4950          jsr       (A2)
0000294C  584F      4951          addq.w    #4,A7
0000294E  600A      4952          bra.s     BreakPointDisplay_7
                    4953   BreakPointDisplay_6:
                    4954   ; }
                    4955   ; else
                    4956   ; printf("\r\nNo BreakPoints Set") ;
00002950  4879 0000 4957          pea       @m68kde~1_100.L
00002954  5B5A      
00002956  4E92      4958          jsr       (A2)
00002958  584F      4959          addq.w    #4,A7
                    4960   BreakPointDisplay_7:
                    4961   ; for(i = 0; i < 8; i++)  {
0000295A  4282      4962          clr.l     D2
                    4963   BreakPointDisplay_8:
0000295C  0C82 0000 4964          cmp.l     #8,D2
00002960  0008      
00002962  6C00 005A 4965          bge       BreakPointDisplay_10
                    4966   ; // put opcode back, then put break point back
                    4967   ; if(BreakPointSetOrCleared[i] == 1)  {
00002966  2002      4968          move.l    D2,D0
00002968  E588      4969          lsl.l     #2,D0
0000296A  41F9 0B00 4970          lea       _BreakPointSetOrCleared.L,A0
0000296E  015E      
00002970  2030 0800 4971          move.l    0(A0,D0.L),D0
00002974  0C80 0000 4972          cmp.l     #1,D0
00002978  0001      
0000297A  6600 003E 4973          bne       BreakPointDisplay_11
                    4974   ; *(unsigned short int *)(BreakPointAddress[i]) = BreakPointInstruction[i];
0000297E  2002      4975          move.l    D2,D0
00002980  E388      4976          lsl.l     #1,D0
00002982  41F9 0B00 4977          lea       _BreakPointInstruction.L,A0
00002986  014E      
00002988  2202      4978          move.l    D2,D1
0000298A  E589      4979          lsl.l     #2,D1
0000298C  2233 1800 4980          move.l    0(A3,D1.L),D1
00002990  2241      4981          move.l    D1,A1
00002992  32B0 0800 4982          move.w    0(A0,D0.L),(A1)
                    4983   ; *(unsigned short int *)(BreakPointAddress[i]) = (unsigned short int)(0x4e4e) ;
00002996  2002      4984          move.l    D2,D0
00002998  E588      4985          lsl.l     #2,D0
0000299A  2033 0800 4986          move.l    0(A3,D0.L),D0
0000299E  2040      4987          move.l    D0,A0
000029A0  30BC 4E4E 4988          move.w    #20046,(A0)
                    4989   ; printf("\r\n%3d     $%08x",i, BreakPointAddress[i]) ;
000029A4  2202      4990          move.l    D2,D1
000029A6  E589      4991          lsl.l     #2,D1
000029A8  2F33 1800 4992          move.l    0(A3,D1.L),-(A7)
000029AC  2F02      4993          move.l    D2,-(A7)
000029AE  4879 0000 4994          pea       @m68kde~1_101.L
000029B2  5B70      
000029B4  4E92      4995          jsr       (A2)
000029B6  DEFC 000C 4996          add.w     #12,A7
                    4997   BreakPointDisplay_11:
000029BA  5282      4998          addq.l    #1,D2
000029BC  609E      4999          bra       BreakPointDisplay_8
                    5000   BreakPointDisplay_10:
                    5001   ; }
                    5002   ; }
                    5003   ; printf("\r\n") ;
000029BE  4879 0000 5004          pea       @m68kde~1_1.L
000029C2  50C8      
000029C4  4E92      5005          jsr       (A2)
000029C6  584F      5006          addq.w    #4,A7
000029C8  4CDF 0C0C 5007          movem.l   (A7)+,D2/D3/A2/A3
000029CC  4E75      5008          rts
                    5009   ; }
                    5010   ; void WatchPointDisplay(void)
                    5011   ; {
                    5012   _WatchPointDisplay:
000029CE  48E7 3020 5013          movem.l   D2/D3/A2,-(A7)
000029D2  45F9 0000 5014          lea       _printf.L,A2
000029D6  3C28      
                    5015   ; int i ;
                    5016   ; int WatchPointsSet = 0 ;
000029D8  4283      5017          clr.l     D3
                    5018   ; // any watchpoints set
                    5019   ; for(i = 0; i < 8; i++)  {
000029DA  4282      5020          clr.l     D2
                    5021   WatchPointDisplay_1:
000029DC  0C82 0000 5022          cmp.l     #8,D2
000029E0  0008      
000029E2  6C1C      5023          bge.s     WatchPointDisplay_3
                    5024   ; if(WatchPointSetOrCleared[i] == 1)
000029E4  2002      5025          move.l    D2,D0
000029E6  E588      5026          lsl.l     #2,D0
000029E8  41F9 0B00 5027          lea       _WatchPointSetOrCleared.L,A0
000029EC  01A2      
000029EE  2030 0800 5028          move.l    0(A0,D0.L),D0
000029F2  0C80 0000 5029          cmp.l     #1,D0
000029F6  0001      
000029F8  6602      5030          bne.s     WatchPointDisplay_4
                    5031   ; WatchPointsSet = 1;
000029FA  7601      5032          moveq     #1,D3
                    5033   WatchPointDisplay_4:
000029FC  5282      5034          addq.l    #1,D2
000029FE  60DC      5035          bra       WatchPointDisplay_1
                    5036   WatchPointDisplay_3:
                    5037   ; }
                    5038   ; if(WatchPointsSet == 1) {
00002A00  0C83 0000 5039          cmp.l     #1,D3
00002A04  0001      
00002A06  6616      5040          bne.s     WatchPointDisplay_6
                    5041   ; printf("\r\nNum     Address") ;
00002A08  4879 0000 5042          pea       @m68kde~1_102.L
00002A0C  5B80      
00002A0E  4E92      5043          jsr       (A2)
00002A10  584F      5044          addq.w    #4,A7
                    5045   ; printf("\r\n---     ---------") ;
00002A12  4879 0000 5046          pea       @m68kde~1_103.L
00002A16  5B92      
00002A18  4E92      5047          jsr       (A2)
00002A1A  584F      5048          addq.w    #4,A7
00002A1C  600A      5049          bra.s     WatchPointDisplay_7
                    5050   WatchPointDisplay_6:
                    5051   ; }
                    5052   ; else
                    5053   ; printf("\r\nNo WatchPoints Set") ;
00002A1E  4879 0000 5054          pea       @m68kde~1_104.L
00002A22  5BA6      
00002A24  4E92      5055          jsr       (A2)
00002A26  584F      5056          addq.w    #4,A7
                    5057   WatchPointDisplay_7:
                    5058   ; for(i = 0; i < 8; i++)  {
00002A28  4282      5059          clr.l     D2
                    5060   WatchPointDisplay_8:
00002A2A  0C82 0000 5061          cmp.l     #8,D2
00002A2E  0008      
00002A30  6C00 0038 5062          bge       WatchPointDisplay_10
                    5063   ; if(WatchPointSetOrCleared[i] == 1)
00002A34  2002      5064          move.l    D2,D0
00002A36  E588      5065          lsl.l     #2,D0
00002A38  41F9 0B00 5066          lea       _WatchPointSetOrCleared.L,A0
00002A3C  01A2      
00002A3E  2030 0800 5067          move.l    0(A0,D0.L),D0
00002A42  0C80 0000 5068          cmp.l     #1,D0
00002A46  0001      
00002A48  661C      5069          bne.s     WatchPointDisplay_11
                    5070   ; printf("\r\n%3d     $%08x",i, WatchPointAddress[i]) ;
00002A4A  2202      5071          move.l    D2,D1
00002A4C  E589      5072          lsl.l     #2,D1
00002A4E  41F9 0B00 5073          lea       _WatchPointAddress.L,A0
00002A52  0182      
00002A54  2F30 1800 5074          move.l    0(A0,D1.L),-(A7)
00002A58  2F02      5075          move.l    D2,-(A7)
00002A5A  4879 0000 5076          pea       @m68kde~1_101.L
00002A5E  5B70      
00002A60  4E92      5077          jsr       (A2)
00002A62  DEFC 000C 5078          add.w     #12,A7
                    5079   WatchPointDisplay_11:
00002A66  5282      5080          addq.l    #1,D2
00002A68  60C0      5081          bra       WatchPointDisplay_8
                    5082   WatchPointDisplay_10:
                    5083   ; }
                    5084   ; printf("\r\n") ;
00002A6A  4879 0000 5085          pea       @m68kde~1_1.L
00002A6E  50C8      
00002A70  4E92      5086          jsr       (A2)
00002A72  584F      5087          addq.w    #4,A7
00002A74  4CDF 040C 5088          movem.l   (A7)+,D2/D3/A2
00002A78  4E75      5089          rts
                    5090   ; }
                    5091   ; void BreakPointClear(void)
                    5092   ; {
                    5093   _BreakPointClear:
00002A7A  4E56 FFFC 5094          link      A6,#-4
00002A7E  48E7 2020 5095          movem.l   D2/A2,-(A7)
00002A82  45F9 0000 5096          lea       _printf.L,A2
00002A86  3C28      
                    5097   ; unsigned int i ;
                    5098   ; volatile unsigned short int *ProgramBreakPointAddress ;
                    5099   ; BreakPointDisplay() ;
00002A88  4EB8 28FA 5100          jsr       _BreakPointDisplay
                    5101   ; printf("\r\nEnter Break Point Number: ") ;
00002A8C  4879 0000 5102          pea       @m68kde~1_105.L
00002A90  5BBC      
00002A92  4E92      5103          jsr       (A2)
00002A94  584F      5104          addq.w    #4,A7
                    5105   ; i = xtod(_getch()) ;           // get break pointer number
00002A96  2F00      5106          move.l    D0,-(A7)
00002A98  4EB8 0DCA 5107          jsr       __getch
00002A9C  2200      5108          move.l    D0,D1
00002A9E  201F      5109          move.l    (A7)+,D0
00002AA0  2F01      5110          move.l    D1,-(A7)
00002AA2  4EB8 0E34 5111          jsr       _xtod
00002AA6  584F      5112          addq.w    #4,A7
00002AA8  C0BC 0000 5113          and.l     #255,D0
00002AAC  00FF      
00002AAE  2400      5114          move.l    D0,D2
                    5115   ; if((i < 0) || (i > 7))   {
00002AB0  0C82 0000 5116          cmp.l     #0,D2
00002AB4  0000      
00002AB6  6508      5117          blo.s     BreakPointClear_3
00002AB8  0C82 0000 5118          cmp.l     #7,D2
00002ABC  0007      
00002ABE  630E      5119          bls.s     BreakPointClear_1
                    5120   BreakPointClear_3:
                    5121   ; printf("\r\nIllegal Range : Use 0 - 7") ;
00002AC0  4879 0000 5122          pea       @m68kde~1_106.L
00002AC4  5BDA      
00002AC6  4E92      5123          jsr       (A2)
00002AC8  584F      5124          addq.w    #4,A7
                    5125   ; return ;
00002ACA  6000 0080 5126          bra       BreakPointClear_4
                    5127   BreakPointClear_1:
                    5128   ; }
                    5129   ; if(BreakPointSetOrCleared[i] == 1)  {       // if break point set
00002ACE  2002      5130          move.l    D2,D0
00002AD0  E588      5131          lsl.l     #2,D0
00002AD2  41F9 0B00 5132          lea       _BreakPointSetOrCleared.L,A0
00002AD6  015E      
00002AD8  2030 0800 5133          move.l    0(A0,D0.L),D0
00002ADC  0C80 0000 5134          cmp.l     #1,D0
00002AE0  0001      
00002AE2  6600 005A 5135          bne       BreakPointClear_5
                    5136   ; ProgramBreakPointAddress = (volatile unsigned short int *)(BreakPointAddress[i]) ;     // point to the instruction in the user program we are about to change
00002AE6  2002      5137          move.l    D2,D0
00002AE8  E588      5138          lsl.l     #2,D0
00002AEA  41F9 0B00 5139          lea       _BreakPointAddress.L,A0
00002AEE  012E      
00002AF0  2D70 0800 5140          move.l    0(A0,D0.L),-4(A6)
00002AF4  FFFC      
                    5141   ; BreakPointAddress[i] = 0 ;
00002AF6  2002      5142          move.l    D2,D0
00002AF8  E588      5143          lsl.l     #2,D0
00002AFA  41F9 0B00 5144          lea       _BreakPointAddress.L,A0
00002AFE  012E      
00002B00  42B0 0800 5145          clr.l     0(A0,D0.L)
                    5146   ; BreakPointSetOrCleared[i] = 0 ;
00002B04  2002      5147          move.l    D2,D0
00002B06  E588      5148          lsl.l     #2,D0
00002B08  41F9 0B00 5149          lea       _BreakPointSetOrCleared.L,A0
00002B0C  015E      
00002B0E  42B0 0800 5150          clr.l     0(A0,D0.L)
                    5151   ; *ProgramBreakPointAddress = BreakPointInstruction[i] ;  // put original instruction back
00002B12  2002      5152          move.l    D2,D0
00002B14  E388      5153          lsl.l     #1,D0
00002B16  41F9 0B00 5154          lea       _BreakPointInstruction.L,A0
00002B1A  014E      
00002B1C  226E FFFC 5155          move.l    -4(A6),A1
00002B20  32B0 0800 5156          move.w    0(A0,D0.L),(A1)
                    5157   ; BreakPointInstruction[i] = 0 ;
00002B24  2002      5158          move.l    D2,D0
00002B26  E388      5159          lsl.l     #1,D0
00002B28  41F9 0B00 5160          lea       _BreakPointInstruction.L,A0
00002B2C  014E      
00002B2E  4270 0800 5161          clr.w     0(A0,D0.L)
                    5162   ; printf("\r\nBreak Point Cleared.....\r\n") ;
00002B32  4879 0000 5163          pea       @m68kde~1_107.L
00002B36  5BF6      
00002B38  4E92      5164          jsr       (A2)
00002B3A  584F      5165          addq.w    #4,A7
00002B3C  600A      5166          bra.s     BreakPointClear_6
                    5167   BreakPointClear_5:
                    5168   ; }
                    5169   ; else
                    5170   ; printf("\r\nBreak Point wasn't Set.....") ;
00002B3E  4879 0000 5171          pea       @m68kde~1_108.L
00002B42  5C14      
00002B44  4E92      5172          jsr       (A2)
00002B46  584F      5173          addq.w    #4,A7
                    5174   BreakPointClear_6:
                    5175   ; BreakPointDisplay() ;
00002B48  4EB8 28FA 5176          jsr       _BreakPointDisplay
                    5177   ; return ;
                    5178   BreakPointClear_4:
00002B4C  4CDF 0404 5179          movem.l   (A7)+,D2/A2
00002B50  4E5E      5180          unlk      A6
00002B52  4E75      5181          rts
                    5182   ; }
                    5183   ; void WatchPointClear(void)
                    5184   ; {
                    5185   _WatchPointClear:
00002B54  48E7 2020 5186          movem.l   D2/A2,-(A7)
00002B58  45F9 0000 5187          lea       _printf.L,A2
00002B5C  3C28      
                    5188   ; unsigned int i ;
                    5189   ; WatchPointDisplay() ;
00002B5E  4EB8 29CE 5190          jsr       _WatchPointDisplay
                    5191   ; printf("\r\nEnter Watch Point Number: ") ;
00002B62  4879 0000 5192          pea       @m68kde~1_109.L
00002B66  5C32      
00002B68  4E92      5193          jsr       (A2)
00002B6A  584F      5194          addq.w    #4,A7
                    5195   ; i = xtod(_getch()) ;           // get watch pointer number
00002B6C  2F00      5196          move.l    D0,-(A7)
00002B6E  4EB8 0DCA 5197          jsr       __getch
00002B72  2200      5198          move.l    D0,D1
00002B74  201F      5199          move.l    (A7)+,D0
00002B76  2F01      5200          move.l    D1,-(A7)
00002B78  4EB8 0E34 5201          jsr       _xtod
00002B7C  584F      5202          addq.w    #4,A7
00002B7E  C0BC 0000 5203          and.l     #255,D0
00002B82  00FF      
00002B84  2400      5204          move.l    D0,D2
                    5205   ; if((i < 0) || (i > 7))   {
00002B86  0C82 0000 5206          cmp.l     #0,D2
00002B8A  0000      
00002B8C  6508      5207          blo.s     WatchPointClear_3
00002B8E  0C82 0000 5208          cmp.l     #7,D2
00002B92  0007      
00002B94  630E      5209          bls.s     WatchPointClear_1
                    5210   WatchPointClear_3:
                    5211   ; printf("\r\nIllegal Range : Use 0 - 7") ;
00002B96  4879 0000 5212          pea       @m68kde~1_106.L
00002B9A  5BDA      
00002B9C  4E92      5213          jsr       (A2)
00002B9E  584F      5214          addq.w    #4,A7
                    5215   ; return ;
00002BA0  6000 004E 5216          bra       WatchPointClear_4
                    5217   WatchPointClear_1:
                    5218   ; }
                    5219   ; if(WatchPointSetOrCleared[i] == 1)  {       // if watch point set
00002BA4  2002      5220          move.l    D2,D0
00002BA6  E588      5221          lsl.l     #2,D0
00002BA8  41F9 0B00 5222          lea       _WatchPointSetOrCleared.L,A0
00002BAC  01A2      
00002BAE  2030 0800 5223          move.l    0(A0,D0.L),D0
00002BB2  0C80 0000 5224          cmp.l     #1,D0
00002BB6  0001      
00002BB8  6628      5225          bne.s     WatchPointClear_5
                    5226   ; WatchPointAddress[i] = 0 ;
00002BBA  2002      5227          move.l    D2,D0
00002BBC  E588      5228          lsl.l     #2,D0
00002BBE  41F9 0B00 5229          lea       _WatchPointAddress.L,A0
00002BC2  0182      
00002BC4  42B0 0800 5230          clr.l     0(A0,D0.L)
                    5231   ; WatchPointSetOrCleared[i] = 0 ;
00002BC8  2002      5232          move.l    D2,D0
00002BCA  E588      5233          lsl.l     #2,D0
00002BCC  41F9 0B00 5234          lea       _WatchPointSetOrCleared.L,A0
00002BD0  01A2      
00002BD2  42B0 0800 5235          clr.l     0(A0,D0.L)
                    5236   ; printf("\r\nWatch Point Cleared.....\r\n") ;
00002BD6  4879 0000 5237          pea       @m68kde~1_110.L
00002BDA  5C50      
00002BDC  4E92      5238          jsr       (A2)
00002BDE  584F      5239          addq.w    #4,A7
00002BE0  600A      5240          bra.s     WatchPointClear_6
                    5241   WatchPointClear_5:
                    5242   ; }
                    5243   ; else
                    5244   ; printf("\r\nWatch Point Was not Set.....") ;
00002BE2  4879 0000 5245          pea       @m68kde~1_111.L
00002BE6  5C6E      
00002BE8  4E92      5246          jsr       (A2)
00002BEA  584F      5247          addq.w    #4,A7
                    5248   WatchPointClear_6:
                    5249   ; WatchPointDisplay() ;
00002BEC  4EB8 29CE 5250          jsr       _WatchPointDisplay
                    5251   ; return ;
                    5252   WatchPointClear_4:
00002BF0  4CDF 0404 5253          movem.l   (A7)+,D2/A2
00002BF4  4E75      5254          rts
                    5255   ; }
                    5256   ; void DisableBreakPoints(void)
                    5257   ; {
                    5258   _DisableBreakPoints:
00002BF6  4E56 FFFC 5259          link      A6,#-4
00002BFA  2F02      5260          move.l    D2,-(A7)
                    5261   ; int i ;
                    5262   ; volatile unsigned short int *ProgramBreakPointAddress ;
                    5263   ; for(i = 0; i < 8; i++)  {
00002BFC  4282      5264          clr.l     D2
                    5265   DisableBreakPoints_1:
00002BFE  0C82 0000 5266          cmp.l     #8,D2
00002C02  0008      
00002C04  6C00 003E 5267          bge       DisableBreakPoints_3
                    5268   ; if(BreakPointSetOrCleared[i] == 1)    {                                                    // if break point set
00002C08  2002      5269          move.l    D2,D0
00002C0A  E588      5270          lsl.l     #2,D0
00002C0C  41F9 0B00 5271          lea       _BreakPointSetOrCleared.L,A0
00002C10  015E      
00002C12  2030 0800 5272          move.l    0(A0,D0.L),D0
00002C16  0C80 0000 5273          cmp.l     #1,D0
00002C1A  0001      
00002C1C  6622      5274          bne.s     DisableBreakPoints_4
                    5275   ; ProgramBreakPointAddress = (volatile unsigned short int *)(BreakPointAddress[i]) ;     // point to the instruction in the user program where the break point has been set
00002C1E  2002      5276          move.l    D2,D0
00002C20  E588      5277          lsl.l     #2,D0
00002C22  41F9 0B00 5278          lea       _BreakPointAddress.L,A0
00002C26  012E      
00002C28  2D70 0800 5279          move.l    0(A0,D0.L),-4(A6)
00002C2C  FFFC      
                    5280   ; *ProgramBreakPointAddress = BreakPointInstruction[i];                                  // copy the instruction back to the user program overwritting the $4e4e
00002C2E  2002      5281          move.l    D2,D0
00002C30  E388      5282          lsl.l     #1,D0
00002C32  41F9 0B00 5283          lea       _BreakPointInstruction.L,A0
00002C36  014E      
00002C38  226E FFFC 5284          move.l    -4(A6),A1
00002C3C  32B0 0800 5285          move.w    0(A0,D0.L),(A1)
                    5286   DisableBreakPoints_4:
00002C40  5282      5287          addq.l    #1,D2
00002C42  60BA      5288          bra       DisableBreakPoints_1
                    5289   DisableBreakPoints_3:
00002C44  241F      5290          move.l    (A7)+,D2
00002C46  4E5E      5291          unlk      A6
00002C48  4E75      5292          rts
                    5293   ; }
                    5294   ; }
                    5295   ; }
                    5296   ; void EnableBreakPoints(void)
                    5297   ; {
                    5298   _EnableBreakPoints:
00002C4A  4E56 FFFC 5299          link      A6,#-4
00002C4E  2F02      5300          move.l    D2,-(A7)
                    5301   ; int i ;
                    5302   ; volatile unsigned short int *ProgramBreakPointAddress ;
                    5303   ; for(i = 0; i < 8; i++)  {
00002C50  4282      5304          clr.l     D2
                    5305   EnableBreakPoints_1:
00002C52  0C82 0000 5306          cmp.l     #8,D2
00002C56  0008      
00002C58  6C32      5307          bge.s     EnableBreakPoints_3
                    5308   ; if(BreakPointSetOrCleared[i] == 1)    {                                                     // if break point set
00002C5A  2002      5309          move.l    D2,D0
00002C5C  E588      5310          lsl.l     #2,D0
00002C5E  41F9 0B00 5311          lea       _BreakPointSetOrCleared.L,A0
00002C62  015E      
00002C64  2030 0800 5312          move.l    0(A0,D0.L),D0
00002C68  0C80 0000 5313          cmp.l     #1,D0
00002C6C  0001      
00002C6E  6618      5314          bne.s     EnableBreakPoints_4
                    5315   ; ProgramBreakPointAddress = (volatile unsigned short int *)(BreakPointAddress[i]) ;     // point to the instruction in the user program where the break point has been set
00002C70  2002      5316          move.l    D2,D0
00002C72  E588      5317          lsl.l     #2,D0
00002C74  41F9 0B00 5318          lea       _BreakPointAddress.L,A0
00002C78  012E      
00002C7A  2D70 0800 5319          move.l    0(A0,D0.L),-4(A6)
00002C7E  FFFC      
                    5320   ; *ProgramBreakPointAddress = (unsigned short int)(0x4e4e);                              // put the breakpoint back in user program
00002C80  206E FFFC 5321          move.l    -4(A6),A0
00002C84  30BC 4E4E 5322          move.w    #20046,(A0)
                    5323   EnableBreakPoints_4:
00002C88  5282      5324          addq.l    #1,D2
00002C8A  60C6      5325          bra       EnableBreakPoints_1
                    5326   EnableBreakPoints_3:
00002C8C  241F      5327          move.l    (A7)+,D2
00002C8E  4E5E      5328          unlk      A6
00002C90  4E75      5329          rts
                    5330   ; }
                    5331   ; }
                    5332   ; }
                    5333   ; void KillAllBreakPoints(void)
                    5334   ; {
                    5335   _KillAllBreakPoints:
00002C92  4E56 FFFC 5336          link      A6,#-4
00002C96  2F02      5337          move.l    D2,-(A7)
                    5338   ; int i ;
                    5339   ; volatile unsigned short int *ProgramBreakPointAddress ;
                    5340   ; for(i = 0; i < 8; i++)  {
00002C98  4282      5341          clr.l     D2
                    5342   KillAllBreakPoints_1:
00002C9A  0C82 0000 5343          cmp.l     #8,D2
00002C9E  0008      
00002CA0  6C00 0052 5344          bge       KillAllBreakPoints_3
                    5345   ; // clear BP
                    5346   ; ProgramBreakPointAddress = (volatile unsigned short int *)(BreakPointAddress[i]) ;     // point to the instruction in the user program where the break point has been set
00002CA4  2002      5347          move.l    D2,D0
00002CA6  E588      5348          lsl.l     #2,D0
00002CA8  41F9 0B00 5349          lea       _BreakPointAddress.L,A0
00002CAC  012E      
00002CAE  2D70 0800 5350          move.l    0(A0,D0.L),-4(A6)
00002CB2  FFFC      
                    5351   ; *ProgramBreakPointAddress = BreakPointInstruction[i];                                  // copy the instruction back to the user program
00002CB4  2002      5352          move.l    D2,D0
00002CB6  E388      5353          lsl.l     #1,D0
00002CB8  41F9 0B00 5354          lea       _BreakPointInstruction.L,A0
00002CBC  014E      
00002CBE  226E FFFC 5355          move.l    -4(A6),A1
00002CC2  32B0 0800 5356          move.w    0(A0,D0.L),(A1)
                    5357   ; BreakPointAddress[i] = 0 ;                                                             // set BP address to NULL
00002CC6  2002      5358          move.l    D2,D0
00002CC8  E588      5359          lsl.l     #2,D0
00002CCA  41F9 0B00 5360          lea       _BreakPointAddress.L,A0
00002CCE  012E      
00002CD0  42B0 0800 5361          clr.l     0(A0,D0.L)
                    5362   ; BreakPointInstruction[i] = 0 ;
00002CD4  2002      5363          move.l    D2,D0
00002CD6  E388      5364          lsl.l     #1,D0
00002CD8  41F9 0B00 5365          lea       _BreakPointInstruction.L,A0
00002CDC  014E      
00002CDE  4270 0800 5366          clr.w     0(A0,D0.L)
                    5367   ; BreakPointSetOrCleared[i] = 0 ;                                                        // mark break point as cleared for future setting
00002CE2  2002      5368          move.l    D2,D0
00002CE4  E588      5369          lsl.l     #2,D0
00002CE6  41F9 0B00 5370          lea       _BreakPointSetOrCleared.L,A0
00002CEA  015E      
00002CEC  42B0 0800 5371          clr.l     0(A0,D0.L)
00002CF0  5282      5372          addq.l    #1,D2
00002CF2  60A6      5373          bra       KillAllBreakPoints_1
                    5374   KillAllBreakPoints_3:
00002CF4  241F      5375          move.l    (A7)+,D2
00002CF6  4E5E      5376          unlk      A6
00002CF8  4E75      5377          rts
                    5378   ; }
                    5379   ; //BreakPointDisplay() ;       // display the break points
                    5380   ; }
                    5381   ; void KillAllWatchPoints(void)
                    5382   ; {
                    5383   _KillAllWatchPoints:
00002CFA  2F02      5384          move.l    D2,-(A7)
                    5385   ; int i ;
                    5386   ; for(i = 0; i < 8; i++)  {
00002CFC  4282      5387          clr.l     D2
                    5388   KillAllWatchPoints_1:
00002CFE  0C82 0000 5389          cmp.l     #8,D2
00002D02  0008      
00002D04  6C20      5390          bge.s     KillAllWatchPoints_3
                    5391   ; WatchPointAddress[i] = 0 ;                                                             // set BP address to NULL
00002D06  2002      5392          move.l    D2,D0
00002D08  E588      5393          lsl.l     #2,D0
00002D0A  41F9 0B00 5394          lea       _WatchPointAddress.L,A0
00002D0E  0182      
00002D10  42B0 0800 5395          clr.l     0(A0,D0.L)
                    5396   ; WatchPointSetOrCleared[i] = 0 ;                                                        // mark break point as cleared for future setting
00002D14  2002      5397          move.l    D2,D0
00002D16  E588      5398          lsl.l     #2,D0
00002D18  41F9 0B00 5399          lea       _WatchPointSetOrCleared.L,A0
00002D1C  01A2      
00002D1E  42B0 0800 5400          clr.l     0(A0,D0.L)
00002D22  5282      5401          addq.l    #1,D2
00002D24  60D8      5402          bra       KillAllWatchPoints_1
                    5403   KillAllWatchPoints_3:
00002D26  241F      5404          move.l    (A7)+,D2
00002D28  4E75      5405          rts
                    5406   ; }
                    5407   ; //WatchPointDisplay() ;       // display the break points
                    5408   ; }
                    5409   ; void SetBreakPoint(void)
                    5410   ; {
                    5411   _SetBreakPoint:
00002D2A  4E56 FFFC 5412          link      A6,#-4
00002D2E  48E7 3830 5413          movem.l   D2/D3/D4/A2/A3,-(A7)
00002D32  45F9 0000 5414          lea       _printf.L,A2
00002D36  3C28      
00002D38  47F9 0B00 5415          lea       _BreakPointSetOrCleared.L,A3
00002D3C  015E      
                    5416   ; int i ;
                    5417   ; int BPNumber;
                    5418   ; int BPAddress;
                    5419   ; volatile unsigned short int *ProgramBreakPointAddress ;
                    5420   ; // see if any free break points
                    5421   ; for(i = 0; i < 8; i ++) {
00002D3E  4282      5422          clr.l     D2
                    5423   SetBreakPoint_1:
00002D40  0C82 0000 5424          cmp.l     #8,D2
00002D44  0008      
00002D46  6C10      5425          bge.s     SetBreakPoint_3
                    5426   ; if( BreakPointSetOrCleared[i] == 0)
00002D48  2002      5427          move.l    D2,D0
00002D4A  E588      5428          lsl.l     #2,D0
00002D4C  2033 0800 5429          move.l    0(A3,D0.L),D0
00002D50  6602      5430          bne.s     SetBreakPoint_4
                    5431   ; break ;         // if spare BP found allow user to set it
00002D52  6004      5432          bra.s     SetBreakPoint_3
                    5433   SetBreakPoint_4:
00002D54  5282      5434          addq.l    #1,D2
00002D56  60E8      5435          bra       SetBreakPoint_1
                    5436   SetBreakPoint_3:
                    5437   ; }
                    5438   ; if(i == 8) {
00002D58  0C82 0000 5439          cmp.l     #8,D2
00002D5C  0008      
00002D5E  660E      5440          bne.s     SetBreakPoint_6
                    5441   ; printf("\r\nNo FREE Break Points.....") ;
00002D60  4879 0000 5442          pea       @m68kde~1_112.L
00002D64  5C8E      
00002D66  4E92      5443          jsr       (A2)
00002D68  584F      5444          addq.w    #4,A7
                    5445   ; return ;
00002D6A  6000 00D6 5446          bra       SetBreakPoint_15
                    5447   SetBreakPoint_6:
                    5448   ; }
                    5449   ; printf("\r\nBreak Point Address: ") ;
00002D6E  4879 0000 5450          pea       @m68kde~1_113.L
00002D72  5CAA      
00002D74  4E92      5451          jsr       (A2)
00002D76  584F      5452          addq.w    #4,A7
                    5453   ; BPAddress = Get8HexDigits(0) ;
00002D78  42A7      5454          clr.l     -(A7)
00002D7A  4EB8 0F06 5455          jsr       _Get8HexDigits
00002D7E  584F      5456          addq.w    #4,A7
00002D80  2600      5457          move.l    D0,D3
                    5458   ; ProgramBreakPointAddress = (volatile unsigned short int *)(BPAddress) ;     // point to the instruction in the user program we are about to change
00002D82  2803      5459          move.l    D3,D4
                    5460   ; if((BPAddress & 0x00000001) == 0x00000001)  {   // cannot set BP at an odd address
00002D84  2003      5461          move.l    D3,D0
00002D86  C0BC 0000 5462          and.l     #1,D0
00002D8A  0001      
00002D8C  0C80 0000 5463          cmp.l     #1,D0
00002D90  0001      
00002D92  660E      5464          bne.s     SetBreakPoint_9
                    5465   ; printf("\r\nError : Break Points CANNOT be set at ODD addresses") ;
00002D94  4879 0000 5466          pea       @m68kde~1_114.L
00002D98  5CC2      
00002D9A  4E92      5467          jsr       (A2)
00002D9C  584F      5468          addq.w    #4,A7
                    5469   ; return ;
00002D9E  6000 00A2 5470          bra       SetBreakPoint_15
                    5471   SetBreakPoint_9:
                    5472   ; }
                    5473   ; if(BPAddress < 0x00008000)  {   // cannot set BP in ROM
00002DA2  0C83 0000 5474          cmp.l     #32768,D3
00002DA6  8000      
00002DA8  640E      5475          bhs.s     SetBreakPoint_11
                    5476   ; printf("\r\nError : Break Points CANNOT be set for ROM in Range : [$0-$00007FFF]") ;
00002DAA  4879 0000 5477          pea       @m68kde~1_115.L
00002DAE  5CF8      
00002DB0  4E92      5478          jsr       (A2)
00002DB2  584F      5479          addq.w    #4,A7
                    5480   ; return ;
00002DB4  6000 008C 5481          bra       SetBreakPoint_15
                    5482   SetBreakPoint_11:
                    5483   ; }
                    5484   ; // search for first free bp or existing same BP
                    5485   ; for(i = 0; i < 8; i++)  {
00002DB8  4282      5486          clr.l     D2
                    5487   SetBreakPoint_13:
00002DBA  0C82 0000 5488          cmp.l     #8,D2
00002DBE  0008      
00002DC0  6C00 0080 5489          bge       SetBreakPoint_15
                    5490   ; if(BreakPointAddress[i] == BPAddress)   {
00002DC4  2002      5491          move.l    D2,D0
00002DC6  E588      5492          lsl.l     #2,D0
00002DC8  41F9 0B00 5493          lea       _BreakPointAddress.L,A0
00002DCC  012E      
00002DCE  B6B0 0800 5494          cmp.l     0(A0,D0.L),D3
00002DD2  6610      5495          bne.s     SetBreakPoint_16
                    5496   ; printf("\r\nError: Break Point Already Exists at Address : %08x\r\n", BPAddress) ;
00002DD4  2F03      5497          move.l    D3,-(A7)
00002DD6  4879 0000 5498          pea       @m68kde~1_116.L
00002DDA  5D40      
00002DDC  4E92      5499          jsr       (A2)
00002DDE  504F      5500          addq.w    #8,A7
                    5501   ; return ;
00002DE0  6000 0060 5502          bra       SetBreakPoint_15
                    5503   SetBreakPoint_16:
                    5504   ; }
                    5505   ; if(BreakPointSetOrCleared[i] == 0) {
00002DE4  2002      5506          move.l    D2,D0
00002DE6  E588      5507          lsl.l     #2,D0
00002DE8  2033 0800 5508          move.l    0(A3,D0.L),D0
00002DEC  6600 004E 5509          bne       SetBreakPoint_18
                    5510   ; // set BP here
                    5511   ; BreakPointSetOrCleared[i] = 1 ;                                 // mark this breakpoint as set
00002DF0  2002      5512          move.l    D2,D0
00002DF2  E588      5513          lsl.l     #2,D0
00002DF4  27BC 0000 5514          move.l    #1,0(A3,D0.L)
00002DF8  0001 0800 
                    5515   ; BreakPointInstruction[i] = *ProgramBreakPointAddress ;          // copy the user program instruction here so we can put it back afterwards
00002DFC  2044      5516          move.l    D4,A0
00002DFE  2002      5517          move.l    D2,D0
00002E00  E388      5518          lsl.l     #1,D0
00002E02  43F9 0B00 5519          lea       _BreakPointInstruction.L,A1
00002E06  014E      
00002E08  3390 0800 5520          move.w    (A0),0(A1,D0.L)
                    5521   ; printf("\r\nBreak Point Set at Address: [$%08x]", ProgramBreakPointAddress) ;
00002E0C  2F04      5522          move.l    D4,-(A7)
00002E0E  4879 0000 5523          pea       @m68kde~1_117.L
00002E12  5D78      
00002E14  4E92      5524          jsr       (A2)
00002E16  504F      5525          addq.w    #8,A7
                    5526   ; *ProgramBreakPointAddress = (unsigned short int)(0x4e4e)    ;   // put a Trap14 instruction at the user specified address
00002E18  2044      5527          move.l    D4,A0
00002E1A  30BC 4E4E 5528          move.w    #20046,(A0)
                    5529   ; BreakPointAddress[i] = BPAddress ;                              // record the address of this break point in the debugger
00002E1E  2002      5530          move.l    D2,D0
00002E20  E588      5531          lsl.l     #2,D0
00002E22  41F9 0B00 5532          lea       _BreakPointAddress.L,A0
00002E26  012E      
00002E28  2183 0800 5533          move.l    D3,0(A0,D0.L)
                    5534   ; printf("\r\n") ;
00002E2C  4879 0000 5535          pea       @m68kde~1_1.L
00002E30  50C8      
00002E32  4E92      5536          jsr       (A2)
00002E34  584F      5537          addq.w    #4,A7
                    5538   ; BreakPointDisplay() ;       // display the break points
00002E36  4EB8 28FA 5539          jsr       _BreakPointDisplay
                    5540   ; return ;
00002E3A  6006      5541          bra.s     SetBreakPoint_15
                    5542   SetBreakPoint_18:
00002E3C  5282      5543          addq.l    #1,D2
00002E3E  6000 FF7A 5544          bra       SetBreakPoint_13
                    5545   SetBreakPoint_15:
00002E42  4CDF 0C1C 5546          movem.l   (A7)+,D2/D3/D4/A2/A3
00002E46  4E5E      5547          unlk      A6
00002E48  4E75      5548          rts
                    5549   ; }
                    5550   ; }
                    5551   ; }
                    5552   ; void SetWatchPoint(void)
                    5553   ; {
                    5554   _SetWatchPoint:
00002E4A  4E56 FFF8 5555          link      A6,#-8
00002E4E  48E7 3030 5556          movem.l   D2/D3/A2/A3,-(A7)
00002E52  45F9 0000 5557          lea       _printf.L,A2
00002E56  3C28      
00002E58  47F9 0B00 5558          lea       _WatchPointSetOrCleared.L,A3
00002E5C  01A2      
                    5559   ; int i ;
                    5560   ; int WPNumber;
                    5561   ; int WPAddress;
                    5562   ; volatile unsigned short int *ProgramWatchPointAddress ;
                    5563   ; // see if any free break points
                    5564   ; for(i = 0; i < 8; i ++) {
00002E5E  4282      5565          clr.l     D2
                    5566   SetWatchPoint_1:
00002E60  0C82 0000 5567          cmp.l     #8,D2
00002E64  0008      
00002E66  6C10      5568          bge.s     SetWatchPoint_3
                    5569   ; if( WatchPointSetOrCleared[i] == 0)
00002E68  2002      5570          move.l    D2,D0
00002E6A  E588      5571          lsl.l     #2,D0
00002E6C  2033 0800 5572          move.l    0(A3,D0.L),D0
00002E70  6602      5573          bne.s     SetWatchPoint_4
                    5574   ; break ;         // if spare WP found allow user to set it
00002E72  6004      5575          bra.s     SetWatchPoint_3
                    5576   SetWatchPoint_4:
00002E74  5282      5577          addq.l    #1,D2
00002E76  60E8      5578          bra       SetWatchPoint_1
                    5579   SetWatchPoint_3:
                    5580   ; }
                    5581   ; if(i == 8) {
00002E78  0C82 0000 5582          cmp.l     #8,D2
00002E7C  0008      
00002E7E  660E      5583          bne.s     SetWatchPoint_6
                    5584   ; printf("\r\nNo FREE Watch Points.....") ;
00002E80  4879 0000 5585          pea       @m68kde~1_118.L
00002E84  5D9E      
00002E86  4E92      5586          jsr       (A2)
00002E88  584F      5587          addq.w    #4,A7
                    5588   ; return ;
00002E8A  6000 008C 5589          bra       SetWatchPoint_11
                    5590   SetWatchPoint_6:
                    5591   ; }
                    5592   ; printf("\r\nWatch Point Address: ") ;
00002E8E  4879 0000 5593          pea       @m68kde~1_119.L
00002E92  5DBA      
00002E94  4E92      5594          jsr       (A2)
00002E96  584F      5595          addq.w    #4,A7
                    5596   ; WPAddress = Get8HexDigits(0) ;
00002E98  42A7      5597          clr.l     -(A7)
00002E9A  4EB8 0F06 5598          jsr       _Get8HexDigits
00002E9E  584F      5599          addq.w    #4,A7
00002EA0  2600      5600          move.l    D0,D3
                    5601   ; // search for first free wp or existing same wp
                    5602   ; for(i = 0; i < 8; i++)  {
00002EA2  4282      5603          clr.l     D2
                    5604   SetWatchPoint_9:
00002EA4  0C82 0000 5605          cmp.l     #8,D2
00002EA8  0008      
00002EAA  6C00 006C 5606          bge       SetWatchPoint_11
                    5607   ; if(WatchPointAddress[i] == WPAddress && WPAddress != 0)   {     //so we can set a wp at 0
00002EAE  2002      5608          move.l    D2,D0
00002EB0  E588      5609          lsl.l     #2,D0
00002EB2  41F9 0B00 5610          lea       _WatchPointAddress.L,A0
00002EB6  0182      
00002EB8  B6B0 0800 5611          cmp.l     0(A0,D0.L),D3
00002EBC  6614      5612          bne.s     SetWatchPoint_12
00002EBE  4A83      5613          tst.l     D3
00002EC0  6710      5614          beq.s     SetWatchPoint_12
                    5615   ; printf("\r\nError: Watch Point Already Set at Address : %08x\r\n", WPAddress) ;
00002EC2  2F03      5616          move.l    D3,-(A7)
00002EC4  4879 0000 5617          pea       @m68kde~1_120.L
00002EC8  5DD2      
00002ECA  4E92      5618          jsr       (A2)
00002ECC  504F      5619          addq.w    #8,A7
                    5620   ; return ;
00002ECE  6000 0048 5621          bra       SetWatchPoint_11
                    5622   SetWatchPoint_12:
                    5623   ; }
                    5624   ; if(WatchPointSetOrCleared[i] == 0) {
00002ED2  2002      5625          move.l    D2,D0
00002ED4  E588      5626          lsl.l     #2,D0
00002ED6  2033 0800 5627          move.l    0(A3,D0.L),D0
00002EDA  6600 0038 5628          bne       SetWatchPoint_14
                    5629   ; WatchPointSetOrCleared[i] = 1 ;                                 // mark this watchpoint as set
00002EDE  2002      5630          move.l    D2,D0
00002EE0  E588      5631          lsl.l     #2,D0
00002EE2  27BC 0000 5632          move.l    #1,0(A3,D0.L)
00002EE6  0001 0800 
                    5633   ; printf("\r\nWatch Point Set at Address: [$%08x]", WPAddress) ;
00002EEA  2F03      5634          move.l    D3,-(A7)
00002EEC  4879 0000 5635          pea       @m68kde~1_121.L
00002EF0  5E08      
00002EF2  4E92      5636          jsr       (A2)
00002EF4  504F      5637          addq.w    #8,A7
                    5638   ; WatchPointAddress[i] = WPAddress ;                              // record the address of this watch point in the debugger
00002EF6  2002      5639          move.l    D2,D0
00002EF8  E588      5640          lsl.l     #2,D0
00002EFA  41F9 0B00 5641          lea       _WatchPointAddress.L,A0
00002EFE  0182      
00002F00  2183 0800 5642          move.l    D3,0(A0,D0.L)
                    5643   ; printf("\r\n") ;
00002F04  4879 0000 5644          pea       @m68kde~1_1.L
00002F08  50C8      
00002F0A  4E92      5645          jsr       (A2)
00002F0C  584F      5646          addq.w    #4,A7
                    5647   ; WatchPointDisplay() ;       // display the break points
00002F0E  4EB8 29CE 5648          jsr       _WatchPointDisplay
                    5649   ; return ;
00002F12  6004      5650          bra.s     SetWatchPoint_11
                    5651   SetWatchPoint_14:
00002F14  5282      5652          addq.l    #1,D2
00002F16  608C      5653          bra       SetWatchPoint_9
                    5654   SetWatchPoint_11:
00002F18  4CDF 0C0C 5655          movem.l   (A7)+,D2/D3/A2/A3
00002F1C  4E5E      5656          unlk      A6
00002F1E  4E75      5657          rts
                    5658   ; }
                    5659   ; }
                    5660   ; }
                    5661   ; void HandleBreakPoint(void)
                    5662   ; {
                    5663   _HandleBreakPoint:
00002F20  4E56 FFFC 5664          link      A6,#-4
00002F24  48E7 0038 5665          movem.l   A2/A3/A4,-(A7)
00002F28  45F9 0B00 5666          lea       _i.L,A2
00002F2C  00C4      
00002F2E  47F9 0000 5667          lea       _printf.L,A3
00002F32  3C28      
00002F34  49F9 0B00 5668          lea       _PC.L,A4
00002F38  0120      
                    5669   ; volatile unsigned short int *ProgramBreakPointAddress ;
                    5670   ; // now we have to put the break point back to run the instruction
                    5671   ; // PC will contain the address of the TRAP instruction but advanced by two bytes so lets play with that
                    5672   ; PC = PC - 2 ;  // ready for user to resume after reaching breakpoint
00002F3A  5594      5673          subq.l    #2,(A4)
                    5674   ; printf("\r\n\r\n\r\n\r\n@BREAKPOINT") ;
00002F3C  4879 0000 5675          pea       @m68kde~1_122.L
00002F40  5E2E      
00002F42  4E93      5676          jsr       (A3)
00002F44  584F      5677          addq.w    #4,A7
                    5678   ; printf("\r\nSingle Step : [ON]") ;
00002F46  4879 0000 5679          pea       @m68kde~1_123.L
00002F4A  5E42      
00002F4C  4E93      5680          jsr       (A3)
00002F4E  584F      5681          addq.w    #4,A7
                    5682   ; printf("\r\nBreakPoints : [Enabled]") ;
00002F50  4879 0000 5683          pea       @m68kde~1_124.L
00002F54  5E58      
00002F56  4E93      5684          jsr       (A3)
00002F58  584F      5685          addq.w    #4,A7
                    5686   ; // now clear the break point (put original instruction back)
                    5687   ; ProgramBreakPointAddress = PC ;
00002F5A  2D54 FFFC 5688          move.l    (A4),-4(A6)
                    5689   ; for(i = 0; i < 8; i ++) {
00002F5E  4292      5690          clr.l     (A2)
                    5691   HandleBreakPoint_1:
00002F60  2012      5692          move.l    (A2),D0
00002F62  0C80 0000 5693          cmp.l     #8,D0
00002F66  0008      
00002F68  6400 0056 5694          bhs       HandleBreakPoint_3
                    5695   ; if(BreakPointAddress[i] == PC) {        // if we have found the breakpoint
00002F6C  2012      5696          move.l    (A2),D0
00002F6E  E588      5697          lsl.l     #2,D0
00002F70  41F9 0B00 5698          lea       _BreakPointAddress.L,A0
00002F74  012E      
00002F76  2230 0800 5699          move.l    0(A0,D0.L),D1
00002F7A  B294      5700          cmp.l     (A4),D1
00002F7C  6600 003E 5701          bne       HandleBreakPoint_4
                    5702   ; BreakPointAddress[i] = 0 ;
00002F80  2012      5703          move.l    (A2),D0
00002F82  E588      5704          lsl.l     #2,D0
00002F84  41F9 0B00 5705          lea       _BreakPointAddress.L,A0
00002F88  012E      
00002F8A  42B0 0800 5706          clr.l     0(A0,D0.L)
                    5707   ; BreakPointSetOrCleared[i] = 0 ;
00002F8E  2012      5708          move.l    (A2),D0
00002F90  E588      5709          lsl.l     #2,D0
00002F92  41F9 0B00 5710          lea       _BreakPointSetOrCleared.L,A0
00002F96  015E      
00002F98  42B0 0800 5711          clr.l     0(A0,D0.L)
                    5712   ; *ProgramBreakPointAddress = BreakPointInstruction[i] ;  // put original instruction back
00002F9C  2012      5713          move.l    (A2),D0
00002F9E  E388      5714          lsl.l     #1,D0
00002FA0  41F9 0B00 5715          lea       _BreakPointInstruction.L,A0
00002FA4  014E      
00002FA6  226E FFFC 5716          move.l    -4(A6),A1
00002FAA  32B0 0800 5717          move.w    0(A0,D0.L),(A1)
                    5718   ; BreakPointInstruction[i] = 0 ;
00002FAE  2012      5719          move.l    (A2),D0
00002FB0  E388      5720          lsl.l     #1,D0
00002FB2  41F9 0B00 5721          lea       _BreakPointInstruction.L,A0
00002FB6  014E      
00002FB8  4270 0800 5722          clr.w     0(A0,D0.L)
                    5723   HandleBreakPoint_4:
00002FBC  5292      5724          addq.l    #1,(A2)
00002FBE  60A0      5725          bra       HandleBreakPoint_1
                    5726   HandleBreakPoint_3:
                    5727   ; }
                    5728   ; }
                    5729   ; DumpRegisters() ;
00002FC0  4EB8 214C 5730          jsr       _DumpRegisters
                    5731   ; printf("\r\nPress <SPACE> to Execute Next Instruction");
00002FC4  4879 0000 5732          pea       @m68kde~1_86.L
00002FC8  59D4      
00002FCA  4E93      5733          jsr       (A3)
00002FCC  584F      5734          addq.w    #4,A7
                    5735   ; printf("\r\nPress <ESC> to Resume User Program\r\n") ;
00002FCE  4879 0000 5736          pea       @m68kde~1_125.L
00002FD2  5E72      
00002FD4  4E93      5737          jsr       (A3)
00002FD6  584F      5738          addq.w    #4,A7
                    5739   ; menu() ;
00002FD8  4EB9 0000 5740          jsr       _menu
00002FDC  31E4      
00002FDE  4CDF 1C00 5741          movem.l   (A7)+,A2/A3/A4
00002FE2  4E5E      5742          unlk      A6
00002FE4  4E75      5743          rts
                    5744   ; }
                    5745   ; void UnknownCommand()
                    5746   ; {
                    5747   _UnknownCommand:
                    5748   ; printf("\r\nUnknown Command.....\r\n") ;
00002FE6  4879 0000 5749          pea       @m68kde~1_126.L
00002FEA  5E9A      
00002FEC  4EB9 0000 5750          jsr       _printf
00002FF0  3C28      
00002FF2  584F      5751          addq.w    #4,A7
                    5752   ; Help() ;
00002FF4  4EB9 0000 5753          jsr       _Help
00002FF8  310A      
00002FFA  4E75      5754          rts
                    5755   ; }
                    5756   ; // system when the users program executes a TRAP #15 instruction to halt program and return to debug monitor
                    5757   ; void CallDebugMonitor(void)
                    5758   ; {
                    5759   _CallDebugMonitor:
                    5760   ; printf("\r\nProgram Ended (TRAP #15)....") ;
00002FFC  4879 0000 5761          pea       @m68kde~1_127.L
00003000  5EB4      
00003002  4EB9 0000 5762          jsr       _printf
00003006  3C28      
00003008  584F      5763          addq.w    #4,A7
                    5764   ; menu();
0000300A  4EB9 0000 5765          jsr       _menu
0000300E  31E4      
00003010  4E75      5766          rts
                    5767   ; }
                    5768   ; void Breakpoint(void)
                    5769   ; {
                    5770   _Breakpoint:
00003012  2F02      5771          move.l    D2,-(A7)
                    5772   ; char c;
                    5773   ; c = toupper(_getch());
00003014  2F00      5774          move.l    D0,-(A7)
00003016  4EB8 0DCA 5775          jsr       __getch
0000301A  2200      5776          move.l    D0,D1
0000301C  201F      5777          move.l    (A7)+,D0
0000301E  2F01      5778          move.l    D1,-(A7)
00003020  4EB9 0000 5779          jsr       _toupper
00003024  3E42      
00003026  584F      5780          addq.w    #4,A7
00003028  1400      5781          move.b    D0,D2
                    5782   ; if( c == (char)('D'))                                      // BreakPoint Display
0000302A  0C02 0044 5783          cmp.b     #68,D2
0000302E  6608      5784          bne.s     Breakpoint_1
                    5785   ; BreakPointDisplay() ;
00003030  4EB8 28FA 5786          jsr       _BreakPointDisplay
00003034  6000 0054 5787          bra       Breakpoint_10
                    5788   Breakpoint_1:
                    5789   ; else if(c == (char)('K')) {                                 // breakpoint Kill
00003038  0C02 004B 5790          cmp.b     #75,D2
0000303C  6630      5791          bne.s     Breakpoint_3
                    5792   ; printf("\r\nKill All Break Points...(y/n)?") ;
0000303E  4879 0000 5793          pea       @m68kde~1_128.L
00003042  5ED4      
00003044  4EB9 0000 5794          jsr       _printf
00003048  3C28      
0000304A  584F      5795          addq.w    #4,A7
                    5796   ; c = toupper(_getch());
0000304C  2F00      5797          move.l    D0,-(A7)
0000304E  4EB8 0DCA 5798          jsr       __getch
00003052  2200      5799          move.l    D0,D1
00003054  201F      5800          move.l    (A7)+,D0
00003056  2F01      5801          move.l    D1,-(A7)
00003058  4EB9 0000 5802          jsr       _toupper
0000305C  3E42      
0000305E  584F      5803          addq.w    #4,A7
00003060  1400      5804          move.b    D0,D2
                    5805   ; if(c == (char)('Y'))
00003062  0C02 0059 5806          cmp.b     #89,D2
00003066  6604      5807          bne.s     Breakpoint_5
                    5808   ; KillAllBreakPoints() ;
00003068  4EB8 2C92 5809          jsr       _KillAllBreakPoints
                    5810   Breakpoint_5:
0000306C  601C      5811          bra.s     Breakpoint_10
                    5812   Breakpoint_3:
                    5813   ; }
                    5814   ; else if(c == (char)('S')) {
0000306E  0C02 0053 5815          cmp.b     #83,D2
00003072  6606      5816          bne.s     Breakpoint_7
                    5817   ; SetBreakPoint() ;
00003074  4EB8 2D2A 5818          jsr       _SetBreakPoint
00003078  6010      5819          bra.s     Breakpoint_10
                    5820   Breakpoint_7:
                    5821   ; }
                    5822   ; else if(c == (char)('C')) {
0000307A  0C02 0043 5823          cmp.b     #67,D2
0000307E  6606      5824          bne.s     Breakpoint_9
                    5825   ; BreakPointClear() ;
00003080  4EB8 2A7A 5826          jsr       _BreakPointClear
00003084  6004      5827          bra.s     Breakpoint_10
                    5828   Breakpoint_9:
                    5829   ; }
                    5830   ; else
                    5831   ; UnknownCommand() ;
00003086  4EB8 2FE6 5832          jsr       _UnknownCommand
                    5833   Breakpoint_10:
0000308A  241F      5834          move.l    (A7)+,D2
0000308C  4E75      5835          rts
                    5836   ; }
                    5837   ; void Watchpoint(void)
                    5838   ; {
                    5839   _Watchpoint:
0000308E  2F02      5840          move.l    D2,-(A7)
                    5841   ; char c;
                    5842   ; c = toupper(_getch());
00003090  2F00      5843          move.l    D0,-(A7)
00003092  4EB8 0DCA 5844          jsr       __getch
00003096  2200      5845          move.l    D0,D1
00003098  201F      5846          move.l    (A7)+,D0
0000309A  2F01      5847          move.l    D1,-(A7)
0000309C  4EB9 0000 5848          jsr       _toupper
000030A0  3E42      
000030A2  584F      5849          addq.w    #4,A7
000030A4  1400      5850          move.b    D0,D2
                    5851   ; if( c == (char)('D'))                                      // WatchPoint Display
000030A6  0C02 0044 5852          cmp.b     #68,D2
000030AA  6608      5853          bne.s     Watchpoint_1
                    5854   ; WatchPointDisplay() ;
000030AC  4EB8 29CE 5855          jsr       _WatchPointDisplay
000030B0  6000 0054 5856          bra       Watchpoint_10
                    5857   Watchpoint_1:
                    5858   ; else if(c == (char)('K')) {                                 // wtahcpoint Kill
000030B4  0C02 004B 5859          cmp.b     #75,D2
000030B8  6630      5860          bne.s     Watchpoint_3
                    5861   ; printf("\r\nKill All Watch Points...(y/n)?") ;
000030BA  4879 0000 5862          pea       @m68kde~1_129.L
000030BE  5EF6      
000030C0  4EB9 0000 5863          jsr       _printf
000030C4  3C28      
000030C6  584F      5864          addq.w    #4,A7
                    5865   ; c = toupper(_getch());
000030C8  2F00      5866          move.l    D0,-(A7)
000030CA  4EB8 0DCA 5867          jsr       __getch
000030CE  2200      5868          move.l    D0,D1
000030D0  201F      5869          move.l    (A7)+,D0
000030D2  2F01      5870          move.l    D1,-(A7)
000030D4  4EB9 0000 5871          jsr       _toupper
000030D8  3E42      
000030DA  584F      5872          addq.w    #4,A7
000030DC  1400      5873          move.b    D0,D2
                    5874   ; if(c == (char)('Y'))
000030DE  0C02 0059 5875          cmp.b     #89,D2
000030E2  6604      5876          bne.s     Watchpoint_5
                    5877   ; KillAllWatchPoints() ;
000030E4  4EB8 2CFA 5878          jsr       _KillAllWatchPoints
                    5879   Watchpoint_5:
000030E8  601C      5880          bra.s     Watchpoint_10
                    5881   Watchpoint_3:
                    5882   ; }
                    5883   ; else if(c == (char)('S')) {
000030EA  0C02 0053 5884          cmp.b     #83,D2
000030EE  6606      5885          bne.s     Watchpoint_7
                    5886   ; SetWatchPoint() ;
000030F0  4EB8 2E4A 5887          jsr       _SetWatchPoint
000030F4  6010      5888          bra.s     Watchpoint_10
                    5889   Watchpoint_7:
                    5890   ; }
                    5891   ; else if(c == (char)('C')) {
000030F6  0C02 0043 5892          cmp.b     #67,D2
000030FA  6606      5893          bne.s     Watchpoint_9
                    5894   ; WatchPointClear() ;
000030FC  4EB8 2B54 5895          jsr       _WatchPointClear
00003100  6004      5896          bra.s     Watchpoint_10
                    5897   Watchpoint_9:
                    5898   ; }
                    5899   ; else
                    5900   ; UnknownCommand() ;
00003102  4EB8 2FE6 5901          jsr       _UnknownCommand
                    5902   Watchpoint_10:
00003106  241F      5903          move.l    (A7)+,D2
00003108  4E75      5904          rts
                    5905   ; }
                    5906   ; void Help(void)
                    5907   ; {
                    5908   _Help:
0000310A  48E7 2020 5909          movem.l   D2/A2,-(A7)
0000310E  45F9 0000 5910          lea       _printf.L,A2
00003112  3C28      
                    5911   ; char *banner = "\r\n----------------------------------------------------------------" ;
00003114  41F9 0000 5912          lea       @m68kde~1_130.L,A0
00003118  5F18      
0000311A  2408      5913          move.l    A0,D2
                    5914   ; printf(banner) ;
0000311C  2F02      5915          move.l    D2,-(A7)
0000311E  4E92      5916          jsr       (A2)
00003120  584F      5917          addq.w    #4,A7
                    5918   ; printf("\r\n  Debugger Command Summary") ;
00003122  4879 0000 5919          pea       @m68kde~1_131.L
00003126  5F5C      
00003128  4E92      5920          jsr       (A2)
0000312A  584F      5921          addq.w    #4,A7
                    5922   ; printf(banner) ;
0000312C  2F02      5923          move.l    D2,-(A7)
0000312E  4E92      5924          jsr       (A2)
00003130  584F      5925          addq.w    #4,A7
                    5926   ; printf("\r\n  .(reg)       - Change Registers: e.g A0-A7,D0-D7,PC,SSP,USP,SR");
00003132  4879 0000 5927          pea       @m68kde~1_132.L
00003136  5F7A      
00003138  4E92      5928          jsr       (A2)
0000313A  584F      5929          addq.w    #4,A7
                    5930   ; printf("\r\n  BD/BS/BC/BK  - Break Point: Display/Set/Clear/Kill") ;
0000313C  4879 0000 5931          pea       @m68kde~1_133.L
00003140  5FBE      
00003142  4E92      5932          jsr       (A2)
00003144  584F      5933          addq.w    #4,A7
                    5934   ; printf("\r\n  C            - Copy Program from Flash to Main Memory") ;
00003146  4879 0000 5935          pea       @m68kde~1_134.L
0000314A  5FF6      
0000314C  4E92      5936          jsr       (A2)
0000314E  584F      5937          addq.w    #4,A7
                    5938   ; printf("\r\n  D            - Dump Memory Contents to Screen") ;
00003150  4879 0000 5939          pea       @m68kde~1_135.L
00003154  6030      
00003156  4E92      5940          jsr       (A2)
00003158  584F      5941          addq.w    #4,A7
                    5942   ; printf("\r\n  E            - Enter String into Memory") ;
0000315A  4879 0000 5943          pea       @m68kde~1_136.L
0000315E  6062      
00003160  4E92      5944          jsr       (A2)
00003162  584F      5945          addq.w    #4,A7
                    5946   ; printf("\r\n  F            - Fill Memory with Data") ;
00003164  4879 0000 5947          pea       @m68kde~1_137.L
00003168  608E      
0000316A  4E92      5948          jsr       (A2)
0000316C  584F      5949          addq.w    #4,A7
                    5950   ; printf("\r\n  G            - Go Program Starting at Address: $%08X", PC) ;
0000316E  2F39 0B00 5951          move.l    _PC.L,-(A7)
00003172  0120      
00003174  4879 0000 5952          pea       @m68kde~1_138.L
00003178  60B8      
0000317A  4E92      5953          jsr       (A2)
0000317C  504F      5954          addq.w    #8,A7
                    5955   ; printf("\r\n  L            - Load Program (.HEX file) from Laptop") ;
0000317E  4879 0000 5956          pea       @m68kde~1_139.L
00003182  60F2      
00003184  4E92      5957          jsr       (A2)
00003186  584F      5958          addq.w    #4,A7
                    5959   ; printf("\r\n  M            - Memory Examine and Change");
00003188  4879 0000 5960          pea       @m68kde~1_140.L
0000318C  612A      
0000318E  4E92      5961          jsr       (A2)
00003190  584F      5962          addq.w    #4,A7
                    5963   ; printf("\r\n  P            - Program Flash Memory with User Program") ;
00003192  4879 0000 5964          pea       @m68kde~1_141.L
00003196  6158      
00003198  4E92      5965          jsr       (A2)
0000319A  584F      5966          addq.w    #4,A7
                    5967   ; printf("\r\n  R            - Display 68000 Registers") ;
0000319C  4879 0000 5968          pea       @m68kde~1_142.L
000031A0  6192      
000031A2  4E92      5969          jsr       (A2)
000031A4  584F      5970          addq.w    #4,A7
                    5971   ; printf("\r\n  S            - Toggle ON/OFF Single Step Mode") ;
000031A6  4879 0000 5972          pea       @m68kde~1_143.L
000031AA  61BE      
000031AC  4E92      5973          jsr       (A2)
000031AE  584F      5974          addq.w    #4,A7
                    5975   ; printf("\r\n  TM           - Test Memory") ;
000031B0  4879 0000 5976          pea       @m68kde~1_144.L
000031B4  61F0      
000031B6  4E92      5977          jsr       (A2)
000031B8  584F      5978          addq.w    #4,A7
                    5979   ; printf("\r\n  TS           - Test Switches: SW7-0") ;
000031BA  4879 0000 5980          pea       @m68kde~1_145.L
000031BE  6210      
000031C0  4E92      5981          jsr       (A2)
000031C2  584F      5982          addq.w    #4,A7
                    5983   ; printf("\r\n  TD           - Test Displays: LEDs and 7-Segment") ;
000031C4  4879 0000 5984          pea       @m68kde~1_146.L
000031C8  6238      
000031CA  4E92      5985          jsr       (A2)
000031CC  584F      5986          addq.w    #4,A7
                    5987   ; printf("\r\n  WD/WS/WC/WK  - Watch Point: Display/Set/Clear/Kill") ;
000031CE  4879 0000 5988          pea       @m68kde~1_147.L
000031D2  626E      
000031D4  4E92      5989          jsr       (A2)
000031D6  584F      5990          addq.w    #4,A7
                    5991   ; printf(banner) ;
000031D8  2F02      5992          move.l    D2,-(A7)
000031DA  4E92      5993          jsr       (A2)
000031DC  584F      5994          addq.w    #4,A7
000031DE  4CDF 0404 5995          movem.l   (A7)+,D2/A2
000031E2  4E75      5996          rts
                    5997   ; }
                    5998   ; void menu(void)
                    5999   ; {
                    6000   _menu:
000031E4  48E7 303C 6001          movem.l   D2/D3/A2/A3/A4/A5,-(A7)
000031E8  45F9 0000 6002          lea       _printf.L,A2
000031EC  3C28      
000031EE  47F9 0B00 6003          lea       _Trace.L,A3
000031F2  00D8      
000031F4  49F9 0B00 6004          lea       _x.L,A4
000031F8  00C8      
000031FA  4BF9 0B00 6005          lea       _SR.L,A5
000031FE  012C      
                    6006   ; char c,c1 ;
                    6007   ; while(1)    {
                    6008   menu_1:
                    6009   ; FlushKeyboard() ;               // dump unread characters from keyboard
00003200  4EB8 0E08 6010          jsr       _FlushKeyboard
                    6011   ; printf("\r\n#") ;
00003204  4879 0000 6012          pea       @m68kde~1_148.L
00003208  62A6      
0000320A  4E92      6013          jsr       (A2)
0000320C  584F      6014          addq.w    #4,A7
                    6015   ; c = toupper(_getch());
0000320E  2F00      6016          move.l    D0,-(A7)
00003210  4EB8 0DCA 6017          jsr       __getch
00003214  2200      6018          move.l    D0,D1
00003216  201F      6019          move.l    (A7)+,D0
00003218  2F01      6020          move.l    D1,-(A7)
0000321A  4EB9 0000 6021          jsr       _toupper
0000321E  3E42      
00003220  584F      6022          addq.w    #4,A7
00003222  1400      6023          move.b    D0,D2
                    6024   ; if( c == (char)('L'))                  // load s record file
00003224  0C02 004C 6025          cmp.b     #76,D2
00003228  6608      6026          bne.s     menu_4
                    6027   ; Load_SRecordFile() ;
0000322A  4EB8 1098 6028          jsr       _Load_SRecordFile
0000322E  6000 023A 6029          bra       menu_50
                    6030   menu_4:
                    6031   ; else if( c == (char)('D'))             // dump memory
00003232  0C02 0044 6032          cmp.b     #68,D2
00003236  6608      6033          bne.s     menu_6
                    6034   ; DumpMemory() ;
00003238  4EB8 0F2E 6035          jsr       _DumpMemory
0000323C  6000 022C 6036          bra       menu_50
                    6037   menu_6:
                    6038   ; else if( c == (char)('E'))             // Enter String into memory
00003240  0C02 0045 6039          cmp.b     #69,D2
00003244  660A      6040          bne.s     menu_8
                    6041   ; EnterString() ;
00003246  4EB9 0000 6042          jsr       _EnterString
0000324A  35B2      
0000324C  6000 021C 6043          bra       menu_50
                    6044   menu_8:
                    6045   ; else if( c == (char)('F'))             // fill memory
00003250  0C02 0046 6046          cmp.b     #70,D2
00003254  6608      6047          bne.s     menu_10
                    6048   ; FillMemory() ;
00003256  4EB8 101E 6049          jsr       _FillMemory
0000325A  6000 020E 6050          bra       menu_50
                    6051   menu_10:
                    6052   ; else if( c == (char)('G'))  {           // go user program
0000325E  0C02 0047 6053          cmp.b     #71,D2
00003262  6626      6054          bne.s     menu_12
                    6055   ; printf("\r\nProgram Running.....") ;
00003264  4879 0000 6056          pea       @m68kde~1_149.L
00003268  62AA      
0000326A  4E92      6057          jsr       (A2)
0000326C  584F      6058          addq.w    #4,A7
                    6059   ; printf("\r\nPress <RESET> button <Key0> on DE1 to stop") ;
0000326E  4879 0000 6060          pea       @m68kde~1_150.L
00003272  62C2      
00003274  4E92      6061          jsr       (A2)
00003276  584F      6062          addq.w    #4,A7
                    6063   ; GoFlag = 1 ;
00003278  23FC 0000 6064          move.l    #1,_GoFlag.L
0000327C  0001 0B00 
00003280  00DC      
                    6065   ; go() ;
00003282  4EB8 08B8 6066          jsr       _go
00003286  6000 01E2 6067          bra       menu_50
                    6068   menu_12:
                    6069   ; }
                    6070   ; else if( c == (char)('M'))           // memory examine and modify
0000328A  0C02 004D 6071          cmp.b     #77,D2
0000328E  6608      6072          bne.s     menu_14
                    6073   ; MemoryChange() ;
00003290  4EB8 1226 6074          jsr       _MemoryChange
00003294  6000 01D4 6075          bra       menu_50
                    6076   menu_14:
                    6077   ; else if( c == (char)('I'))           //I2Ctest()
00003298  0C02 0049 6078          cmp.b     #73,D2
0000329C  6608      6079          bne.s     menu_16
                    6080   ; I2CTest(); 
0000329E  4EB8 1CB8 6081          jsr       _I2CTest
000032A2  6000 01C6 6082          bra       menu_50
                    6083   menu_16:
                    6084   ; else if( c == (char)('W'))           // DAC test
000032A6  0C02 0057 6085          cmp.b     #87,D2
000032AA  6608      6086          bne.s     menu_18
                    6087   ; DACWave();
000032AC  4EB8 209C 6088          jsr       _DACWave
000032B0  6000 01B8 6089          bra       menu_50
                    6090   menu_18:
                    6091   ; else if( c == (char)('P'))            // Program Flash Chip
000032B4  0C02 0050 6092          cmp.b     #80,D2
000032B8  6608      6093          bne.s     menu_20
                    6094   ; ProgramFlashChip() ;
000032BA  4EB8 15CA 6095          jsr       _ProgramFlashChip
000032BE  6000 01AA 6096          bra       menu_50
                    6097   menu_20:
                    6098   ; else if( c == (char)('C'))             // copy flash chip to ram and go
000032C2  0C02 0043 6099          cmp.b     #67,D2
000032C6  6608      6100          bne.s     menu_22
                    6101   ; LoadFromFlashChip();
000032C8  4EB8 15EC 6102          jsr       _LoadFromFlashChip
000032CC  6000 019C 6103          bra       menu_50
                    6104   menu_22:
                    6105   ; else if( c == (char)('R'))             // dump registers
000032D0  0C02 0052 6106          cmp.b     #82,D2
000032D4  6608      6107          bne.s     menu_24
                    6108   ; DumpRegisters() ;
000032D6  4EB8 214C 6109          jsr       _DumpRegisters
000032DA  6000 018E 6110          bra       menu_50
                    6111   menu_24:
                    6112   ; else if( c == (char)('.'))           // change registers
000032DE  0C02 002E 6113          cmp.b     #46,D2
000032E2  6608      6114          bne.s     menu_26
                    6115   ; ChangeRegisters() ;
000032E4  4EB8 263E 6116          jsr       _ChangeRegisters
000032E8  6000 0180 6117          bra       menu_50
                    6118   menu_26:
                    6119   ; else if( c == (char)('B'))              // breakpoint command
000032EC  0C02 0042 6120          cmp.b     #66,D2
000032F0  6608      6121          bne.s     menu_28
                    6122   ; Breakpoint() ;
000032F2  4EB8 3012 6123          jsr       _Breakpoint
000032F6  6000 0172 6124          bra       menu_50
                    6125   menu_28:
                    6126   ; else if( c == (char)('T'))  {          // Test command
000032FA  0C02 0054 6127          cmp.b     #84,D2
000032FE  6600 0046 6128          bne       menu_30
                    6129   ; c1 = toupper(_getch()) ;
00003302  2F00      6130          move.l    D0,-(A7)
00003304  4EB8 0DCA 6131          jsr       __getch
00003308  2200      6132          move.l    D0,D1
0000330A  201F      6133          move.l    (A7)+,D0
0000330C  2F01      6134          move.l    D1,-(A7)
0000330E  4EB9 0000 6135          jsr       _toupper
00003312  3E42      
00003314  584F      6136          addq.w    #4,A7
00003316  1600      6137          move.b    D0,D3
                    6138   ; if(c1 == (char)('M'))                    // memory test
00003318  0C03 004D 6139          cmp.b     #77,D3
0000331C  6608      6140          bne.s     menu_32
                    6141   ; MemoryTest() ;
0000331E  4EB9 0000 6142          jsr       _MemoryTest
00003322  362A      
00003324  601C      6143          bra.s     menu_37
                    6144   menu_32:
                    6145   ; else if( c1 == (char)('S'))              // Switch Test command
00003326  0C03 0053 6146          cmp.b     #83,D3
0000332A  6606      6147          bne.s     menu_34
                    6148   ; SwitchTest() ;
0000332C  4EB8 0D06 6149          jsr       _SwitchTest
00003330  6010      6150          bra.s     menu_37
                    6151   menu_34:
                    6152   ; else if( c1 == (char)('D'))              // display Test command
00003332  0C03 0044 6153          cmp.b     #68,D3
00003336  6606      6154          bne.s     menu_36
                    6155   ; TestLEDS() ;
00003338  4EB8 0CB2 6156          jsr       _TestLEDS
0000333C  6004      6157          bra.s     menu_37
                    6158   menu_36:
                    6159   ; else
                    6160   ; UnknownCommand() ;
0000333E  4EB8 2FE6 6161          jsr       _UnknownCommand
                    6162   menu_37:
00003342  6000 0126 6163          bra       menu_50
                    6164   menu_30:
                    6165   ; }
                    6166   ; else if( c == (char)(' ')) {             // Next instruction command
00003346  0C02 0020 6167          cmp.b     #32,D2
0000334A  6636      6168          bne.s     menu_38
                    6169   ; DisableBreakPoints() ;
0000334C  4EB8 2BF6 6170          jsr       _DisableBreakPoints
                    6171   ; if(Trace == 1 && GoFlag == 1)   {    // if the program is running and trace mode on then 'N' is valid
00003350  2013      6172          move.l    (A3),D0
00003352  0C80 0000 6173          cmp.l     #1,D0
00003356  0001      
00003358  661A      6174          bne.s     menu_40
0000335A  2039 0B00 6175          move.l    _GoFlag.L,D0
0000335E  00DC      
00003360  0C80 0000 6176          cmp.l     #1,D0
00003364  0001      
00003366  660C      6177          bne.s     menu_40
                    6178   ; TraceException = 1 ;             // generate a trace exception for the next instruction if user wants to single step though next instruction
00003368  13FC 0001 6179          move.b    #1,4194314
0000336C  0040 000A 
                    6180   ; return ;
00003370  6000 00FC 6181          bra       menu_42
                    6182   menu_40:
                    6183   ; }
                    6184   ; else
                    6185   ; printf("\r\nError: Press 'G' first to start program") ;
00003374  4879 0000 6186          pea       @m68kde~1_151.L
00003378  62F0      
0000337A  4E92      6187          jsr       (A2)
0000337C  584F      6188          addq.w    #4,A7
0000337E  6000 00EA 6189          bra       menu_50
                    6190   menu_38:
                    6191   ; }
                    6192   ; else if( c == (char)('S')) {             // single step
00003382  0C02 0053 6193          cmp.b     #83,D2
00003386  6600 008C 6194          bne       menu_43
                    6195   ; if(Trace == 0) {
0000338A  2013      6196          move.l    (A3),D0
0000338C  6600 0050 6197          bne       menu_45
                    6198   ; DisableBreakPoints() ;
00003390  4EB8 2BF6 6199          jsr       _DisableBreakPoints
                    6200   ; printf("\r\nSingle Step  :[ON]") ;
00003394  4879 0000 6201          pea       @m68kde~1_152.L
00003398  631A      
0000339A  4E92      6202          jsr       (A2)
0000339C  584F      6203          addq.w    #4,A7
                    6204   ; printf("\r\nBreak Points :[Disabled]") ;
0000339E  4879 0000 6205          pea       @m68kde~1_85.L
000033A2  59B8      
000033A4  4E92      6206          jsr       (A2)
000033A6  584F      6207          addq.w    #4,A7
                    6208   ; SR = SR | (unsigned short int)(0x8000) ;    // set T bit in status register
000033A8  0055 8000 6209          or.w      #32768,(A5)
                    6210   ; printf("\r\nPress 'G' to Trace Program from address $%X.....",PC) ;
000033AC  2F39 0B00 6211          move.l    _PC.L,-(A7)
000033B0  0120      
000033B2  4879 0000 6212          pea       @m68kde~1_153.L
000033B6  6330      
000033B8  4E92      6213          jsr       (A2)
000033BA  504F      6214          addq.w    #8,A7
                    6215   ; printf("\r\nPush <RESET Button> to Stop.....") ;
000033BC  4879 0000 6216          pea       @m68kde~1_154.L
000033C0  6364      
000033C2  4E92      6217          jsr       (A2)
000033C4  584F      6218          addq.w    #4,A7
                    6219   ; DumpRegisters() ;
000033C6  4EB8 214C 6220          jsr       _DumpRegisters
                    6221   ; Trace = 1;
000033CA  26BC 0000 6222          move.l    #1,(A3)
000033CE  0001      
                    6223   ; TraceException = 1;
000033D0  13FC 0001 6224          move.b    #1,4194314
000033D4  0040 000A 
                    6225   ; x = *(unsigned int *)(0x00000074) ;       // simulate responding to a Level 5 IRQ by reading vector to reset Trace exception generator
000033D8  28B8 0074 6226          move.l    116,(A4)
000033DC  6032      6227          bra.s     menu_46
                    6228   menu_45:
                    6229   ; }
                    6230   ; else {
                    6231   ; Trace = 0 ;
000033DE  4293      6232          clr.l     (A3)
                    6233   ; TraceException = 0 ;
000033E0  4239 0040 6234          clr.b     4194314
000033E4  000A      
                    6235   ; x = *(unsigned int *)(0x00000074) ;       // simulate responding to a Level 5 IRQ by reading vector to reset Trace exception generator
000033E6  28B8 0074 6236          move.l    116,(A4)
                    6237   ; EnableBreakPoints() ;
000033EA  4EB8 2C4A 6238          jsr       _EnableBreakPoints
                    6239   ; SR = SR & (unsigned short int)(0x7FFF) ;    // clear T bit in status register
000033EE  0255 7FFF 6240          and.w     #32767,(A5)
                    6241   ; printf("\r\nSingle Step : [OFF]") ;
000033F2  4879 0000 6242          pea       @m68kde~1_155.L
000033F6  6388      
000033F8  4E92      6243          jsr       (A2)
000033FA  584F      6244          addq.w    #4,A7
                    6245   ; printf("\r\nBreak Points :[Enabled]") ;
000033FC  4879 0000 6246          pea       @m68kde~1_156.L
00003400  639E      
00003402  4E92      6247          jsr       (A2)
00003404  584F      6248          addq.w    #4,A7
                    6249   ; printf("\r\nPress <ESC> to Resume User Program.....") ;
00003406  4879 0000 6250          pea       @m68kde~1_157.L
0000340A  63B8      
0000340C  4E92      6251          jsr       (A2)
0000340E  584F      6252          addq.w    #4,A7
                    6253   menu_46:
00003410  6000 0058 6254          bra       menu_50
                    6255   menu_43:
                    6256   ; }
                    6257   ; }
                    6258   ; else if(c == (char)(0x1b))  {   // if user choses to end trace and run program
00003414  0C02 001B 6259          cmp.b     #27,D2
00003418  6600 0040 6260          bne       menu_47
                    6261   ; Trace = 0;
0000341C  4293      6262          clr.l     (A3)
                    6263   ; TraceException = 0;
0000341E  4239 0040 6264          clr.b     4194314
00003422  000A      
                    6265   ; x = *(unsigned int *)(0x00000074) ;   // read IRQ 5 vector to reset trace vector generator
00003424  28B8 0074 6266          move.l    116,(A4)
                    6267   ; EnableBreakPoints() ;
00003428  4EB8 2C4A 6268          jsr       _EnableBreakPoints
                    6269   ; SR = SR & (unsigned short int)(0x7FFF) ;    // clear T bit in status register
0000342C  0255 7FFF 6270          and.w     #32767,(A5)
                    6271   ; printf("\r\nSingle Step  :[OFF]") ;
00003430  4879 0000 6272          pea       @m68kde~1_158.L
00003434  63E2      
00003436  4E92      6273          jsr       (A2)
00003438  584F      6274          addq.w    #4,A7
                    6275   ; printf("\r\nBreak Points :[Enabled]");
0000343A  4879 0000 6276          pea       @m68kde~1_156.L
0000343E  639E      
00003440  4E92      6277          jsr       (A2)
00003442  584F      6278          addq.w    #4,A7
                    6279   ; printf("\r\nProgram Running.....") ;
00003444  4879 0000 6280          pea       @m68kde~1_149.L
00003448  62AA      
0000344A  4E92      6281          jsr       (A2)
0000344C  584F      6282          addq.w    #4,A7
                    6283   ; printf("\r\nPress <RESET> button <Key0> on DE1 to stop") ;
0000344E  4879 0000 6284          pea       @m68kde~1_150.L
00003452  62C2      
00003454  4E92      6285          jsr       (A2)
00003456  584F      6286          addq.w    #4,A7
                    6287   ; return ;
00003458  6014      6288          bra.s     menu_42
                    6289   menu_47:
                    6290   ; }
                    6291   ; else if( c == (char)('W'))              // Watchpoint command
0000345A  0C02 0057 6292          cmp.b     #87,D2
0000345E  6606      6293          bne.s     menu_49
                    6294   ; Watchpoint() ;
00003460  4EB8 308E 6295          jsr       _Watchpoint
00003464  6004      6296          bra.s     menu_50
                    6297   menu_49:
                    6298   ; else
                    6299   ; UnknownCommand() ;
00003466  4EB8 2FE6 6300          jsr       _UnknownCommand
                    6301   menu_50:
0000346A  6000 FD94 6302          bra       menu_1
                    6303   menu_42:
0000346E  4CDF 3C0C 6304          movem.l   (A7)+,D2/D3/A2/A3/A4/A5
00003472  4E75      6305          rts
                    6306   ; }
                    6307   ; }
                    6308   ; void PrintErrorMessageandAbort(char *string) {
                    6309   _PrintErrorMessageandAbort:
00003474  4E56 0000 6310          link      A6,#0
                    6311   ; printf("\r\n\r\nProgram ABORT !!!!!!\r\n") ;
00003478  4879 0000 6312          pea       @m68kde~1_159.L
0000347C  63F8      
0000347E  4EB9 0000 6313          jsr       _printf
00003482  3C28      
00003484  584F      6314          addq.w    #4,A7
                    6315   ; printf("%s\r\n", string) ;
00003486  2F2E 0008 6316          move.l    8(A6),-(A7)
0000348A  4879 0000 6317          pea       @m68kde~1_160.L
0000348E  6414      
00003490  4EB9 0000 6318          jsr       _printf
00003494  3C28      
00003496  504F      6319          addq.w    #8,A7
                    6320   ; menu() ;
00003498  4EB8 31E4 6321          jsr       _menu
0000349C  4E5E      6322          unlk      A6
0000349E  4E75      6323          rts
                    6324   ; }
                    6325   ; void IRQMessage(int level) {
                    6326   _IRQMessage:
000034A0  4E56 0000 6327          link      A6,#0
                    6328   ; printf("\r\n\r\nProgram ABORT !!!!!");
000034A4  4879 0000 6329          pea       @m68kde~1_161.L
000034A8  641A      
000034AA  4EB9 0000 6330          jsr       _printf
000034AE  3C28      
000034B0  584F      6331          addq.w    #4,A7
                    6332   ; printf("\r\nUnhandled Interrupt: IRQ%d !!!!!", level) ;
000034B2  2F2E 0008 6333          move.l    8(A6),-(A7)
000034B6  4879 0000 6334          pea       @m68kde~1_162.L
000034BA  6432      
000034BC  4EB9 0000 6335          jsr       _printf
000034C0  3C28      
000034C2  504F      6336          addq.w    #8,A7
                    6337   ; menu() ;
000034C4  4EB8 31E4 6338          jsr       _menu
000034C8  4E5E      6339          unlk      A6
000034CA  4E75      6340          rts
                    6341   ; }
                    6342   ; void UnhandledIRQ1(void) {
                    6343   _UnhandledIRQ1:
                    6344   ; IRQMessage(1);
000034CC  4878 0001 6345          pea       1
000034D0  4EB8 34A0 6346          jsr       _IRQMessage
000034D4  584F      6347          addq.w    #4,A7
000034D6  4E75      6348          rts
                    6349   ; }
                    6350   ; void UnhandledIRQ2(void) {
                    6351   _UnhandledIRQ2:
                    6352   ; IRQMessage(2);
000034D8  4878 0002 6353          pea       2
000034DC  4EB8 34A0 6354          jsr       _IRQMessage
000034E0  584F      6355          addq.w    #4,A7
000034E2  4E75      6356          rts
                    6357   ; }
                    6358   ; void UnhandledIRQ3(void){
                    6359   _UnhandledIRQ3:
                    6360   ; IRQMessage(3);
000034E4  4878 0003 6361          pea       3
000034E8  4EB8 34A0 6362          jsr       _IRQMessage
000034EC  584F      6363          addq.w    #4,A7
000034EE  4E75      6364          rts
                    6365   ; }
                    6366   ; void UnhandledIRQ4(void) {
                    6367   _UnhandledIRQ4:
                    6368   ; IRQMessage(4);
000034F0  4878 0004 6369          pea       4
000034F4  4EB8 34A0 6370          jsr       _IRQMessage
000034F8  584F      6371          addq.w    #4,A7
000034FA  4E75      6372          rts
                    6373   ; }
                    6374   ; void UnhandledIRQ5(void) {
                    6375   _UnhandledIRQ5:
                    6376   ; IRQMessage(5);
000034FC  4878 0005 6377          pea       5
00003500  4EB8 34A0 6378          jsr       _IRQMessage
00003504  584F      6379          addq.w    #4,A7
00003506  4E75      6380          rts
                    6381   ; }
                    6382   ; void UnhandledIRQ6(void) {
                    6383   _UnhandledIRQ6:
                    6384   ; PrintErrorMessageandAbort("ADDRESS ERROR: 16 or 32 Bit Transfer to/from an ODD Address....") ;
00003508  4879 0000 6385          pea       @m68kde~1_163.L
0000350C  6456      
0000350E  4EB8 3474 6386          jsr       _PrintErrorMessageandAbort
00003512  584F      6387          addq.w    #4,A7
                    6388   ; menu() ;
00003514  4EB8 31E4 6389          jsr       _menu
00003518  4E75      6390          rts
                    6391   ; }
                    6392   ; void UnhandledIRQ7(void) {
                    6393   _UnhandledIRQ7:
                    6394   ; IRQMessage(7);
0000351A  4878 0007 6395          pea       7
0000351E  4EB8 34A0 6396          jsr       _IRQMessage
00003522  584F      6397          addq.w    #4,A7
00003524  4E75      6398          rts
                    6399   ; }
                    6400   ; void UnhandledTrap(void) {
                    6401   _UnhandledTrap:
                    6402   ; PrintErrorMessageandAbort("Unhandled Trap !!!!!") ;
00003526  4879 0000 6403          pea       @m68kde~1_164.L
0000352A  6496      
0000352C  4EB8 3474 6404          jsr       _PrintErrorMessageandAbort
00003530  584F      6405          addq.w    #4,A7
00003532  4E75      6406          rts
                    6407   ; }
                    6408   ; void BusError() {
                    6409   _BusError:
                    6410   ; PrintErrorMessageandAbort("BUS Error!") ;
00003534  4879 0000 6411          pea       @m68kde~1_165.L
00003538  64AC      
0000353A  4EB8 3474 6412          jsr       _PrintErrorMessageandAbort
0000353E  584F      6413          addq.w    #4,A7
00003540  4E75      6414          rts
                    6415   ; }
                    6416   ; void AddressError() {
                    6417   _AddressError:
                    6418   ; PrintErrorMessageandAbort("ADDRESS Error!") ;
00003542  4879 0000 6419          pea       @m68kde~1_166.L
00003546  64B8      
00003548  4EB8 3474 6420          jsr       _PrintErrorMessageandAbort
0000354C  584F      6421          addq.w    #4,A7
0000354E  4E75      6422          rts
                    6423   ; }
                    6424   ; void IllegalInstruction() {
                    6425   _IllegalInstruction:
                    6426   ; PrintErrorMessageandAbort("ILLEGAL INSTRUCTION") ;
00003550  4879 0000 6427          pea       @m68kde~1_167.L
00003554  64C8      
00003556  4EB8 3474 6428          jsr       _PrintErrorMessageandAbort
0000355A  584F      6429          addq.w    #4,A7
0000355C  4E75      6430          rts
                    6431   ; }
                    6432   ; void Dividebyzero() {
                    6433   _Dividebyzero:
                    6434   ; PrintErrorMessageandAbort("DIVIDE BY ZERO") ;
0000355E  4879 0000 6435          pea       @m68kde~1_168.L
00003562  64DC      
00003564  4EB8 3474 6436          jsr       _PrintErrorMessageandAbort
00003568  584F      6437          addq.w    #4,A7
0000356A  4E75      6438          rts
                    6439   ; }
                    6440   ; void Check() {
                    6441   _Check:
                    6442   ; PrintErrorMessageandAbort("'CHK' INSTRUCTION") ;
0000356C  4879 0000 6443          pea       @m68kde~1_169.L
00003570  64EC      
00003572  4EB8 3474 6444          jsr       _PrintErrorMessageandAbort
00003576  584F      6445          addq.w    #4,A7
00003578  4E75      6446          rts
                    6447   ; }
                    6448   ; void Trapv() {
                    6449   _Trapv:
                    6450   ; PrintErrorMessageandAbort("TRAPV INSTRUCTION") ;
0000357A  4879 0000 6451          pea       @m68kde~1_170.L
0000357E  64FE      
00003580  4EB8 3474 6452          jsr       _PrintErrorMessageandAbort
00003584  584F      6453          addq.w    #4,A7
00003586  4E75      6454          rts
                    6455   ; }
                    6456   ; void PrivError() {
                    6457   _PrivError:
                    6458   ; PrintErrorMessageandAbort("PRIVILEGE VIOLATION") ;
00003588  4879 0000 6459          pea       @m68kde~1_171.L
0000358C  6510      
0000358E  4EB8 3474 6460          jsr       _PrintErrorMessageandAbort
00003592  584F      6461          addq.w    #4,A7
00003594  4E75      6462          rts
                    6463   ; }
                    6464   ; void UnitIRQ() {
                    6465   _UnitIRQ:
                    6466   ; PrintErrorMessageandAbort("UNINITIALISED IRQ") ;
00003596  4879 0000 6467          pea       @m68kde~1_172.L
0000359A  6524      
0000359C  4EB8 3474 6468          jsr       _PrintErrorMessageandAbort
000035A0  584F      6469          addq.w    #4,A7
000035A2  4E75      6470          rts
                    6471   ; }
                    6472   ; void Spurious() {
                    6473   _Spurious:
                    6474   ; PrintErrorMessageandAbort("SPURIOUS IRQ") ;
000035A4  4879 0000 6475          pea       @m68kde~1_173.L
000035A8  6536      
000035AA  4EB8 3474 6476          jsr       _PrintErrorMessageandAbort
000035AE  584F      6477          addq.w    #4,A7
000035B0  4E75      6478          rts
                    6479   ; }
                    6480   ; void EnterString(void)
                    6481   ; {
                    6482   _EnterString:
000035B2  4E56 FFFC 6483          link      A6,#-4
000035B6  2F02      6484          move.l    D2,-(A7)
                    6485   ; unsigned char *Start;
                    6486   ; unsigned char c;
                    6487   ; printf("\r\nStart Address in Memory: ") ;
000035B8  4879 0000 6488          pea       @m68kde~1_174.L
000035BC  6544      
000035BE  4EB9 0000 6489          jsr       _printf
000035C2  3C28      
000035C4  584F      6490          addq.w    #4,A7
                    6491   ; Start = Get8HexDigits(0) ;
000035C6  42A7      6492          clr.l     -(A7)
000035C8  4EB8 0F06 6493          jsr       _Get8HexDigits
000035CC  584F      6494          addq.w    #4,A7
000035CE  2400      6495          move.l    D0,D2
                    6496   ; printf("\r\nEnter String (ESC to end) :") ;
000035D0  4879 0000 6497          pea       @m68kde~1_175.L
000035D4  6560      
000035D6  4EB9 0000 6498          jsr       _printf
000035DA  3C28      
000035DC  584F      6499          addq.w    #4,A7
                    6500   ; while((c = getchar()) != 0x1b)
                    6501   EnterString_1:
000035DE  4EB9 0000 6502          jsr       _getch
000035E2  3D78      
000035E4  1D40 FFFF 6503          move.b    D0,-1(A6)
000035E8  0C00 001B 6504          cmp.b     #27,D0
000035EC  670A      6505          beq.s     EnterString_3
                    6506   ; *Start++ = c ;
000035EE  2042      6507          move.l    D2,A0
000035F0  5282      6508          addq.l    #1,D2
000035F2  10AE FFFF 6509          move.b    -1(A6),(A0)
000035F6  60E6      6510          bra       EnterString_1
                    6511   EnterString_3:
                    6512   ; *Start = 0x00;  // terminate with a null
000035F8  2042      6513          move.l    D2,A0
000035FA  4210      6514          clr.b     (A0)
000035FC  241F      6515          move.l    (A7)+,D2
000035FE  4E5E      6516          unlk      A6
00003600  4E75      6517          rts
                    6518   ; }
                    6519   ; // Sourced from this stack overflow post: https://stackoverflow.com/questions/7898215/how-can-i-clear-an-input-buffer-in-c
                    6520   ; void clearInputBuffer() {
                    6521   _clearInputBuffer:
00003602  4E56 FFFC 6522          link      A6,#-4
                    6523   ; int c;
                    6524   ; while ((c = getchar()) != '\n' && c != EOF);
                    6525   clearInputBuffer_1:
00003606  4EB9 0000 6526          jsr       _getch
0000360A  3D78      
0000360C  2D40 FFFC 6527          move.l    D0,-4(A6)
00003610  0C80 0000 6528          cmp.l     #10,D0
00003614  000A      
00003616  670E      6529          beq.s     clearInputBuffer_3
00003618  202E FFFC 6530          move.l    -4(A6),D0
0000361C  0C80 FFFF 6531          cmp.l     #-1,D0
00003620  FFFF      
00003622  6702      6532          beq.s     clearInputBuffer_3
00003624  60E0      6533          bra       clearInputBuffer_1
                    6534   clearInputBuffer_3:
00003626  4E5E      6535          unlk      A6
00003628  4E75      6536          rts
                    6537   ; }
                    6538   ; void MemoryTest(void)
                    6539   ; {
                    6540   _MemoryTest:
0000362A  4E56 FF40 6541          link      A6,#-192
0000362E  48E7 3F3C 6542          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
00003632  45F9 0000 6543          lea       _printf.L,A2
00003636  3C28      
00003638  4BF8 0DCA 6544          lea       __getch.L,A5
                    6545   ; unsigned int *RamPtr, counter1=1 ;
0000363C  2D7C 0000 6546          move.l    #1,-188(A6)
00003640  0001 FF44 
                    6547   ; register unsigned int i ;
                    6548   ; unsigned int Start, End ;
                    6549   ; char c, text[150];
                    6550   ; unsigned int* addressPointer;
                    6551   ; unsigned int startAddress = NULL;
00003644  42AE FFF0 6552          clr.l     -16(A6)
                    6553   ; unsigned int endAddress = NULL;
00003648  42AE FFF4 6554          clr.l     -12(A6)
                    6555   ; unsigned int byteLength;
                    6556   ; unsigned int dataSize = 0;
0000364C  4285      6557          clr.l     D5
                    6558   ; unsigned int dataPattern = 0;
0000364E  4283      6559          clr.l     D3
                    6560   ; unsigned int currAddress;
                    6561   ; unsigned int addrCount;
                    6562   ; unsigned int intBuffer = NULL;
00003650  7E00      6563          moveq     #0,D7
                    6564   ; unsigned char *startAddressPtr = NULL;
00003652  4282      6565          clr.l     D2
                    6566   ; unsigned char *endAddressPtr = NULL;
00003654  4286      6567          clr.l     D6
                    6568   ; unsigned short int *wordAddressPtr = NULL;
00003656  387C 0000 6569          move.w    #0,A4
                    6570   ; unsigned int *longAddressPtr = NULL;
0000365A  367C 0000 6571          move.w    #0,A3
                    6572   ; // IMPROVEMENTS TO BE MADE:
                    6573   ; // Suppossed to be able to write an odd address as a byte
                    6574   ; // We should be blocking certian thresholds from getting written according to SRAM and DRAM reqs. 
                    6575   ; // printf("\r\nStart Address: ") ;
                    6576   ; // Start = Get8HexDigits(0) ;
                    6577   ; // printf("\r\nEnd Address: ") ;
                    6578   ; // End = Get8HexDigits(0) ;
                    6579   ; // TODO
                    6580   ; scanflush();
0000365E  4EB9 0000 6581          jsr       _scanflush
00003662  40FA      
                    6582   ; memset(text, 0, sizeof(text));  // fills with zeros
00003664  4878 0096 6583          pea       150
00003668  42A7      6584          clr.l     -(A7)
0000366A  486E FF56 6585          pea       -170(A6)
0000366E  4EB9 0000 6586          jsr       _memset
00003672  3E14      
00003674  DEFC 000C 6587          add.w     #12,A7
                    6588   ; printf("\nEnter what size of memory you want to read/write\n Byte = 0\n Word = 1\n Long Word = 2\n");
00003678  4879 0000 6589          pea       @m68kde~1_176.L
0000367C  657E      
0000367E  4E92      6590          jsr       (A2)
00003680  584F      6591          addq.w    #4,A7
                    6592   ; dataSize = _getch() - 48;
00003682  4E95      6593          jsr       (A5)
00003684  0480 0000 6594          sub.l     #48,D0
00003688  0030      
0000368A  2A00      6595          move.l    D0,D5
                    6596   ; printf("\n");
0000368C  4879 0000 6597          pea       @m68kde~1_28.L
00003690  5370      
00003692  4E92      6598          jsr       (A2)
00003694  584F      6599          addq.w    #4,A7
                    6600   ; if (dataSize == 0) {
00003696  4A85      6601          tst.l     D5
00003698  6600 0058 6602          bne       MemoryTest_1
                    6603   ; printf("\nEnter which data pattern you want to write into memory\n 0x00 = 0\n 0xB2 = 1\n 0xC3 = 2\n 0xD4 = 3\n");
0000369C  4879 0000 6604          pea       @m68kde~1_177.L
000036A0  65D4      
000036A2  4E92      6605          jsr       (A2)
000036A4  584F      6606          addq.w    #4,A7
                    6607   ; intBuffer = _getch() - 48;
000036A6  4E95      6608          jsr       (A5)
000036A8  0480 0000 6609          sub.l     #48,D0
000036AC  0030      
000036AE  2E00      6610          move.l    D0,D7
                    6611   ; // scanf("%d", &intBuffer);
                    6612   ; switch (intBuffer) {
000036B0  2007      6613          move.l    D7,D0
000036B2  0C80 0000 6614          cmp.l     #4,D0
000036B6  0004      
000036B8  642C      6615          bhs.s     MemoryTest_4
000036BA  E380      6616          asl.l     #1,D0
000036BC  303B 0806 6617          move.w    MemoryTest_5(PC,D0.L),D0
000036C0  4EFB 0002 6618          jmp       MemoryTest_5(PC,D0.W)
                    6619   MemoryTest_5:
000036C4  0008      6620          dc.w      MemoryTest_6-MemoryTest_5
000036C6  000C      6621          dc.w      MemoryTest_7-MemoryTest_5
000036C8  0014      6622          dc.w      MemoryTest_8-MemoryTest_5
000036CA  001C      6623          dc.w      MemoryTest_9-MemoryTest_5
                    6624   MemoryTest_6:
                    6625   ; case(0):
                    6626   ; dataPattern = 0x00; break;
000036CC  4283      6627          clr.l     D3
000036CE  6016      6628          bra.s     MemoryTest_4
                    6629   MemoryTest_7:
                    6630   ; case(1):
                    6631   ; dataPattern = 0xB2; break;
000036D0  263C 0000 6632          move.l    #178,D3
000036D4  00B2      
000036D6  600E      6633          bra.s     MemoryTest_4
                    6634   MemoryTest_8:
                    6635   ; case(2):
                    6636   ; dataPattern = 0xC3; break;
000036D8  263C 0000 6637          move.l    #195,D3
000036DC  00C3      
000036DE  6006      6638          bra.s     MemoryTest_4
                    6639   MemoryTest_9:
                    6640   ; case(3):
                    6641   ; dataPattern = 0xD4; break;
000036E0  263C 0000 6642          move.l    #212,D3
000036E4  00D4      
                    6643   MemoryTest_4:
                    6644   ; }
                    6645   ; dataPattern &= 0xFF;
000036E6  C6BC 0000 6646          and.l     #255,D3
000036EA  00FF      
                    6647   ; byteLength = 1;
000036EC  7801      6648          moveq     #1,D4
000036EE  6000 00AE 6649          bra       MemoryTest_11
                    6650   MemoryTest_1:
                    6651   ; } else if (dataSize == 1) {
000036F2  0C85 0000 6652          cmp.l     #1,D5
000036F6  0001      
000036F8  6600 0058 6653          bne       MemoryTest_10
                    6654   ; printf("\nEnter which data pattern you want to write into memory\n 0x0000 = 0\n 0x1234 = 1\n 0xA1B2 = 2\n 0xC3D4 = 3\n");
000036FC  4879 0000 6655          pea       @m68kde~1_178.L
00003700  6636      
00003702  4E92      6656          jsr       (A2)
00003704  584F      6657          addq.w    #4,A7
                    6658   ; intBuffer = _getch() - 48;
00003706  4E95      6659          jsr       (A5)
00003708  0480 0000 6660          sub.l     #48,D0
0000370C  0030      
0000370E  2E00      6661          move.l    D0,D7
                    6662   ; switch (intBuffer) {
00003710  2007      6663          move.l    D7,D0
00003712  0C80 0000 6664          cmp.l     #4,D0
00003716  0004      
00003718  642C      6665          bhs.s     MemoryTest_13
0000371A  E380      6666          asl.l     #1,D0
0000371C  303B 0806 6667          move.w    MemoryTest_14(PC,D0.L),D0
00003720  4EFB 0002 6668          jmp       MemoryTest_14(PC,D0.W)
                    6669   MemoryTest_14:
00003724  0008      6670          dc.w      MemoryTest_15-MemoryTest_14
00003726  000C      6671          dc.w      MemoryTest_16-MemoryTest_14
00003728  0014      6672          dc.w      MemoryTest_17-MemoryTest_14
0000372A  001C      6673          dc.w      MemoryTest_18-MemoryTest_14
                    6674   MemoryTest_15:
                    6675   ; case(0):
                    6676   ; dataPattern = 0x0000; break;
0000372C  4283      6677          clr.l     D3
0000372E  6016      6678          bra.s     MemoryTest_13
                    6679   MemoryTest_16:
                    6680   ; case(1):
                    6681   ; dataPattern = 0x1234; break;
00003730  263C 0000 6682          move.l    #4660,D3
00003734  1234      
00003736  600E      6683          bra.s     MemoryTest_13
                    6684   MemoryTest_17:
                    6685   ; case(2):
                    6686   ; dataPattern = 0xA1B2; break;
00003738  263C 0000 6687          move.l    #41394,D3
0000373C  A1B2      
0000373E  6006      6688          bra.s     MemoryTest_13
                    6689   MemoryTest_18:
                    6690   ; case(3):
                    6691   ; dataPattern = 0xC3D4; break;
00003740  263C 0000 6692          move.l    #50132,D3
00003744  C3D4      
                    6693   MemoryTest_13:
                    6694   ; }
                    6695   ; dataPattern &= 0xFFFF;
00003746  C6BC 0000 6696          and.l     #65535,D3
0000374A  FFFF      
                    6697   ; byteLength = 2;
0000374C  7802      6698          moveq     #2,D4
0000374E  6000 004E 6699          bra       MemoryTest_11
                    6700   MemoryTest_10:
                    6701   ; } else {
                    6702   ; printf("\nEnter which data pattern you want to write into memory\n 0x0000_0000 = 0\n 0xAABB_CCDD = 1\n 0x1122_3344 = 2\n 0x7654_3210 = 3\n");
00003752  4879 0000 6703          pea       @m68kde~1_179.L
00003756  66A0      
00003758  4E92      6704          jsr       (A2)
0000375A  584F      6705          addq.w    #4,A7
                    6706   ; intBuffer = _getch() - 48;
0000375C  4E95      6707          jsr       (A5)
0000375E  0480 0000 6708          sub.l     #48,D0
00003762  0030      
00003764  2E00      6709          move.l    D0,D7
                    6710   ; switch (intBuffer) {
00003766  2007      6711          move.l    D7,D0
00003768  0C80 0000 6712          cmp.l     #4,D0
0000376C  0004      
0000376E  642C      6713          bhs.s     MemoryTest_20
00003770  E380      6714          asl.l     #1,D0
00003772  303B 0806 6715          move.w    MemoryTest_21(PC,D0.L),D0
00003776  4EFB 0002 6716          jmp       MemoryTest_21(PC,D0.W)
                    6717   MemoryTest_21:
0000377A  0008      6718          dc.w      MemoryTest_22-MemoryTest_21
0000377C  000C      6719          dc.w      MemoryTest_23-MemoryTest_21
0000377E  0014      6720          dc.w      MemoryTest_24-MemoryTest_21
00003780  001C      6721          dc.w      MemoryTest_25-MemoryTest_21
                    6722   MemoryTest_22:
                    6723   ; case(0):
                    6724   ; dataPattern = 0x00000000; break;
00003782  4283      6725          clr.l     D3
00003784  6016      6726          bra.s     MemoryTest_20
                    6727   MemoryTest_23:
                    6728   ; case(1):
                    6729   ; dataPattern = 0xAABBCCDD; break;
00003786  263C AABB 6730          move.l    #-1430532899,D3
0000378A  CCDD      
0000378C  600E      6731          bra.s     MemoryTest_20
                    6732   MemoryTest_24:
                    6733   ; case(2):
                    6734   ; dataPattern = 0x11223344; break;
0000378E  263C 1122 6735          move.l    #287454020,D3
00003792  3344      
00003794  6006      6736          bra.s     MemoryTest_20
                    6737   MemoryTest_25:
                    6738   ; case(3):
                    6739   ; dataPattern = 0x76543210; break;
00003796  263C 7654 6740          move.l    #1985229328,D3
0000379A  3210      
                    6741   MemoryTest_20:
                    6742   ; }
                    6743   ; byteLength = 4;
0000379C  7804      6744          moveq     #4,D4
                    6745   MemoryTest_11:
                    6746   ; }
                    6747   ; // Tests the DRAM range memory from 0x0802_0000 to 0x0B00_0000
                    6748   ; while (startAddressPtr == NULL || 
                    6749   MemoryTest_26:
0000379E  4A82      6750          tst.l     D2
000037A0  6732      6751          beq.s     MemoryTest_29
000037A2  0C84 0000 6752          cmp.l     #1,D4
000037A6  0001      
000037A8  6316      6753          bls.s     MemoryTest_30
000037AA  2F02      6754          move.l    D2,-(A7)
000037AC  4878 0002 6755          pea       2
000037B0  4EB9 0000 6756          jsr       ULDIV
000037B4  3C6A      
000037B6  202F 0004 6757          move.l    4(A7),D0
000037BA  504F      6758          addq.w    #8,A7
000037BC  4A80      6759          tst.l     D0
000037BE  6614      6760          bne.s     MemoryTest_29
                    6761   MemoryTest_30:
000037C0  0C82 0802 6762          cmp.l     #134348800,D2
000037C4  0000      
000037C6  650C      6763          blo.s     MemoryTest_29
000037C8  203C 0B00 6764          move.l    #184549376,D0
000037CC  0000      
000037CE  9084      6765          sub.l     D4,D0
000037D0  B480      6766          cmp.l     D0,D2
000037D2  6316      6767          bls.s     MemoryTest_28
                    6768   MemoryTest_29:
                    6769   ; (byteLength > 1 && (unsigned int) startAddressPtr % 2 != 0) || 
                    6770   ; (unsigned int) startAddressPtr < 0x08020000 || 
                    6771   ; (unsigned int) startAddressPtr > 0x0B000000 - byteLength) {
                    6772   ; printf("\nProvide Start Address in hex (do not use 0x prefix)\n0x");
000037D4  4879 0000 6773          pea       @m68kde~1_180.L
000037D8  671E      
000037DA  4E92      6774          jsr       (A2)
000037DC  584F      6775          addq.w    #4,A7
                    6776   ; startAddressPtr =  Get8HexDigits(0);
000037DE  42A7      6777          clr.l     -(A7)
000037E0  4EB8 0F06 6778          jsr       _Get8HexDigits
000037E4  584F      6779          addq.w    #4,A7
000037E6  2400      6780          move.l    D0,D2
000037E8  60B4      6781          bra       MemoryTest_26
                    6782   MemoryTest_28:
                    6783   ; }
                    6784   ; while (endAddressPtr == NULL || 
                    6785   MemoryTest_31:
000037EA  4A86      6786          tst.l     D6
000037EC  670A      6787          beq.s     MemoryTest_34
000037EE  202E FFF0 6788          move.l    -16(A6),D0
000037F2  D084      6789          add.l     D4,D0
000037F4  BC80      6790          cmp.l     D0,D6
000037F6  6416      6791          bhs.s     MemoryTest_33
                    6792   MemoryTest_34:
                    6793   ; (unsigned int) endAddressPtr < startAddress + byteLength) {
                    6794   ; printf("\nProvide End Address in hex (do not use 0x prefix)\n0x");
000037F8  4879 0000 6795          pea       @m68kde~1_181.L
000037FC  6756      
000037FE  4E92      6796          jsr       (A2)
00003800  584F      6797          addq.w    #4,A7
                    6798   ; endAddressPtr =  Get8HexDigits(0);
00003802  42A7      6799          clr.l     -(A7)
00003804  4EB8 0F06 6800          jsr       _Get8HexDigits
00003808  584F      6801          addq.w    #4,A7
0000380A  2C00      6802          move.l    D0,D6
0000380C  60DC      6803          bra       MemoryTest_31
                    6804   MemoryTest_33:
                    6805   ; }
                    6806   ; printf("\nStart Address 0x%08x\n", (unsigned int) startAddressPtr);
0000380E  2F02      6807          move.l    D2,-(A7)
00003810  4879 0000 6808          pea       @m68kde~1_182.L
00003814  678C      
00003816  4E92      6809          jsr       (A2)
00003818  504F      6810          addq.w    #8,A7
                    6811   ; printf("\nEnd Address: 0x%08x\n",(unsigned int) endAddressPtr);
0000381A  2F06      6812          move.l    D6,-(A7)
0000381C  4879 0000 6813          pea       @m68kde~1_183.L
00003820  67A4      
00003822  4E92      6814          jsr       (A2)
00003824  504F      6815          addq.w    #8,A7
                    6816   ; addrCount = 0;
00003826  42AE FFFC 6817          clr.l     -4(A6)
                    6818   ; while (startAddressPtr < endAddressPtr && ((unsigned int)endAddressPtr - (unsigned int)startAddressPtr + 1) >= (byteLength)) {
                    6819   MemoryTest_35:
0000382A  B486      6820          cmp.l     D6,D2
0000382C  6400 0132 6821          bhs       MemoryTest_37
00003830  2006      6822          move.l    D6,D0
00003832  9082      6823          sub.l     D2,D0
00003834  5280      6824          addq.l    #1,D0
00003836  B084      6825          cmp.l     D4,D0
00003838  6500 0126 6826          blo       MemoryTest_37
                    6827   ; // If address goes beyond 0x0B00_0000 then break
                    6828   ; if ((unsigned int)startAddressPtr > 0x0B000000 - byteLength) {
0000383C  203C 0B00 6829          move.l    #184549376,D0
00003840  0000      
00003842  9084      6830          sub.l     D4,D0
00003844  B480      6831          cmp.l     D0,D2
00003846  6310      6832          bls.s     MemoryTest_38
                    6833   ; printf("ERROR... Address 0x%x is beyond the memory range\n", (void*)startAddressPtr);
00003848  2F02      6834          move.l    D2,-(A7)
0000384A  4879 0000 6835          pea       @m68kde~1_184.L
0000384E  67BA      
00003850  4E92      6836          jsr       (A2)
00003852  504F      6837          addq.w    #8,A7
                    6838   ; break;
00003854  6000 010A 6839          bra       MemoryTest_37
                    6840   MemoryTest_38:
                    6841   ; }
                    6842   ; longAddressPtr = startAddressPtr;
00003858  2642      6843          move.l    D2,A3
                    6844   ; wordAddressPtr = startAddressPtr;
0000385A  2842      6845          move.l    D2,A4
                    6846   ; if (dataSize == 0) {
0000385C  4A85      6847          tst.l     D5
0000385E  6600 0034 6848          bne       MemoryTest_40
                    6849   ; *startAddressPtr = dataPattern;
00003862  2042      6850          move.l    D2,A0
00003864  1083      6851          move.b    D3,(A0)
                    6852   ; if ((*startAddressPtr) != dataPattern) {
00003866  2042      6853          move.l    D2,A0
00003868  1010      6854          move.b    (A0),D0
0000386A  C0BC 0000 6855          and.l     #255,D0
0000386E  00FF      
00003870  B083      6856          cmp.l     D3,D0
00003872  671C      6857          beq.s     MemoryTest_42
                    6858   ; printf("ERROR... Value written to address 0x%x == 0x%x. Value Expected: 0x%x\n", (void*)startAddressPtr, *startAddressPtr, dataPattern);
00003874  2F03      6859          move.l    D3,-(A7)
00003876  2042      6860          move.l    D2,A0
00003878  1210      6861          move.b    (A0),D1
0000387A  C2BC 0000 6862          and.l     #255,D1
0000387E  00FF      
00003880  2F01      6863          move.l    D1,-(A7)
00003882  2F02      6864          move.l    D2,-(A7)
00003884  4879 0000 6865          pea       @m68kde~1_185.L
00003888  67EC      
0000388A  4E92      6866          jsr       (A2)
0000388C  DEFC 0010 6867          add.w     #16,A7
                    6868   MemoryTest_42:
00003890  6000 0058 6869          bra       MemoryTest_48
                    6870   MemoryTest_40:
                    6871   ; }
                    6872   ; } else if (dataSize == 1) {
00003894  0C85 0000 6873          cmp.l     #1,D5
00003898  0001      
0000389A  662C      6874          bne.s     MemoryTest_44
                    6875   ; *wordAddressPtr = dataPattern;
0000389C  3883      6876          move.w    D3,(A4)
                    6877   ; if ((*wordAddressPtr) != dataPattern) {
0000389E  3014      6878          move.w    (A4),D0
000038A0  C0BC 0000 6879          and.l     #65535,D0
000038A4  FFFF      
000038A6  B083      6880          cmp.l     D3,D0
000038A8  671C      6881          beq.s     MemoryTest_46
                    6882   ; printf("ERROR... Value written to address 0x%x == 0x%x. Value Expected: 0x%x\n", (void*)startAddressPtr, *startAddressPtr, dataPattern);
000038AA  2F03      6883          move.l    D3,-(A7)
000038AC  2042      6884          move.l    D2,A0
000038AE  1210      6885          move.b    (A0),D1
000038B0  C2BC 0000 6886          and.l     #255,D1
000038B4  00FF      
000038B6  2F01      6887          move.l    D1,-(A7)
000038B8  2F02      6888          move.l    D2,-(A7)
000038BA  4879 0000 6889          pea       @m68kde~1_185.L
000038BE  67EC      
000038C0  4E92      6890          jsr       (A2)
000038C2  DEFC 0010 6891          add.w     #16,A7
                    6892   MemoryTest_46:
000038C6  6022      6893          bra.s     MemoryTest_48
                    6894   MemoryTest_44:
                    6895   ; }
                    6896   ; } else {
                    6897   ; *longAddressPtr = dataPattern;
000038C8  2683      6898          move.l    D3,(A3)
                    6899   ; if ((*longAddressPtr) != dataPattern) {
000038CA  B693      6900          cmp.l     (A3),D3
000038CC  671C      6901          beq.s     MemoryTest_48
                    6902   ; printf("ERROR... Value written to address 0x%x == 0x%x. Value Expected: 0x%x\n", (void*)startAddressPtr, *startAddressPtr, dataPattern);
000038CE  2F03      6903          move.l    D3,-(A7)
000038D0  2042      6904          move.l    D2,A0
000038D2  1210      6905          move.b    (A0),D1
000038D4  C2BC 0000 6906          and.l     #255,D1
000038D8  00FF      
000038DA  2F01      6907          move.l    D1,-(A7)
000038DC  2F02      6908          move.l    D2,-(A7)
000038DE  4879 0000 6909          pea       @m68kde~1_185.L
000038E2  67EC      
000038E4  4E92      6910          jsr       (A2)
000038E6  DEFC 0010 6911          add.w     #16,A7
                    6912   MemoryTest_48:
                    6913   ; }
                    6914   ; }
                    6915   ; // if ((*startAddressPtr) != dataPattern) {
                    6916   ; //     printf("ERROR... Value written to address 0x%x == 0x%x. Value Expected: 0x%x\n", (void*)startAddressPtr, *startAddressPtr, dataPattern);
                    6917   ; // }
                    6918   ; addrCount++;
000038EA  52AE FFFC 6919          addq.l    #1,-4(A6)
                    6920   ; if (addrCount % 128 == 0) {
000038EE  2F2E FFFC 6921          move.l    -4(A6),-(A7)
000038F2  4878 0080 6922          pea       128
000038F6  4EB9 0000 6923          jsr       ULDIV
000038FA  3C6A      
000038FC  202F 0004 6924          move.l    4(A7),D0
00003900  504F      6925          addq.w    #8,A7
00003902  4A80      6926          tst.l     D0
00003904  6600 0054 6927          bne       MemoryTest_55
                    6928   ; if (dataSize == 0) {
00003908  4A85      6929          tst.l     D5
0000390A  661C      6930          bne.s     MemoryTest_52
                    6931   ; printf("Address: 0x%x Value: 0x%02X\n",
0000390C  2042      6932          move.l    D2,A0
0000390E  1210      6933          move.b    (A0),D1
00003910  C2BC 0000 6934          and.l     #255,D1
00003914  00FF      
00003916  2F01      6935          move.l    D1,-(A7)
00003918  2F02      6936          move.l    D2,-(A7)
0000391A  4879 0000 6937          pea       @m68kde~1_186.L
0000391E  6832      
00003920  4E92      6938          jsr       (A2)
00003922  DEFC 000C 6939          add.w     #12,A7
00003926  6032      6940          bra.s     MemoryTest_55
                    6941   MemoryTest_52:
                    6942   ; (unsigned int)startAddressPtr, *startAddressPtr);
                    6943   ; }
                    6944   ; else if (dataSize == 1) {
00003928  0C85 0000 6945          cmp.l     #1,D5
0000392C  0001      
0000392E  661A      6946          bne.s     MemoryTest_54
                    6947   ; printf("Address: 0x%x Value: 0x%04X\n",
00003930  3214      6948          move.w    (A4),D1
00003932  C2BC 0000 6949          and.l     #65535,D1
00003936  FFFF      
00003938  2F01      6950          move.l    D1,-(A7)
0000393A  2F0C      6951          move.l    A4,-(A7)
0000393C  4879 0000 6952          pea       @m68kde~1_187.L
00003940  6850      
00003942  4E92      6953          jsr       (A2)
00003944  DEFC 000C 6954          add.w     #12,A7
00003948  6010      6955          bra.s     MemoryTest_55
                    6956   MemoryTest_54:
                    6957   ; (unsigned int)wordAddressPtr, *wordAddressPtr);
                    6958   ; }
                    6959   ; else {
                    6960   ; printf("Address: 0x%x Value: 0x%08X\n",
0000394A  2F13      6961          move.l    (A3),-(A7)
0000394C  2F0B      6962          move.l    A3,-(A7)
0000394E  4879 0000 6963          pea       @m68kde~1_188.L
00003952  686E      
00003954  4E92      6964          jsr       (A2)
00003956  DEFC 000C 6965          add.w     #12,A7
                    6966   MemoryTest_55:
                    6967   ; (unsigned int)longAddressPtr, *longAddressPtr);
                    6968   ; }
                    6969   ; }
                    6970   ; startAddressPtr += byteLength;
0000395A  D484      6971          add.l     D4,D2
0000395C  6000 FECC 6972          bra       MemoryTest_35
                    6973   MemoryTest_37:
00003960  4CDF 3CFC 6974          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
00003964  4E5E      6975          unlk      A6
00003966  4E75      6976          rts
                    6977   ; }
                    6978   ; // add your code to test memory here using 32 bit reads and writes of data between the start and end of memory
                    6979   ; }
                    6980   ; void main(void)
                    6981   ; {
                    6982   _main:
00003968  4E56 FFF4 6983          link      A6,#-12
0000396C  48E7 3030 6984          movem.l   D2/D3/A2/A3,-(A7)
00003970  45F8 0C92 6985          lea       _InstallExceptionHandler.L,A2
00003974  47F9 0000 6986          lea       _printf.L,A3
00003978  3C28      
                    6987   ; char c ;
                    6988   ; int i, j ;
                    6989   ; char *BugMessage = "DE1-68k Bug V1.77";
0000397A  41F9 0000 6990          lea       @m68kde~1_189.L,A0
0000397E  688C      
00003980  2608      6991          move.l    A0,D3
                    6992   ; char *CopyrightMessage = "Copyright (C) PJ Davies 2016";
00003982  41F9 0000 6993          lea       @m68kde~1_190.L,A0
00003986  689E      
00003988  2D48 FFFC 6994          move.l    A0,-4(A6)
                    6995   ; KillAllBreakPoints() ;
0000398C  4EB8 2C92 6996          jsr       _KillAllBreakPoints
                    6997   ; i = x = y = z = PortA_Count = 0;
00003990  42B9 0B00 6998          clr.l     _PortA_Count.L
00003994  00D4      
00003996  42B9 0B00 6999          clr.l     _z.L
0000399A  00D0      
0000399C  42B9 0B00 7000          clr.l     _y.L
000039A0  00CC      
000039A2  42B9 0B00 7001          clr.l     _x.L
000039A6  00C8      
000039A8  4282      7002          clr.l     D2
                    7003   ; Trace = GoFlag = 0;                       // used in tracing/single stepping
000039AA  42B9 0B00 7004          clr.l     _GoFlag.L
000039AE  00DC      
000039B0  42B9 0B00 7005          clr.l     _Trace.L
000039B4  00D8      
                    7006   ; Echo = 1 ;
000039B6  23FC 0000 7007          move.l    #1,_Echo.L
000039BA  0001 0B00 
000039BE  00E0      
                    7008   ; d0=d1=d2=d3=d4=d5=d6=d7=0 ;
000039C0  42B9 0B00 7009          clr.l     _d7.L
000039C4  0100      
000039C6  42B9 0B00 7010          clr.l     _d6.L
000039CA  00FC      
000039CC  42B9 0B00 7011          clr.l     _d5.L
000039D0  00F8      
000039D2  42B9 0B00 7012          clr.l     _d4.L
000039D6  00F4      
000039D8  42B9 0B00 7013          clr.l     _d3.L
000039DC  00F0      
000039DE  42B9 0B00 7014          clr.l     _d2.L
000039E2  00EC      
000039E4  42B9 0B00 7015          clr.l     _d1.L
000039E8  00E8      
000039EA  42B9 0B00 7016          clr.l     _d0.L
000039EE  00E4      
                    7017   ; a0=a1=a2=a3=a4=a5=a6=0 ;
000039F0  42B9 0B00 7018          clr.l     _a6.L
000039F4  011C      
000039F6  42B9 0B00 7019          clr.l     _a5.L
000039FA  0118      
000039FC  42B9 0B00 7020          clr.l     _a4.L
00003A00  0114      
00003A02  42B9 0B00 7021          clr.l     _a3.L
00003A06  0110      
00003A08  42B9 0B00 7022          clr.l     _a2.L
00003A0C  010C      
00003A0E  42B9 0B00 7023          clr.l     _a1.L
00003A12  0108      
00003A14  42B9 0B00 7024          clr.l     _a0.L
00003A18  0104      
                    7025   ; PC = ProgramStart, SSP=TopOfStack, USP = TopOfStack;
00003A1A  23FC 0800 7026          move.l    #134217728,_PC.L
00003A1E  0000 0B00 
00003A22  0120      
00003A24  23FC 0C00 7027          move.l    #201326592,_SSP.L
00003A28  0000 0B00 
00003A2C  0124      
00003A2E  23FC 0C00 7028          move.l    #201326592,_USP.L
00003A32  0000 0B00 
00003A36  0128      
                    7029   ; SR = 0x2000;                            // clear interrupts enable tracing  uses IRQ6
00003A38  33FC 2000 7030          move.w    #8192,_SR.L
00003A3C  0B00 012C 
                    7031   ; // Initialise Breakpoint variables
                    7032   ; for(i = 0; i < 8; i++)  {
00003A40  4282      7033          clr.l     D2
                    7034   main_1:
00003A42  0C82 0000 7035          cmp.l     #8,D2
00003A46  0008      
00003A48  6C00 004C 7036          bge       main_3
                    7037   ; BreakPointAddress[i] = 0;               //array of 8 breakpoint addresses
00003A4C  2002      7038          move.l    D2,D0
00003A4E  E588      7039          lsl.l     #2,D0
00003A50  41F9 0B00 7040          lea       _BreakPointAddress.L,A0
00003A54  012E      
00003A56  42B0 0800 7041          clr.l     0(A0,D0.L)
                    7042   ; WatchPointAddress[i] = 0 ;
00003A5A  2002      7043          move.l    D2,D0
00003A5C  E588      7044          lsl.l     #2,D0
00003A5E  41F9 0B00 7045          lea       _WatchPointAddress.L,A0
00003A62  0182      
00003A64  42B0 0800 7046          clr.l     0(A0,D0.L)
                    7047   ; BreakPointInstruction[i] = 0;           // to hold the instruction at the break point
00003A68  2002      7048          move.l    D2,D0
00003A6A  E388      7049          lsl.l     #1,D0
00003A6C  41F9 0B00 7050          lea       _BreakPointInstruction.L,A0
00003A70  014E      
00003A72  4270 0800 7051          clr.w     0(A0,D0.L)
                    7052   ; BreakPointSetOrCleared[i] = 0;          // indicates if break point set
00003A76  2002      7053          move.l    D2,D0
00003A78  E588      7054          lsl.l     #2,D0
00003A7A  41F9 0B00 7055          lea       _BreakPointSetOrCleared.L,A0
00003A7E  015E      
00003A80  42B0 0800 7056          clr.l     0(A0,D0.L)
                    7057   ; WatchPointSetOrCleared[i] = 0;
00003A84  2002      7058          move.l    D2,D0
00003A86  E588      7059          lsl.l     #2,D0
00003A88  41F9 0B00 7060          lea       _WatchPointSetOrCleared.L,A0
00003A8C  01A2      
00003A8E  42B0 0800 7061          clr.l     0(A0,D0.L)
00003A92  5282      7062          addq.l    #1,D2
00003A94  60AC      7063          bra       main_1
                    7064   main_3:
                    7065   ; }
                    7066   ; Init_RS232() ;     // initialise the RS232 port
00003A96  4EB8 0D74 7067          jsr       _Init_RS232
                    7068   ; Init_LCD() ;
00003A9A  4EB8 0BC0 7069          jsr       _Init_LCD
                    7070   ; SPI_Init();
00003A9E  4EB8 135E 7071          jsr       _SPI_Init
                    7072   ; IIC_Init();
00003AA2  4EB8 168A 7073          jsr       _IIC_Init
                    7074   ; for( i = 32; i < 48; i++)
00003AA6  7420      7075          moveq     #32,D2
                    7076   main_4:
00003AA8  0C82 0000 7077          cmp.l     #48,D2
00003AAC  0030      
00003AAE  6C0E      7078          bge.s     main_6
                    7079   ; InstallExceptionHandler(UnhandledTrap, i) ;		        // install Trap exception handler on vector 32-47
00003AB0  2F02      7080          move.l    D2,-(A7)
00003AB2  4878 3526 7081          pea       _UnhandledTrap.L
00003AB6  4E92      7082          jsr       (A2)
00003AB8  504F      7083          addq.w    #8,A7
00003ABA  5282      7084          addq.l    #1,D2
00003ABC  60EA      7085          bra       main_4
                    7086   main_6:
                    7087   ; InstallExceptionHandler(menu, 47) ;		                   // TRAP #15 call debug and end program
00003ABE  4878 002F 7088          pea       47
00003AC2  4878 31E4 7089          pea       _menu.L
00003AC6  4E92      7090          jsr       (A2)
00003AC8  504F      7091          addq.w    #8,A7
                    7092   ; InstallExceptionHandler(UnhandledIRQ1, 25) ;		      // install handler for interrupts
00003ACA  4878 0019 7093          pea       25
00003ACE  4878 34CC 7094          pea       _UnhandledIRQ1.L
00003AD2  4E92      7095          jsr       (A2)
00003AD4  504F      7096          addq.w    #8,A7
                    7097   ; InstallExceptionHandler(UnhandledIRQ2, 26) ;		      // install handler for interrupts
00003AD6  4878 001A 7098          pea       26
00003ADA  4878 34D8 7099          pea       _UnhandledIRQ2.L
00003ADE  4E92      7100          jsr       (A2)
00003AE0  504F      7101          addq.w    #8,A7
                    7102   ; InstallExceptionHandler(UnhandledIRQ3, 27) ;		      // install handler for interrupts
00003AE2  4878 001B 7103          pea       27
00003AE6  4878 34E4 7104          pea       _UnhandledIRQ3.L
00003AEA  4E92      7105          jsr       (A2)
00003AEC  504F      7106          addq.w    #8,A7
                    7107   ; InstallExceptionHandler(UnhandledIRQ4, 28) ;		      // install handler for interrupts
00003AEE  4878 001C 7108          pea       28
00003AF2  4878 34F0 7109          pea       _UnhandledIRQ4.L
00003AF6  4E92      7110          jsr       (A2)
00003AF8  504F      7111          addq.w    #8,A7
                    7112   ; InstallExceptionHandler(UnhandledIRQ5, 29) ;		      // install handler for interrupts
00003AFA  4878 001D 7113          pea       29
00003AFE  4878 34FC 7114          pea       _UnhandledIRQ5.L
00003B02  4E92      7115          jsr       (A2)
00003B04  504F      7116          addq.w    #8,A7
                    7117   ; InstallExceptionHandler(UnhandledIRQ6, 30) ;		      // install handler for interrupts
00003B06  4878 001E 7118          pea       30
00003B0A  4878 3508 7119          pea       _UnhandledIRQ6.L
00003B0E  4E92      7120          jsr       (A2)
00003B10  504F      7121          addq.w    #8,A7
                    7122   ; InstallExceptionHandler(UnhandledIRQ7, 31) ;		      // install handler for interrupts
00003B12  4878 001F 7123          pea       31
00003B16  4878 351A 7124          pea       _UnhandledIRQ7.L
00003B1A  4E92      7125          jsr       (A2)
00003B1C  504F      7126          addq.w    #8,A7
                    7127   ; InstallExceptionHandler(HandleBreakPoint, 46) ;		           // install Trap 14 Break Point exception handler on vector 46
00003B1E  4878 002E 7128          pea       46
00003B22  4878 2F20 7129          pea       _HandleBreakPoint.L
00003B26  4E92      7130          jsr       (A2)
00003B28  504F      7131          addq.w    #8,A7
                    7132   ; InstallExceptionHandler(DumpRegistersandPause, 29) ;		   // install TRACE handler for IRQ5 on vector 29
00003B2A  4878 001D 7133          pea       29
00003B2E  4878 2600 7134          pea       _DumpRegistersandPause.L
00003B32  4E92      7135          jsr       (A2)
00003B34  504F      7136          addq.w    #8,A7
                    7137   ; InstallExceptionHandler(BusError,2) ;                          // install Bus error handler
00003B36  4878 0002 7138          pea       2
00003B3A  4878 3534 7139          pea       _BusError.L
00003B3E  4E92      7140          jsr       (A2)
00003B40  504F      7141          addq.w    #8,A7
                    7142   ; InstallExceptionHandler(AddressError,3) ;                      // install address error handler (doesn't work on soft core 68k implementation)
00003B42  4878 0003 7143          pea       3
00003B46  4878 3542 7144          pea       _AddressError.L
00003B4A  4E92      7145          jsr       (A2)
00003B4C  504F      7146          addq.w    #8,A7
                    7147   ; InstallExceptionHandler(IllegalInstruction,4) ;                // install illegal instruction exception handler
00003B4E  4878 0004 7148          pea       4
00003B52  4878 3550 7149          pea       _IllegalInstruction.L
00003B56  4E92      7150          jsr       (A2)
00003B58  504F      7151          addq.w    #8,A7
                    7152   ; InstallExceptionHandler(Dividebyzero,5) ;                      // install /0 exception handler
00003B5A  4878 0005 7153          pea       5
00003B5E  4878 355E 7154          pea       _Dividebyzero.L
00003B62  4E92      7155          jsr       (A2)
00003B64  504F      7156          addq.w    #8,A7
                    7157   ; InstallExceptionHandler(Check,6) ;                             // install check instruction exception handler
00003B66  4878 0006 7158          pea       6
00003B6A  4878 356C 7159          pea       _Check.L
00003B6E  4E92      7160          jsr       (A2)
00003B70  504F      7161          addq.w    #8,A7
                    7162   ; InstallExceptionHandler(Trapv,7) ;                             // install trapv instruction exception handler
00003B72  4878 0007 7163          pea       7
00003B76  4878 357A 7164          pea       _Trapv.L
00003B7A  4E92      7165          jsr       (A2)
00003B7C  504F      7166          addq.w    #8,A7
                    7167   ; InstallExceptionHandler(PrivError,8) ;                         // install Priv Violation exception handler
00003B7E  4878 0008 7168          pea       8
00003B82  4878 3588 7169          pea       _PrivError.L
00003B86  4E92      7170          jsr       (A2)
00003B88  504F      7171          addq.w    #8,A7
                    7172   ; InstallExceptionHandler(UnitIRQ,15) ;                          // install uninitialised IRQ exception handler
00003B8A  4878 000F 7173          pea       15
00003B8E  4878 3596 7174          pea       _UnitIRQ.L
00003B92  4E92      7175          jsr       (A2)
00003B94  504F      7176          addq.w    #8,A7
                    7177   ; InstallExceptionHandler(Check,24) ;                            // install spurious IRQ exception handler
00003B96  4878 0018 7178          pea       24
00003B9A  4878 356C 7179          pea       _Check.L
00003B9E  4E92      7180          jsr       (A2)
00003BA0  504F      7181          addq.w    #8,A7
                    7182   ; FlushKeyboard() ;                        // dump unread characters from keyboard
00003BA2  4EB8 0E08 7183          jsr       _FlushKeyboard
                    7184   ; TraceException = 0 ;                     // clear trace exception port to remove any software generated single step/trace
00003BA6  4239 0040 7185          clr.b     4194314
00003BAA  000A      
                    7186   ; // test for auto flash boot and run from Flash by reading switch 9 on DE1-soc board. If set, copy program from flash into Dram and run
                    7187   ; if (((char)(PortB & 0x02)) == (char)(0x02))    {
00003BAC  1039 0040 7188          move.b    4194306,D0
00003BB0  0002      
00003BB2  C03C 0002 7189          and.b     #2,D0
00003BB6  0C00 0002 7190          cmp.b     #2,D0
00003BBA  6628      7191          bne.s     main_7
                    7192   ; LoadFromFlashChip();
00003BBC  4EB8 15EC 7193          jsr       _LoadFromFlashChip
                    7194   ; printf("\r\nRunning.....") ;
00003BC0  4879 0000 7195          pea       @m68kde~1_191.L
00003BC4  68BC      
00003BC6  4E93      7196          jsr       (A3)
00003BC8  584F      7197          addq.w    #4,A7
                    7198   ; Oline1("Running.....") ;
00003BCA  4879 0000 7199          pea       @m68kde~1_192.L
00003BCE  68CC      
00003BD0  4EB8 0C64 7200          jsr       _Oline1
00003BD4  584F      7201          addq.w    #4,A7
                    7202   ; GoFlag = 1;
00003BD6  23FC 0000 7203          move.l    #1,_GoFlag.L
00003BDA  0001 0B00 
00003BDE  00DC      
                    7204   ; go() ;
00003BE0  4EB8 08B8 7205          jsr       _go
                    7206   main_7:
                    7207   ; }
                    7208   ; // otherwise start the debug monitor
                    7209   ; Oline0(BugMessage) ;
00003BE4  2F03      7210          move.l    D3,-(A7)
00003BE6  4EB8 0C36 7211          jsr       _Oline0
00003BEA  584F      7212          addq.w    #4,A7
                    7213   ; Oline1("By: PJ Davies") ;
00003BEC  4879 0000 7214          pea       @m68kde~1_193.L
00003BF0  68DA      
00003BF2  4EB8 0C64 7215          jsr       _Oline1
00003BF6  584F      7216          addq.w    #4,A7
                    7217   ; printf("\r\n%s", BugMessage) ;
00003BF8  2F03      7218          move.l    D3,-(A7)
00003BFA  4879 0000 7219          pea       @m68kde~1_194.L
00003BFE  68E8      
00003C00  4E93      7220          jsr       (A3)
00003C02  504F      7221          addq.w    #8,A7
                    7222   ; printf("\r\n%s", CopyrightMessage) ;
00003C04  2F2E FFFC 7223          move.l    -4(A6),-(A7)
00003C08  4879 0000 7224          pea       @m68kde~1_194.L
00003C0C  68E8      
00003C0E  4E93      7225          jsr       (A3)
00003C10  504F      7226          addq.w    #8,A7
                    7227   ; printf("\n Student Names:\n Zachariah Joseph: 45500055 \n Umair Mazhar: 20333308\n");
00003C12  4879 0000 7228          pea       @m68kde~1_195.L
00003C16  68EE      
00003C18  4E93      7229          jsr       (A3)
00003C1A  584F      7230          addq.w    #4,A7
                    7231   ; menu();
00003C1C  4EB8 31E4 7232          jsr       _menu
00003C20  4CDF 0C0C 7233          movem.l   (A7)+,D2/D3/A2/A3
00003C24  4E5E      7234          unlk      A6
00003C26  4E75      7235          rts
                    7236   ; }
                    7237   _printf:
00003C28  4E56 FFFC 7238          link      A6,#-4
00003C2C  48E7 2000 7239          movem.l   D2,-(A7)
00003C30  41EE 0008 7240          lea       8(A6),A0
00003C34  5848      7241          addq.w    #4,A0
00003C36  2408      7242          move.l    A0,D2
00003C38  2F02      7243          move.l    D2,-(A7)
00003C3A  2F2E 0008 7244          move.l    8(A6),-(A7)
00003C3E  42A7      7245          clr.l     -(A7)
00003C40  6100 0B74 7246          bsr       _vsprintf
00003C44  DEFC 000C 7247          add.w     #12,A7
00003C48  2D40 FFFC 7248          move.l    D0,-4(A6)
00003C4C  4282      7249          clr.l     D2
00003C4E  202E FFFC 7250          move.l    -4(A6),D0
00003C52  4CDF 0004 7251          movem.l   (A7)+,D2
00003C56  4E5E      7252          unlk      A6
00003C58  4E75      7253          rts
                    7254   _strcpy:
00003C5A  206F 0004 7255          move.l    (4,A7),A0
00003C5E  226F 0008 7256          move.l    (8,A7),A1
00003C62  2008      7257          move.l    A0,D0
                    7258   strcpy_1:
00003C64  10D9      7259          move.b    (A1)+,(A0)+
00003C66  66FC      7260          bne       strcpy_1
00003C68  4E75      7261          rts
                    7262   ULDIV:
00003C6A  4E56 0000 7263          link    A6,#0
00003C6E  48E7 C000 7264          movem.l D0/D1,-(A7)
00003C72  222E 0008 7265          move.l  8(A6),D1
00003C76  202E 000C 7266          move.l  12(A6),D0
00003C7A  6036      7267          bra.s   ldiv_3
                    7268   LDIV:
00003C7C  4E56 0000 7269          link    A6,#0
00003C80  48E7 C000 7270          movem.l D0/D1,-(A7)
00003C84  222E 0008 7271          move.l  8(A6),D1
00003C88  202E 000C 7272          move.l  12(A6),D0
00003C8C  4A80      7273          tst.l   D0
00003C8E  6A0E      7274          bpl.s   ldiv_1
00003C90  4480      7275          neg.l   D0
00003C92  4A81      7276          tst.l   D1
00003C94  6A14      7277          bpl.s   ldiv_2
00003C96  4481      7278          neg.l   D1
00003C98  612A      7279          bsr.s   dodiv
00003C9A  4481      7280          neg.l   D1
00003C9C  6016      7281          bra.s   ldiv_4
                    7282   ldiv_1:
00003C9E  4A81      7283          tst.l   D1
00003CA0  6A10      7284          bpl.s   ldiv_3
00003CA2  4481      7285          neg.l   D1
00003CA4  611E      7286          bsr.s   dodiv
00003CA6  4480      7287          neg.l   D0
00003CA8  600A      7288          bra.s   ldiv_4
                    7289   ldiv_2:
00003CAA  6118      7290          bsr.s   dodiv
00003CAC  4480      7291          neg.l   D0
00003CAE  4481      7292          neg.l   D1
00003CB0  6002      7293          bra.s   ldiv_4
                    7294   ldiv_3:
00003CB2  6110      7295          bsr.s   dodiv
                    7296   ldiv_4:
00003CB4  2D40 0008 7297          move.l  D0,8(A6)
00003CB8  2D41 000C 7298          move.l  D1,12(A6)
00003CBC  4CDF 0003 7299          movem.l (A7)+,D0/D1
00003CC0  4E5E      7300          unlk    A6
00003CC2  4E75      7301          rts
                    7302   dodiv:
00003CC4  0C81 0000 7303          cmpi.l  #$FFFF,D1
00003CC8  FFFF      
00003CCA  6236      7304          bhi.s   dodiv_2
00003CCC  0C80 0000 7305          cmpi.l  #$FFFF,D0
00003CD0  FFFF      
00003CD2  6210      7306          bhi.s   dodiv_1
00003CD4  80C1      7307          divu    D1,D0
00003CD6  2200      7308          move.l  D0,D1
00003CD8  4241      7309          clr.w   D1
00003CDA  4841      7310          swap    D1
00003CDC  0280 0000 7311          andi.l  #$FFFF,D0
00003CE0  FFFF      
00003CE2  4E75      7312          rts
                    7313   dodiv_1:
00003CE4  48A7 A000 7314          movem.w D0/D2,-(A7)
00003CE8  4240      7315          clr.w   D0
00003CEA  4840      7316          swap    D0
00003CEC  80C1      7317          divu    D1,D0
00003CEE  3400      7318          move.w  D0,D2
00003CF0  301F      7319          move.w  (A7)+,D0
00003CF2  80C1      7320          divu    D1,D0
00003CF4  4840      7321          swap    D0
00003CF6  4281      7322          clr.l   D1
00003CF8  3200      7323          move.w  D0,D1
00003CFA  3002      7324          move.w  D2,D0
00003CFC  4840      7325          swap    D0
00003CFE  341F      7326          move.w  (A7)+,D2
00003D00  4E75      7327          rts
                    7328   dodiv_2:
00003D02  48E7 3800 7329          movem.l D2/D3/D4,-(A7)
00003D06  2401      7330          move.l  D1,D2
00003D08  4242      7331          clr.w   D2
00003D0A  4842      7332          swap    D2
00003D0C  5282      7333          addq.l  #1,D2
00003D0E  2600      7334          move.l  D0,D3
00003D10  2801      7335          move.l  D1,D4
00003D12  2202      7336          move.l  D2,D1
00003D14  61CE      7337          bsr.s   dodiv_1
00003D16  2204      7338          move.l  D4,D1
00003D18  82C2      7339          divu    D2,D1
00003D1A  80C1      7340          divu    D1,D0
00003D1C  0280 0000 7341          andi.l  #$FFFF,D0
00003D20  FFFF      
                    7342   dodiv_3:
00003D22  2204      7343          move.l  D4,D1
00003D24  2404      7344          move.l  D4,D2
00003D26  4842      7345          swap    D2
00003D28  C2C0      7346          mulu    D0,D1
00003D2A  C4C0      7347          mulu    D0,D2
00003D2C  4842      7348          swap    D2
00003D2E  D282      7349          add.l   D2,D1
00003D30  9283      7350          sub.l   D3,D1
00003D32  620A      7351          bhi.s   dodiv_4
00003D34  4481      7352          neg.l   D1
00003D36  B881      7353          cmp.l   D1,D4
00003D38  6208      7354          bhi.s   dodiv_5
00003D3A  5280      7355          addq.l  #1,D0
00003D3C  60E4      7356          bra.s   dodiv_3
                    7357   dodiv_4:
00003D3E  5380      7358          subq.l  #1,D0
00003D40  60E0      7359          bra.s   dodiv_3
                    7360   dodiv_5:
00003D42  4CDF 001C 7361          movem.l (A7)+,D2/D3/D4
00003D46  4E75      7362          rts
                    7363   _putch:
00003D48  4E56 0000 7364          link      A6,#0
00003D4C  48E7 2000 7365          movem.l   D2,-(A7)
00003D50  242E 0008 7366          move.l    8(A6),D2
00003D54  0C82 0000 7367          cmp.l     #10,D2
00003D58  000A      
00003D5A  660A      7368          bne.s     putch_1
00003D5C  4878 000D 7369          pea       13
00003D60  6100 D03C 7370          bsr       __putch
00003D64  584F      7371          addq.w    #4,A7
                    7372   putch_1:
00003D66  2F02      7373          move.l    D2,-(A7)
00003D68  6100 D034 7374          bsr       __putch
00003D6C  584F      7375          addq.w    #4,A7
00003D6E  2002      7376          move.l    D2,D0
00003D70  4CDF 0004 7377          movem.l   (A7)+,D2
00003D74  4E5E      7378          unlk      A6
00003D76  4E75      7379          rts
                    7380   _getch:
00003D78  48E7 2000 7381          movem.l   D2,-(A7)
00003D7C  2439 0B00 7382          move.l    __ungetbuf,D2
00003D80  00C0      
00003D82  2039 0B00 7383          move.l    __ungetbuf,D0
00003D86  00C0      
00003D88  0C80 FFFF 7384          cmp.l     #-1,D0
00003D8C  FFFF      
00003D8E  670C      7385          beq.s     getch_1
00003D90  23FC FFFF 7386          move.l    #-1,__ungetbuf
00003D94  FFFF 0B00 
00003D98  00C0      
00003D9A  6010      7387          bra.s     getch_3
                    7388   getch_1:
00003D9C  6100 D02C 7389          bsr       __getch
00003DA0  2400      7390          move.l    D0,D2
00003DA2  0C80 0000 7391          cmp.l     #13,D0
00003DA6  000D      
00003DA8  6602      7392          bne.s     getch_3
00003DAA  740A      7393          moveq     #10,D2
                    7394   getch_3:
00003DAC  2002      7395          move.l    D2,D0
00003DAE  4CDF 0004 7396          movem.l   (A7)+,D2
00003DB2  4E75      7397          rts
                    7398   _tolower:
00003DB4  4E56 0000 7399          link      A6,#0
00003DB8  48E7 2000 7400          movem.l   D2,-(A7)
00003DBC  242E 0008 7401          move.l    8(A6),D2
00003DC0  0C82 0000 7402          cmp.l     #65,D2
00003DC4  0041      
00003DC6  6D0E      7403          blt.s     tolower_1
00003DC8  0C82 0000 7404          cmp.l     #90,D2
00003DCC  005A      
00003DCE  6E06      7405          bgt.s     tolower_1
00003DD0  84BC 0000 7406          or.l      #32,D2
00003DD4  0020      
                    7407   tolower_1:
00003DD6  2002      7408          move.l    D2,D0
00003DD8  4CDF 0004 7409          movem.l   (A7)+,D2
00003DDC  4E5E      7410          unlk      A6
00003DDE  4E75      7411          rts
                    7412   _sprintf:
00003DE0  4E56 FFFC 7413          link      A6,#-4
00003DE4  48E7 2000 7414          movem.l   D2,-(A7)
00003DE8  41EE 000C 7415          lea       12(A6),A0
00003DEC  5848      7416          addq.w    #4,A0
00003DEE  2408      7417          move.l    A0,D2
00003DF0  2F02      7418          move.l    D2,-(A7)
00003DF2  2F2E 000C 7419          move.l    12(A6),-(A7)
00003DF6  2F2E 0008 7420          move.l    8(A6),-(A7)
00003DFA  6100 09BA 7421          bsr       _vsprintf
00003DFE  DEFC 000C 7422          add.w     #12,A7
00003E02  2D40 FFFC 7423          move.l    D0,-4(A6)
00003E06  4282      7424          clr.l     D2
00003E08  202E FFFC 7425          move.l    -4(A6),D0
00003E0C  4CDF 0004 7426          movem.l   (A7)+,D2
00003E10  4E5E      7427          unlk      A6
00003E12  4E75      7428          rts
                    7429   _memset:
00003E14  206F 0004 7430          move.l    (4,A7),A0
00003E18  202F 0008 7431          move.l    (8,A7),D0
00003E1C  222F 000C 7432          move.l    (12,A7),D1
00003E20  2248      7433          move.l    A0,A1	
                    7434   memset_1:
00003E22  12C0      7435          move.b    D0,(A1)+
00003E24  5341      7436          subq      #1,D1
00003E26  66FA      7437          bne       memset_1
00003E28  2008      7438          move.l    A0,D0
00003E2A  4E75      7439          rts
                    7440   _strcat:
00003E2C  206F 0004 7441          move.l    (4,A7),A0	
00003E30  226F 0008 7442          move.l    (8,A7),A1	
00003E34  2008      7443          move.l    A0,D0		
                    7444   strcat_0:
00003E36  4A18      7445          tst.b     (A0)+
00003E38  66FC      7446          bne       strcat_0
00003E3A  5348      7447          subq      #1,A0
                    7448   strcat_1:
00003E3C  10D9      7449          move.b    (A1)+,(A0)+
00003E3E  66FC      7450          bne       strcat_1
00003E40  4E75      7451          rts
                    7452   _toupper:
00003E42  4E56 0000 7453          link      A6,#0
00003E46  48E7 2000 7454          movem.l   D2,-(A7)
00003E4A  242E 0008 7455          move.l    8(A6),D2
00003E4E  0C82 0000 7456          cmp.l     #97,D2
00003E52  0061      
00003E54  6D0E      7457          blt.s     toupper_1
00003E56  0C82 0000 7458          cmp.l     #122,D2
00003E5A  007A      
00003E5C  6E06      7459          bgt.s     toupper_1
00003E5E  C4BC 0000 7460          and.l     #95,D2
00003E62  005F      
                    7461   toupper_1:
00003E64  2002      7462          move.l    D2,D0
00003E66  4CDF 0004 7463          movem.l   (A7)+,D2
00003E6A  4E5E      7464          unlk      A6
00003E6C  4E75      7465          rts
                    7466   @vsscanf_scanread:
00003E6E  4E56 FFFC 7467          link      A6,#-4
00003E72  48E7 0020 7468          movem.l   A2,-(A7)
00003E76  45F9 0000 7469          lea       @vsscanf_bufx,A2
00003E7A  6936      
00003E7C  4AAE 0008 7470          tst.l     8(A6)
00003E80  6722      7471          beq.s     @vsscanf_scanread_1
00003E82  206E 0008 7472          move.l    8(A6),A0
00003E86  58AE 0008 7473          addq.l    #4,8(A6)
00003E8A  2050      7474          move.l    (A0),A0
00003E8C  1010      7475          move.b    (A0),D0
00003E8E  4880      7476          ext.w     D0
00003E90  48C0      7477          ext.l     D0
00003E92  2D40 FFFC 7478          move.l    D0,-4(A6)
00003E96  6706      7479          beq.s     @vsscanf_scanread_3
00003E98  202E FFFC 7480          move.l    -4(A6),D0
00003E9C  6002      7481          bra.s     @vsscanf_scanread_4
                    7482   @vsscanf_scanread_3:
00003E9E  70FF      7483          moveq     #-1,D0
                    7484   @vsscanf_scanread_4:
00003EA0  6000 0032 7485          bra       @vsscanf_scanread_5
                    7486   @vsscanf_scanread_1:
00003EA4  2052      7487          move.l    (A2),A0
00003EA6  1010      7488          move.b    (A0),D0
00003EA8  6620      7489          bne.s     @vsscanf_scanread_6
00003EAA  4879 0B00 7490          pea       @vsscanf_buf
00003EAE  0546      
00003EB0  6100 1006 7491          bsr       _gets
00003EB4  584F      7492          addq.w    #4,A7
00003EB6  2480      7493          move.l    D0,(A2)
00003EB8  4879 0000 7494          pea       @vsscanf_1
00003EBC  693A      
00003EBE  4879 0B00 7495          pea       @vsscanf_buf
00003EC2  0546      
00003EC4  6100 FF66 7496          bsr       _strcat
00003EC8  504F      7497          addq.w    #8,A7
                    7498   @vsscanf_scanread_6:
00003ECA  2052      7499          move.l    (A2),A0
00003ECC  5292      7500          addq.l    #1,(A2)
00003ECE  1010      7501          move.b    (A0),D0
00003ED0  4880      7502          ext.w     D0
00003ED2  48C0      7503          ext.l     D0
                    7504   @vsscanf_scanread_5:
00003ED4  4CDF 0400 7505          movem.l   (A7)+,A2
00003ED8  4E5E      7506          unlk      A6
00003EDA  4E75      7507          rts
                    7508   @vsscanf_scanputback:
00003EDC  4E56 0000 7509          link      A6,#0
00003EE0  48E7 3000 7510          movem.l   D2/D3,-(A7)
00003EE4  242E 000C 7511          move.l    12(A6),D2
00003EE8  262E 0008 7512          move.l    8(A6),D3
00003EEC  6718      7513          beq.s     @vsscanf_scanputback_1
00003EEE  0C82 FFFF 7514          cmp.l     #-1,D2
00003EF2  FFFF      
00003EF4  670A      7515          beq.s     @vsscanf_scanputback_3
00003EF6  5983      7516          subq.l    #4,D3
00003EF8  2043      7517          move.l    D3,A0
00003EFA  2050      7518          move.l    (A0),A0
00003EFC  1082      7519          move.b    D2,(A0)
00003EFE  6004      7520          bra.s     @vsscanf_scanputback_4
                    7521   @vsscanf_scanputback_3:
00003F00  2043      7522          move.l    D3,A0
00003F02  5390      7523          subq.l    #1,(A0)
                    7524   @vsscanf_scanputback_4:
00003F04  602E      7525          bra.s     @vsscanf_scanputback_6
                    7526   @vsscanf_scanputback_1:
00003F06  41F9 0B00 7527          lea       @vsscanf_buf,A0
00003F0A  0546      
00003F0C  2008      7528          move.l    A0,D0
00003F0E  B0B9 0000 7529          cmp.l     @vsscanf_bufx,D0
00003F12  6936      
00003F14  6610      7530          bne.s     @vsscanf_scanputback_5
00003F16  4239 0B00 7531          clr.b     @vsscanf_buf
00003F1A  0546      
00003F1C  2F02      7532          move.l    D2,-(A7)
00003F1E  6100 100A 7533          bsr       _ungetch
00003F22  584F      7534          addq.w    #4,A7
00003F24  600E      7535          bra.s     @vsscanf_scanputback_6
                    7536   @vsscanf_scanputback_5:
00003F26  53B9 0000 7537          subq.l    #1,@vsscanf_bufx
00003F2A  6936      
00003F2C  2079 0000 7538          move.l    @vsscanf_bufx,A0
00003F30  6936      
00003F32  1082      7539          move.b    D2,(A0)
                    7540   @vsscanf_scanputback_6:
00003F34  2002      7541          move.l    D2,D0
00003F36  4CDF 000C 7542          movem.l   (A7)+,D2/D3
00003F3A  4E5E      7543          unlk      A6
00003F3C  4E75      7544          rts
                    7545   @vsscanf_scanspace:
00003F3E  4E56 0000 7546          link      A6,#0
00003F42  48E7 2000 7547          movem.l   D2,-(A7)
                    7548   @vsscanf_scanspace_1:
00003F46  2F2E 0008 7549          move.l    8(A6),-(A7)
00003F4A  6100 FF22 7550          bsr       @vsscanf_scanread
00003F4E  584F      7551          addq.w    #4,A7
00003F50  2400      7552          move.l    D0,D2
00003F52  206E 000C 7553          move.l    12(A6),A0
00003F56  5290      7554          addq.l    #1,(A0)
00003F58  2042      7555          move.l    D2,A0
00003F5A  43F9 0000 7556          lea       __ctype,A1
00003F5E  693C      
00003F60  1030 9801 7557          move.b    1(A0,A1.L),D0
00003F64  C03C 0010 7558          and.b     #16,D0
00003F68  66DC      7559          bne       @vsscanf_scanspace_1
00003F6A  2002      7560          move.l    D2,D0
00003F6C  4CDF 0004 7561          movem.l   (A7)+,D2
00003F70  4E5E      7562          unlk      A6
00003F72  4E75      7563          rts
                    7564   @vsscanf_scanselect:
00003F74  4E56 0000 7565          link      A6,#0
00003F78  48E7 3F20 7566          movem.l   D2/D3/D4/D5/D6/D7/A2,-(A7)
00003F7C  262E 000C 7567          move.l    12(A6),D3
00003F80  2C2E 0018 7568          move.l    24(A6),D6
00003F84  2E2E 0014 7569          move.l    20(A6),D7
00003F88  2043      7570          move.l    D3,A0
00003F8A  1010      7571          move.b    (A0),D0
00003F8C  4880      7572          ext.w     D0
00003F8E  48C0      7573          ext.l     D0
00003F90  0C80 0000 7574          cmp.l     #94,D0
00003F94  005E      
00003F96  6608      7575          bne.s     @vsscanf_scanselect_1
00003F98  347C 0001 7576          move.w    #1,A2
00003F9C  5283      7577          addq.l    #1,D3
00003F9E  6004      7578          bra.s     @vsscanf_scanselect_2
                    7579   @vsscanf_scanselect_1:
00003FA0  347C 0000 7580          move.w    #0,A2
                    7581   @vsscanf_scanselect_2:
00003FA4  202E 0010 7582          move.l    16(A6),D0
00003FA8  53AE 0010 7583          subq.l    #1,16(A6)
00003FAC  4A80      7584          tst.l     D0
00003FAE  6700 0108 7585          beq       @vsscanf_scanselect_5
00003FB2  2F2E 0008 7586          move.l    8(A6),-(A7)
00003FB6  6100 FEB6 7587          bsr       @vsscanf_scanread
00003FBA  584F      7588          addq.w    #4,A7
00003FBC  2800      7589          move.l    D0,D4
00003FBE  0C84 FFFF 7590          cmp.l     #-1,D4
00003FC2  FFFF      
00003FC4  6604      7591          bne.s     @vsscanf_scanselect_6
00003FC6  6000 00F0 7592          bra       @vsscanf_scanselect_5
                    7593   @vsscanf_scanselect_6:
00003FCA  206E 001C 7594          move.l    28(A6),A0
00003FCE  5290      7595          addq.l    #1,(A0)
00003FD0  4285      7596          clr.l     D5
00003FD2  4282      7597          clr.l     D2
                    7598   @vsscanf_scanselect_8:
00003FD4  2043      7599          move.l    D3,A0
00003FD6  1030 2800 7600          move.b    0(A0,D2.L),D0
00003FDA  4880      7601          ext.w     D0
00003FDC  48C0      7602          ext.l     D0
00003FDE  0C80 0000 7603          cmp.l     #93,D0
00003FE2  005D      
00003FE4  6700 008E 7604          beq       @vsscanf_scanselect_10
00003FE8  4A82      7605          tst.l     D2
00003FEA  6716      7606          beq.s     @vsscanf_scanselect_11
00003FEC  2043      7607          move.l    D3,A0
00003FEE  1030 2800 7608          move.b    0(A0,D2.L),D0
00003FF2  4880      7609          ext.w     D0
00003FF4  48C0      7610          ext.l     D0
00003FF6  0C80 0000 7611          cmp.l     #93,D0
00003FFA  005D      
00003FFC  6604      7612          bne.s     @vsscanf_scanselect_11
00003FFE  6000 0074 7613          bra       @vsscanf_scanselect_10
                    7614   @vsscanf_scanselect_11:
00004002  4A82      7615          tst.l     D2
00004004  6700 0058 7616          beq       @vsscanf_scanselect_15
00004008  2043      7617          move.l    D3,A0
0000400A  1030 2800 7618          move.b    0(A0,D2.L),D0
0000400E  4880      7619          ext.w     D0
00004010  48C0      7620          ext.l     D0
00004012  0C80 0000 7621          cmp.l     #45,D0
00004016  002D      
00004018  6600 0044 7622          bne       @vsscanf_scanselect_15
0000401C  2043      7623          move.l    D3,A0
0000401E  2002      7624          move.l    D2,D0
00004020  5380      7625          subq.l    #1,D0
00004022  2243      7626          move.l    D3,A1
00004024  2F08      7627          move.l    A0,-(A7)
00004026  2042      7628          move.l    D2,A0
00004028  1230 0800 7629          move.b    0(A0,D0.L),D1
0000402C  B230 9801 7630          cmp.b     1(A0,A1.L),D1
00004030  6C00 002C 7631          bge       @vsscanf_scanselect_15
00004034  205F      7632          move.l    (A7)+,A0
00004036  2043      7633          move.l    D3,A0
00004038  2002      7634          move.l    D2,D0
0000403A  5380      7635          subq.l    #1,D0
0000403C  1030 0800 7636          move.b    0(A0,D0.L),D0
00004040  4880      7637          ext.w     D0
00004042  48C0      7638          ext.l     D0
00004044  B880      7639          cmp.l     D0,D4
00004046  6D12      7640          blt.s     @vsscanf_scanselect_17
00004048  2043      7641          move.l    D3,A0
0000404A  2242      7642          move.l    D2,A1
0000404C  1031 8801 7643          move.b    1(A1,A0.L),D0
00004050  4880      7644          ext.w     D0
00004052  48C0      7645          ext.l     D0
00004054  B880      7646          cmp.l     D0,D4
00004056  6E02      7647          bgt.s     @vsscanf_scanselect_17
00004058  601A      7648          bra.s     @vsscanf_scanselect_10
                    7649   @vsscanf_scanselect_17:
0000405A  5282      7650          addq.l    #1,D2
0000405C  6010      7651          bra.s     @vsscanf_scanselect_19
                    7652   @vsscanf_scanselect_15:
0000405E  2043      7653          move.l    D3,A0
00004060  1030 2800 7654          move.b    0(A0,D2.L),D0
00004064  4880      7655          ext.w     D0
00004066  48C0      7656          ext.l     D0
00004068  B880      7657          cmp.l     D0,D4
0000406A  6602      7658          bne.s     @vsscanf_scanselect_19
0000406C  6006      7659          bra.s     @vsscanf_scanselect_10
                    7660   @vsscanf_scanselect_19:
0000406E  5282      7661          addq.l    #1,D2
00004070  6000 FF62 7662          bra       @vsscanf_scanselect_8
                    7663   @vsscanf_scanselect_10:
00004074  4A82      7664          tst.l     D2
00004076  6712      7665          beq.s     @vsscanf_scanselect_23
00004078  2043      7666          move.l    D3,A0
0000407A  1030 2800 7667          move.b    0(A0,D2.L),D0
0000407E  4880      7668          ext.w     D0
00004080  48C0      7669          ext.l     D0
00004082  0C80 0000 7670          cmp.l     #93,D0
00004086  005D      
00004088  6702      7671          beq.s     @vsscanf_scanselect_21
                    7672   @vsscanf_scanselect_23:
0000408A  7A01      7673          moveq     #1,D5
                    7674   @vsscanf_scanselect_21:
0000408C  200A      7675          move.l    A2,D0
0000408E  6712      7676          beq.s     @vsscanf_scanselect_24
00004090  4A85      7677          tst.l     D5
00004092  660C      7678          bne.s     @vsscanf_scanselect_26
00004094  4A87      7679          tst.l     D7
00004096  6606      7680          bne.s     @vsscanf_scanselect_28
00004098  2046      7681          move.l    D6,A0
0000409A  5286      7682          addq.l    #1,D6
0000409C  1084      7683          move.b    D4,(A0)
                    7684   @vsscanf_scanselect_28:
0000409E  6014      7685          bra.s     @vsscanf_scanselect_4
                    7686   @vsscanf_scanselect_26:
000040A0  6016      7687          bra.s     @vsscanf_scanselect_5
                    7688   @vsscanf_scanselect_24:
000040A2  4A85      7689          tst.l     D5
000040A4  670C      7690          beq.s     @vsscanf_scanselect_30
000040A6  4A87      7691          tst.l     D7
000040A8  6606      7692          bne.s     @vsscanf_scanselect_32
000040AA  2046      7693          move.l    D6,A0
000040AC  5286      7694          addq.l    #1,D6
000040AE  1084      7695          move.b    D4,(A0)
                    7696   @vsscanf_scanselect_32:
000040B0  6002      7697          bra.s     @vsscanf_scanselect_4
                    7698   @vsscanf_scanselect_30:
000040B2  6004      7699          bra.s     @vsscanf_scanselect_5
                    7700   @vsscanf_scanselect_4:
000040B4  6000 FEEE 7701          bra       @vsscanf_scanselect_2
                    7702   @vsscanf_scanselect_5:
000040B8  0C84 FFFF 7703          cmp.l     #-1,D4
000040BC  FFFF      
000040BE  6712      7704          beq.s     @vsscanf_scanselect_34
000040C0  2F04      7705          move.l    D4,-(A7)
000040C2  2F2E 0008 7706          move.l    8(A6),-(A7)
000040C6  6100 FE14 7707          bsr       @vsscanf_scanputback
000040CA  504F      7708          addq.w    #8,A7
000040CC  206E 001C 7709          move.l    28(A6),A0
000040D0  5390      7710          subq.l    #1,(A0)
                    7711   @vsscanf_scanselect_34:
000040D2  4A87      7712          tst.l     D7
000040D4  6604      7713          bne.s     @vsscanf_scanselect_36
000040D6  2046      7714          move.l    D6,A0
000040D8  4210      7715          clr.b     (A0)
                    7716   @vsscanf_scanselect_36:
000040DA  5283      7717          addq.l    #1,D3
000040DC  2043      7718          move.l    D3,A0
000040DE  1010      7719          move.b    (A0),D0
000040E0  4880      7720          ext.w     D0
000040E2  48C0      7721          ext.l     D0
000040E4  0C80 0000 7722          cmp.l     #93,D0
000040E8  005D      
000040EA  6702      7723          beq.s     @vsscanf_scanselect_40
000040EC  60EC      7724          bra       @vsscanf_scanselect_36
                    7725   @vsscanf_scanselect_40:
000040EE  5283      7726          addq.l    #1,D3
000040F0  2003      7727          move.l    D3,D0
000040F2  4CDF 04FC 7728          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2
000040F6  4E5E      7729          unlk      A6
000040F8  4E75      7730          rts
                    7731   _scanflush:
000040FA  41F9 0B00 7732          lea       @vsscanf_buf,A0
000040FE  0546      
00004100  23C8 0000 7733          move.l    A0,@vsscanf_bufx
00004104  6936      
00004106  4239 0B00 7734          clr.b     @vsscanf_buf
0000410A  0546      
0000410C  4878 FFFF 7735          pea       -1
00004110  6100 0E18 7736          bsr       _ungetch
00004114  584F      7737          addq.w    #4,A7
00004116  4E75      7738          rts
                    7739   _vsscanf:
00004118  4E56 FF88 7740          link      A6,#-120
0000411C  48E7 3F3C 7741          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
00004120  47F8 3E6E 7742          lea       @vsscanf_scanread,A3
00004124  4AAE 0008 7743          tst.l     8(A6)
00004128  6706      7744          beq.s     vsscanf_1
0000412A  41EE 0008 7745          lea       8(A6),A0
0000412E  6004      7746          bra.s     vsscanf_2
                    7747   vsscanf_1:
00004130  4280      7748          clr.l     D0
00004132  2040      7749          move.l    D0,A0
                    7750   vsscanf_2:
00004134  2A08      7751          move.l    A0,D5
00004136  42AE FFE4 7752          clr.l     -28(A6)
0000413A  4284      7753          clr.l     D4
                    7754   vsscanf_3:
0000413C  206E 000C 7755          move.l    12(A6),A0
00004140  52AE 000C 7756          addq.l    #1,12(A6)
00004144  1010      7757          move.b    (A0),D0
00004146  4880      7758          ext.w     D0
00004148  48C0      7759          ext.l     D0
0000414A  2600      7760          move.l    D0,D3
0000414C  6700 05AC 7761          beq       vsscanf_5
00004150  4286      7762          clr.l     D6
00004152  387C 0000 7763          move.w    #0,A4
00004156  0C83 0000 7764          cmp.l     #32,D3
0000415A  0020      
0000415C  6712      7765          beq.s     vsscanf_8
0000415E  0C83 0000 7766          cmp.l     #9,D3
00004162  0009      
00004164  670A      7767          beq.s     vsscanf_8
00004166  0C83 0000 7768          cmp.l     #10,D3
0000416A  000A      
0000416C  6600 0048 7769          bne       vsscanf_6
                    7770   vsscanf_8:
00004170  2F05      7771          move.l    D5,-(A7)
00004172  4E93      7772          jsr       (A3)
00004174  584F      7773          addq.w    #4,A7
00004176  2400      7774          move.l    D0,D2
00004178  52AE FFE4 7775          addq.l    #1,-28(A6)
0000417C  0C82 FFFF 7776          cmp.l     #-1,D2
00004180  FFFF      
00004182  660E      7777          bne.s     vsscanf_11
00004184  4A84      7778          tst.l     D4
00004186  6704      7779          beq.s     vsscanf_13
00004188  2004      7780          move.l    D4,D0
0000418A  6002      7781          bra.s     vsscanf_14
                    7782   vsscanf_13:
0000418C  70FF      7783          moveq     #-1,D0
                    7784   vsscanf_14:
0000418E  6000 056C 7785          bra       vsscanf_15
                    7786   vsscanf_11:
00004192  2042      7787          move.l    D2,A0
00004194  43F9 0000 7788          lea       __ctype,A1
00004198  693C      
0000419A  1030 9801 7789          move.b    1(A0,A1.L),D0
0000419E  C03C 0010 7790          and.b     #16,D0
000041A2  66CC      7791          bne       vsscanf_8
000041A4  53AE FFE4 7792          subq.l    #1,-28(A6)
000041A8  2F02      7793          move.l    D2,-(A7)
000041AA  2F05      7794          move.l    D5,-(A7)
000041AC  6100 FD2E 7795          bsr       @vsscanf_scanputback
000041B0  504F      7796          addq.w    #8,A7
000041B2  6000 0542 7797          bra       vsscanf_139
                    7798   vsscanf_6:
000041B6  0C83 0000 7799          cmp.l     #37,D3
000041BA  0025      
000041BC  6600 0502 7800          bne       vsscanf_127
000041C0  206E 000C 7801          move.l    12(A6),A0
000041C4  52AE 000C 7802          addq.l    #1,12(A6)
000041C8  1010      7803          move.b    (A0),D0
000041CA  4880      7804          ext.w     D0
000041CC  48C0      7805          ext.l     D0
000041CE  2600      7806          move.l    D0,D3
000041D0  42AE FFEC 7807          clr.l     -20(A6)
000041D4  4286      7808          clr.l     D6
000041D6  42AE FFE8 7809          clr.l     -24(A6)
000041DA  347C 7FFF 7810          move.w    #32767,A2
000041DE  0C83 0000 7811          cmp.l     #42,D3
000041E2  002A      
000041E4  6612      7812          bne.s     vsscanf_18
000041E6  7C01      7813          moveq     #1,D6
000041E8  206E 000C 7814          move.l    12(A6),A0
000041EC  52AE 000C 7815          addq.l    #1,12(A6)
000041F0  1010      7816          move.b    (A0),D0
000041F2  4880      7817          ext.w     D0
000041F4  48C0      7818          ext.l     D0
000041F6  2600      7819          move.l    D0,D3
                    7820   vsscanf_18:
000041F8  2043      7821          move.l    D3,A0
000041FA  43F9 0000 7822          lea       __ctype,A1
000041FE  693C      
00004200  1030 9801 7823          move.b    1(A0,A1.L),D0
00004204  C03C 0004 7824          and.b     #4,D0
00004208  6700 004E 7825          beq       vsscanf_24
0000420C  2003      7826          move.l    D3,D0
0000420E  0480 0000 7827          sub.l     #48,D0
00004212  0030      
00004214  2440      7828          move.l    D0,A2
                    7829   vsscanf_22:
00004216  206E 000C 7830          move.l    12(A6),A0
0000421A  52AE 000C 7831          addq.l    #1,12(A6)
0000421E  1010      7832          move.b    (A0),D0
00004220  4880      7833          ext.w     D0
00004222  48C0      7834          ext.l     D0
00004224  2600      7835          move.l    D0,D3
00004226  2040      7836          move.l    D0,A0
00004228  43F9 0000 7837          lea       __ctype,A1
0000422C  693C      
0000422E  1030 9801 7838          move.b    1(A0,A1.L),D0
00004232  C0BC 0000 7839          and.l     #255,D0
00004236  00FF      
00004238  C0BC 0000 7840          and.l     #4,D0
0000423C  0004      
0000423E  6718      7841          beq.s     vsscanf_24
00004240  70D0      7842          moveq     #-48,D0
00004242  2F0A      7843          move.l    A2,-(A7)
00004244  4878 000A 7844          pea       10
00004248  6100 0BE0 7845          bsr       LMUL
0000424C  2217      7846          move.l    (A7),D1
0000424E  504F      7847          addq.w    #8,A7
00004250  D283      7848          add.l     D3,D1
00004252  D081      7849          add.l     D1,D0
00004254  2440      7850          move.l    D0,A2
00004256  60BE      7851          bra       vsscanf_22
                    7852   vsscanf_24:
00004258  0C83 0000 7853          cmp.l     #108,D3
0000425C  006C      
0000425E  6708      7854          beq.s     vsscanf_27
00004260  0C83 0000 7855          cmp.l     #76,D3
00004264  004C      
00004266  661A      7856          bne.s     vsscanf_25
                    7857   vsscanf_27:
00004268  2D7C 0000 7858          move.l    #1,-24(A6)
0000426C  0001 FFE8 
00004270  206E 000C 7859          move.l    12(A6),A0
00004274  52AE 000C 7860          addq.l    #1,12(A6)
00004278  1010      7861          move.b    (A0),D0
0000427A  4880      7862          ext.w     D0
0000427C  48C0      7863          ext.l     D0
0000427E  2600      7864          move.l    D0,D3
00004280  6020      7865          bra.s     vsscanf_28
                    7866   vsscanf_25:
00004282  0C83 0000 7867          cmp.l     #104,D3
00004286  0068      
00004288  6618      7868          bne.s     vsscanf_28
0000428A  2D7C 0000 7869          move.l    #1,-20(A6)
0000428E  0001 FFEC 
00004292  206E 000C 7870          move.l    12(A6),A0
00004296  52AE 000C 7871          addq.l    #1,12(A6)
0000429A  1010      7872          move.b    (A0),D0
0000429C  4880      7873          ext.w     D0
0000429E  48C0      7874          ext.l     D0
000042A0  2600      7875          move.l    D0,D3
                    7876   vsscanf_28:
000042A2  0C83 0000 7877          cmp.l     #91,D3
000042A6  005B      
000042A8  6600 0036 7878          bne       vsscanf_30
000042AC  4A86      7879          tst.l     D6
000042AE  660A      7880          bne.s     vsscanf_32
000042B0  206E 0010 7881          move.l    16(A6),A0
000042B4  58AE 0010 7882          addq.l    #4,16(A6)
000042B8  2E10      7883          move.l    (A0),D7
                    7884   vsscanf_32:
000042BA  486E FFE4 7885          pea       -28(A6)
000042BE  2F07      7886          move.l    D7,-(A7)
000042C0  2F06      7887          move.l    D6,-(A7)
000042C2  2F0A      7888          move.l    A2,-(A7)
000042C4  2F2E 000C 7889          move.l    12(A6),-(A7)
000042C8  2F05      7890          move.l    D5,-(A7)
000042CA  6100 FCA8 7891          bsr       @vsscanf_scanselect
000042CE  DEFC 0018 7892          add.w     #24,A7
000042D2  2D40 000C 7893          move.l    D0,12(A6)
000042D6  4A86      7894          tst.l     D6
000042D8  6602      7895          bne.s     vsscanf_34
000042DA  5284      7896          addq.l    #1,D4
                    7897   vsscanf_34:
000042DC  6000 0418 7898          bra       vsscanf_139
                    7899   vsscanf_30:
000042E0  0C83 0000 7900          cmp.l     #110,D3
000042E4  006E      
000042E6  661A      7901          bne.s     vsscanf_36
000042E8  4A86      7902          tst.l     D6
000042EA  6612      7903          bne.s     vsscanf_38
000042EC  206E 0010 7904          move.l    16(A6),A0
000042F0  58AE 0010 7905          addq.l    #4,16(A6)
000042F4  2E10      7906          move.l    (A0),D7
000042F6  2047      7907          move.l    D7,A0
000042F8  20AE FFE4 7908          move.l    -28(A6),(A0)
000042FC  5284      7909          addq.l    #1,D4
                    7910   vsscanf_38:
000042FE  6000 03F6 7911          bra       vsscanf_139
                    7912   vsscanf_36:
00004302  0C83 0000 7913          cmp.l     #115,D3
00004306  0073      
00004308  6600 00AC 7914          bne       vsscanf_40
0000430C  486E FFE4 7915          pea       -28(A6)
00004310  2F05      7916          move.l    D5,-(A7)
00004312  6100 FC2A 7917          bsr       @vsscanf_scanspace
00004316  504F      7918          addq.w    #8,A7
00004318  2400      7919          move.l    D0,D2
0000431A  4A86      7920          tst.l     D6
0000431C  660A      7921          bne.s     vsscanf_42
0000431E  206E 0010 7922          move.l    16(A6),A0
00004322  58AE 0010 7923          addq.l    #4,16(A6)
00004326  2E10      7924          move.l    (A0),D7
                    7925   vsscanf_42:
00004328  52AE FFE4 7926          addq.l    #1,-28(A6)
                    7927   vsscanf_44:
0000432C  200A      7928          move.l    A2,D0
0000432E  534A      7929          subq.w    #1,A2
00004330  4A80      7930          tst.l     D0
00004332  6700 0038 7931          beq       vsscanf_46
00004336  2042      7932          move.l    D2,A0
00004338  43F9 0000 7933          lea       __ctype,A1
0000433C  693C      
0000433E  1030 9801 7934          move.b    1(A0,A1.L),D0
00004342  C03C 0010 7935          and.b     #16,D0
00004346  6624      7936          bne.s     vsscanf_46
00004348  0C82 FFFF 7937          cmp.l     #-1,D2
0000434C  FFFF      
0000434E  671C      7938          beq.s     vsscanf_46
00004350  387C 0001 7939          move.w    #1,A4
00004354  4A86      7940          tst.l     D6
00004356  6606      7941          bne.s     vsscanf_47
00004358  2047      7942          move.l    D7,A0
0000435A  5287      7943          addq.l    #1,D7
0000435C  1082      7944          move.b    D2,(A0)
                    7945   vsscanf_47:
0000435E  2F05      7946          move.l    D5,-(A7)
00004360  4E93      7947          jsr       (A3)
00004362  584F      7948          addq.w    #4,A7
00004364  2400      7949          move.l    D0,D2
00004366  52AE FFE4 7950          addq.l    #1,-28(A6)
0000436A  60C0      7951          bra       vsscanf_44
                    7952   vsscanf_46:
0000436C  4A86      7953          tst.l     D6
0000436E  660A      7954          bne.s     vsscanf_51
00004370  2047      7955          move.l    D7,A0
00004372  4210      7956          clr.b     (A0)
00004374  200C      7957          move.l    A4,D0
00004376  6702      7958          beq.s     vsscanf_51
00004378  5284      7959          addq.l    #1,D4
                    7960   vsscanf_51:
0000437A  0C82 FFFF 7961          cmp.l     #-1,D2
0000437E  FFFF      
00004380  6708      7962          beq.s     vsscanf_55
00004382  4A86      7963          tst.l     D6
00004384  661E      7964          bne.s     vsscanf_53
00004386  200C      7965          move.l    A4,D0
00004388  661A      7966          bne.s     vsscanf_53
                    7967   vsscanf_55:
0000438A  4A84      7968          tst.l     D4
0000438C  6704      7969          beq.s     vsscanf_56
0000438E  2004      7970          move.l    D4,D0
00004390  600E      7971          bra.s     vsscanf_59
                    7972   vsscanf_56:
00004392  0C82 FFFF 7973          cmp.l     #-1,D2
00004396  FFFF      
00004398  6604      7974          bne.s     vsscanf_58
0000439A  70FF      7975          moveq     #-1,D0
0000439C  6002      7976          bra.s     vsscanf_59
                    7977   vsscanf_58:
0000439E  2004      7978          move.l    D4,D0
                    7979   vsscanf_59:
000043A0  6000 035A 7980          bra       vsscanf_15
                    7981   vsscanf_53:
000043A4  53AE FFE4 7982          subq.l    #1,-28(A6)
000043A8  2F02      7983          move.l    D2,-(A7)
000043AA  2F05      7984          move.l    D5,-(A7)
000043AC  6100 FB2E 7985          bsr       @vsscanf_scanputback
000043B0  504F      7986          addq.w    #8,A7
000043B2  6000 0342 7987          bra       vsscanf_139
                    7988   vsscanf_40:
000043B6  0C83 0000 7989          cmp.l     #99,D3
000043BA  0063      
000043BC  6600 008E 7990          bne       vsscanf_60
000043C0  4A86      7991          tst.l     D6
000043C2  660A      7992          bne.s     vsscanf_62
000043C4  206E 0010 7993          move.l    16(A6),A0
000043C8  58AE 0010 7994          addq.l    #4,16(A6)
000043CC  2E10      7995          move.l    (A0),D7
                    7996   vsscanf_62:
000043CE  2F05      7997          move.l    D5,-(A7)
000043D0  4E93      7998          jsr       (A3)
000043D2  584F      7999          addq.w    #4,A7
000043D4  2400      8000          move.l    D0,D2
000043D6  52AE FFE4 8001          addq.l    #1,-28(A6)
000043DA  200A      8002          move.l    A2,D0
000043DC  0C80 0000 8003          cmp.l     #32767,D0
000043E0  7FFF      
000043E2  6604      8004          bne.s     vsscanf_64
000043E4  347C 0001 8005          move.w    #1,A2
                    8006   vsscanf_64:
000043E8  0C82 FFFF 8007          cmp.l     #-1,D2
000043EC  FFFF      
000043EE  6606      8008          bne.s     vsscanf_66
000043F0  4A86      8009          tst.l     D6
000043F2  6602      8010          bne.s     vsscanf_66
000043F4  5384      8011          subq.l    #1,D4
                    8012   vsscanf_66:
000043F6  200A      8013          move.l    A2,D0
000043F8  534A      8014          subq.w    #1,A2
000043FA  4A80      8015          tst.l     D0
000043FC  6720      8016          beq.s     vsscanf_70
000043FE  0C82 FFFF 8017          cmp.l     #-1,D2
00004402  FFFF      
00004404  6718      8018          beq.s     vsscanf_70
00004406  4A86      8019          tst.l     D6
00004408  6606      8020          bne.s     vsscanf_71
0000440A  2047      8021          move.l    D7,A0
0000440C  5287      8022          addq.l    #1,D7
0000440E  1082      8023          move.b    D2,(A0)
                    8024   vsscanf_71:
00004410  2F05      8025          move.l    D5,-(A7)
00004412  4E93      8026          jsr       (A3)
00004414  584F      8027          addq.w    #4,A7
00004416  2400      8028          move.l    D0,D2
00004418  52AE FFE4 8029          addq.l    #1,-28(A6)
0000441C  60D8      8030          bra       vsscanf_66
                    8031   vsscanf_70:
0000441E  0C82 FFFF 8032          cmp.l     #-1,D2
00004422  FFFF      
00004424  660E      8033          bne.s     vsscanf_73
00004426  4A84      8034          tst.l     D4
00004428  6704      8035          beq.s     vsscanf_75
0000442A  2004      8036          move.l    D4,D0
0000442C  6002      8037          bra.s     vsscanf_76
                    8038   vsscanf_75:
0000442E  70FF      8039          moveq     #-1,D0
                    8040   vsscanf_76:
00004430  6000 02CA 8041          bra       vsscanf_15
                    8042   vsscanf_73:
00004434  4A86      8043          tst.l     D6
00004436  6602      8044          bne.s     vsscanf_77
00004438  5284      8045          addq.l    #1,D4
                    8046   vsscanf_77:
0000443A  53AE FFE4 8047          subq.l    #1,-28(A6)
0000443E  2F02      8048          move.l    D2,-(A7)
00004440  2F05      8049          move.l    D5,-(A7)
00004442  6100 FA98 8050          bsr       @vsscanf_scanputback
00004446  504F      8051          addq.w    #8,A7
00004448  6000 02AC 8052          bra       vsscanf_139
                    8053   vsscanf_60:
0000444C  0C83 0000 8054          cmp.l     #105,D3
00004450  0069      
00004452  6600 0060 8055          bne       vsscanf_82
00004456  486E FFE4 8056          pea       -28(A6)
0000445A  2F05      8057          move.l    D5,-(A7)
0000445C  6100 FAE0 8058          bsr       @vsscanf_scanspace
00004460  504F      8059          addq.w    #8,A7
00004462  2400      8060          move.l    D0,D2
00004464  0C82 0000 8061          cmp.l     #48,D2
00004468  0030      
0000446A  6600 0038 8062          bne       vsscanf_81
0000446E  387C 0001 8063          move.w    #1,A4
00004472  2F05      8064          move.l    D5,-(A7)
00004474  4E93      8065          jsr       (A3)
00004476  584F      8066          addq.w    #4,A7
00004478  2400      8067          move.l    D0,D2
0000447A  2F02      8068          move.l    D2,-(A7)
0000447C  6100 F936 8069          bsr       _tolower
00004480  584F      8070          addq.w    #4,A7
00004482  0C80 0000 8071          cmp.l     #120,D0
00004486  0078      
00004488  6604      8072          bne.s     vsscanf_83
0000448A  7678      8073          moveq     #120,D3
0000448C  6010      8074          bra.s     vsscanf_84
                    8075   vsscanf_83:
0000448E  53AE FFE4 8076          subq.l    #1,-28(A6)
00004492  2F02      8077          move.l    D2,-(A7)
00004494  2F05      8078          move.l    D5,-(A7)
00004496  6100 FA44 8079          bsr       @vsscanf_scanputback
0000449A  504F      8080          addq.w    #8,A7
0000449C  766F      8081          moveq     #111,D3
                    8082   vsscanf_84:
0000449E  52AE FFE4 8083          addq.l    #1,-28(A6)
000044A2  6010      8084          bra.s     vsscanf_82
                    8085   vsscanf_81:
000044A4  53AE FFE4 8086          subq.l    #1,-28(A6)
000044A8  2F02      8087          move.l    D2,-(A7)
000044AA  2F05      8088          move.l    D5,-(A7)
000044AC  6100 FA2E 8089          bsr       @vsscanf_scanputback
000044B0  504F      8090          addq.w    #8,A7
000044B2  7664      8091          moveq     #100,D3
                    8092   vsscanf_82:
000044B4  0C83 0000 8093          cmp.l     #100,D3
000044B8  0064      
000044BA  671A      8094          beq.s     vsscanf_87
000044BC  0C83 0000 8095          cmp.l     #117,D3
000044C0  0075      
000044C2  6712      8096          beq.s     vsscanf_87
000044C4  0C83 0000 8097          cmp.l     #120,D3
000044C8  0078      
000044CA  670A      8098          beq.s     vsscanf_87
000044CC  0C83 0000 8099          cmp.l     #111,D3
000044D0  006F      
000044D2  6600 01A4 8100          bne       vsscanf_85
                    8101   vsscanf_87:
000044D6  486E FFE4 8102          pea       -28(A6)
000044DA  2F05      8103          move.l    D5,-(A7)
000044DC  6100 FA60 8104          bsr       @vsscanf_scanspace
000044E0  504F      8105          addq.w    #8,A7
000044E2  2400      8106          move.l    D0,D2
000044E4  2D7C 0000 8107          move.l    #10,-4(A6)
000044E8  000A FFFC 
000044EC  0C83 0000 8108          cmp.l     #120,D3
000044F0  0078      
000044F2  6608      8109          bne.s     vsscanf_88
000044F4  2D7C 0000 8110          move.l    #16,-4(A6)
000044F8  0010 FFFC 
                    8111   vsscanf_88:
000044FC  0C83 0000 8112          cmp.l     #111,D3
00004500  006F      
00004502  6608      8113          bne.s     vsscanf_90
00004504  2D7C 0000 8114          move.l    #8,-4(A6)
00004508  0008 FFFC 
                    8115   vsscanf_90:
0000450C  4A86      8116          tst.l     D6
0000450E  660A      8117          bne.s     vsscanf_92
00004510  206E 0010 8118          move.l    16(A6),A0
00004514  58AE 0010 8119          addq.l    #4,16(A6)
00004518  2E10      8120          move.l    (A0),D7
                    8121   vsscanf_92:
0000451A  42AE FFE0 8122          clr.l     -32(A6)
0000451E  52AE FFE4 8123          addq.l    #1,-28(A6)
00004522  0C83 0000 8124          cmp.l     #117,D3
00004526  0075      
00004528  6720      8125          beq.s     vsscanf_94
0000452A  0C82 0000 8126          cmp.l     #45,D2
0000452E  002D      
00004530  6618      8127          bne.s     vsscanf_94
00004532  2F05      8128          move.l    D5,-(A7)
00004534  4E93      8129          jsr       (A3)
00004536  584F      8130          addq.w    #4,A7
00004538  2400      8131          move.l    D0,D2
0000453A  52AE FFE4 8132          addq.l    #1,-28(A6)
0000453E  2D7C 0000 8133          move.l    #1,-32(A6)
00004542  0001 FFE0 
00004546  387C 0001 8134          move.w    #1,A4
                    8135   vsscanf_94:
0000454A  3A7C 0000 8136          move.w    #0,A5
0000454E  0C82 FFFF 8137          cmp.l     #-1,D2
00004552  FFFF      
00004554  660E      8138          bne.s     vsscanf_96
00004556  4A84      8139          tst.l     D4
00004558  6704      8140          beq.s     vsscanf_98
0000455A  2004      8141          move.l    D4,D0
0000455C  6002      8142          bra.s     vsscanf_99
                    8143   vsscanf_98:
0000455E  70FF      8144          moveq     #-1,D0
                    8145   vsscanf_99:
00004560  6000 019A 8146          bra       vsscanf_15
                    8147   vsscanf_96:
00004564  200A      8148          move.l    A2,D0
00004566  534A      8149          subq.w    #1,A2
00004568  4A80      8150          tst.l     D0
0000456A  6700 0090 8151          beq       vsscanf_102
0000456E  0C83 0000 8152          cmp.l     #120,D3
00004572  0078      
00004574  6620      8153          bne.s     vsscanf_104
00004576  2F02      8154          move.l    D2,-(A7)
00004578  6100 F8C8 8155          bsr       _toupper
0000457C  584F      8156          addq.w    #4,A7
0000457E  0C80 0000 8157          cmp.l     #65,D0
00004582  0041      
00004584  6D10      8158          blt.s     vsscanf_104
00004586  2F02      8159          move.l    D2,-(A7)
00004588  6100 F8B8 8160          bsr       _toupper
0000458C  584F      8161          addq.w    #4,A7
0000458E  0C80 0000 8162          cmp.l     #70,D0
00004592  0046      
00004594  6F14      8163          ble.s     vsscanf_103
                    8164   vsscanf_104:
00004596  2042      8165          move.l    D2,A0
00004598  43F9 0000 8166          lea       __ctype,A1
0000459C  693C      
0000459E  1030 9801 8167          move.b    1(A0,A1.L),D0
000045A2  C03C 0004 8168          and.b     #4,D0
000045A6  6700 0054 8169          beq       vsscanf_102
                    8170   vsscanf_103:
000045AA  2042      8171          move.l    D2,A0
000045AC  43F9 0000 8172          lea       __ctype,A1
000045B0  693C      
000045B2  1030 9801 8173          move.b    1(A0,A1.L),D0
000045B6  C03C 0004 8174          and.b     #4,D0
000045BA  6614      8175          bne.s     vsscanf_105
000045BC  70F9      8176          moveq     #-7,D0
000045BE  2F00      8177          move.l    D0,-(A7)
000045C0  2F02      8178          move.l    D2,-(A7)
000045C2  6100 F87E 8179          bsr       _toupper
000045C6  584F      8180          addq.w    #4,A7
000045C8  2200      8181          move.l    D0,D1
000045CA  201F      8182          move.l    (A7)+,D0
000045CC  D081      8183          add.l     D1,D0
000045CE  2400      8184          move.l    D0,D2
                    8185   vsscanf_105:
000045D0  2F0D      8186          move.l    A5,-(A7)
000045D2  2F2E FFFC 8187          move.l    -4(A6),-(A7)
000045D6  6100 0852 8188          bsr       LMUL
000045DA  2017      8189          move.l    (A7),D0
000045DC  504F      8190          addq.w    #8,A7
000045DE  D082      8191          add.l     D2,D0
000045E0  0480 0000 8192          sub.l     #48,D0
000045E4  0030      
000045E6  2A40      8193          move.l    D0,A5
000045E8  2F05      8194          move.l    D5,-(A7)
000045EA  4E93      8195          jsr       (A3)
000045EC  584F      8196          addq.w    #4,A7
000045EE  2400      8197          move.l    D0,D2
000045F0  52AE FFE4 8198          addq.l    #1,-28(A6)
000045F4  387C 0001 8199          move.w    #1,A4
000045F8  6000 FF6A 8200          bra       vsscanf_96
                    8201   vsscanf_102:
000045FC  0C82 FFFF 8202          cmp.l     #-1,D2
00004600  FFFF      
00004602  671A      8203          beq.s     vsscanf_107
00004604  2F02      8204          move.l    D2,-(A7)
00004606  2F05      8205          move.l    D5,-(A7)
00004608  6100 F8D2 8206          bsr       @vsscanf_scanputback
0000460C  504F      8207          addq.w    #8,A7
0000460E  53AE FFE4 8208          subq.l    #1,-28(A6)
00004612  200C      8209          move.l    A4,D0
00004614  6606      8210          bne.s     vsscanf_109
00004616  2004      8211          move.l    D4,D0
00004618  6000 00E2 8212          bra       vsscanf_15
                    8213   vsscanf_109:
0000461C  6012      8214          bra.s     vsscanf_111
                    8215   vsscanf_107:
0000461E  200C      8216          move.l    A4,D0
00004620  660E      8217          bne.s     vsscanf_111
00004622  4A84      8218          tst.l     D4
00004624  6704      8219          beq.s     vsscanf_113
00004626  2004      8220          move.l    D4,D0
00004628  6002      8221          bra.s     vsscanf_114
                    8222   vsscanf_113:
0000462A  70FF      8223          moveq     #-1,D0
                    8224   vsscanf_114:
0000462C  6000 00CE 8225          bra       vsscanf_15
                    8226   vsscanf_111:
00004630  4AAE FFE0 8227          tst.l     -32(A6)
00004634  6706      8228          beq.s     vsscanf_115
00004636  200D      8229          move.l    A5,D0
00004638  4480      8230          neg.l     D0
0000463A  2A40      8231          move.l    D0,A5
                    8232   vsscanf_115:
0000463C  4A86      8233          tst.l     D6
0000463E  661E      8234          bne.s     vsscanf_117
00004640  4AAE FFE8 8235          tst.l     -24(A6)
00004644  6706      8236          beq.s     vsscanf_119
00004646  2047      8237          move.l    D7,A0
00004648  208D      8238          move.l    A5,(A0)
0000464A  6010      8239          bra.s     vsscanf_122
                    8240   vsscanf_119:
0000464C  4AAE FFEC 8241          tst.l     -20(A6)
00004650  6706      8242          beq.s     vsscanf_121
00004652  2047      8243          move.l    D7,A0
00004654  308D      8244          move.w    A5,(A0)
00004656  6004      8245          bra.s     vsscanf_122
                    8246   vsscanf_121:
00004658  2047      8247          move.l    D7,A0
0000465A  208D      8248          move.l    A5,(A0)
                    8249   vsscanf_122:
0000465C  5284      8250          addq.l    #1,D4
                    8251   vsscanf_117:
0000465E  0C82 FFFF 8252          cmp.l     #-1,D2
00004662  FFFF      
00004664  660E      8253          bne.s     vsscanf_123
00004666  4A84      8254          tst.l     D4
00004668  6704      8255          beq.s     vsscanf_125
0000466A  2004      8256          move.l    D4,D0
0000466C  6002      8257          bra.s     vsscanf_126
                    8258   vsscanf_125:
0000466E  70FF      8259          moveq     #-1,D0
                    8260   vsscanf_126:
00004670  6000 008A 8261          bra       vsscanf_15
                    8262   vsscanf_123:
00004674  6000 0080 8263          bra       vsscanf_139
                    8264   vsscanf_85:
00004678  0C83 0000 8265          cmp.l     #37,D3
0000467C  0025      
0000467E  6600 0040 8266          bne       vsscanf_127
00004682  2F05      8267          move.l    D5,-(A7)
00004684  4E93      8268          jsr       (A3)
00004686  584F      8269          addq.w    #4,A7
00004688  2400      8270          move.l    D0,D2
0000468A  0C82 FFFF 8271          cmp.l     #-1,D2
0000468E  FFFF      
00004690  660E      8272          bne.s     vsscanf_129
00004692  4A84      8273          tst.l     D4
00004694  6704      8274          beq.s     vsscanf_131
00004696  2004      8275          move.l    D4,D0
00004698  6002      8276          bra.s     vsscanf_132
                    8277   vsscanf_131:
0000469A  70FF      8278          moveq     #-1,D0
                    8279   vsscanf_132:
0000469C  6000 005E 8280          bra       vsscanf_15
                    8281   vsscanf_129:
000046A0  52AE FFE4 8282          addq.l    #1,-28(A6)
000046A4  B483      8283          cmp.l     D3,D2
000046A6  6714      8284          beq.s     vsscanf_133
000046A8  2F02      8285          move.l    D2,-(A7)
000046AA  2F05      8286          move.l    D5,-(A7)
000046AC  6100 F82E 8287          bsr       @vsscanf_scanputback
000046B0  504F      8288          addq.w    #8,A7
000046B2  53AE FFE4 8289          subq.l    #1,-28(A6)
000046B6  2004      8290          move.l    D4,D0
000046B8  6000 0042 8291          bra       vsscanf_15
                    8292   vsscanf_133:
000046BC  6000 0038 8293          bra       vsscanf_139
                    8294   vsscanf_127:
000046C0  2F05      8295          move.l    D5,-(A7)
000046C2  4E93      8296          jsr       (A3)
000046C4  584F      8297          addq.w    #4,A7
000046C6  2400      8298          move.l    D0,D2
000046C8  52AE FFE4 8299          addq.l    #1,-28(A6)
000046CC  0C82 FFFF 8300          cmp.l     #-1,D2
000046D0  FFFF      
000046D2  660C      8301          bne.s     vsscanf_135
000046D4  4A84      8302          tst.l     D4
000046D6  6704      8303          beq.s     vsscanf_137
000046D8  2004      8304          move.l    D4,D0
000046DA  6002      8305          bra.s     vsscanf_138
                    8306   vsscanf_137:
000046DC  70FF      8307          moveq     #-1,D0
                    8308   vsscanf_138:
000046DE  601C      8309          bra.s     vsscanf_15
                    8310   vsscanf_135:
000046E0  B483      8311          cmp.l     D3,D2
000046E2  6712      8312          beq.s     vsscanf_139
000046E4  2F02      8313          move.l    D2,-(A7)
000046E6  2F05      8314          move.l    D5,-(A7)
000046E8  6100 F7F2 8315          bsr       @vsscanf_scanputback
000046EC  504F      8316          addq.w    #8,A7
000046EE  53AE FFE4 8317          subq.l    #1,-28(A6)
000046F2  2004      8318          move.l    D4,D0
000046F4  6006      8319          bra.s     vsscanf_15
                    8320   vsscanf_139:
000046F6  6000 FA44 8321          bra       vsscanf_3
                    8322   vsscanf_5:
000046FA  2004      8323          move.l    D4,D0
                    8324   vsscanf_15:
000046FC  4CDF 3CFC 8325          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
00004700  4E5E      8326          unlk      A6
00004702  4E75      8327          rts
                    8328   @vsprintf_copy:
00004704  4E56 0000 8329          link      A6,#0
00004708  206E 0008 8330          move.l    8(A6),A0
0000470C  4A90      8331          tst.l     (A0)
0000470E  6710      8332          beq.s     @vsprintf_copy_1
00004710  202E 000C 8333          move.l    12(A6),D0
00004714  206E 0008 8334          move.l    8(A6),A0
00004718  2250      8335          move.l    (A0),A1
0000471A  5290      8336          addq.l    #1,(A0)
0000471C  1280      8337          move.b    D0,(A1)
0000471E  600A      8338          bra.s     @vsprintf_copy_2
                    8339   @vsprintf_copy_1:
00004720  2F2E 000C 8340          move.l    12(A6),-(A7)
00004724  6100 F622 8341          bsr       _putch
00004728  584F      8342          addq.w    #4,A7
                    8343   @vsprintf_copy_2:
0000472A  4E5E      8344          unlk      A6
0000472C  4E75      8345          rts
                    8346   @vsprintf_getval:
0000472E  4E56 0000 8347          link      A6,#0
00004732  48E7 3000 8348          movem.l   D2/D3,-(A7)
00004736  242E 0008 8349          move.l    8(A6),D2
0000473A  4283      8350          clr.l     D3
0000473C  2042      8351          move.l    D2,A0
0000473E  2050      8352          move.l    (A0),A0
00004740  1010      8353          move.b    (A0),D0
00004742  4880      8354          ext.w     D0
00004744  48C0      8355          ext.l     D0
00004746  0C80 0000 8356          cmp.l     #42,D0
0000474A  002A      
0000474C  6612      8357          bne.s     @vsprintf_getval_1
0000474E  206E 000C 8358          move.l    12(A6),A0
00004752  2250      8359          move.l    (A0),A1
00004754  5890      8360          addq.l    #4,(A0)
00004756  2611      8361          move.l    (A1),D3
00004758  2042      8362          move.l    D2,A0
0000475A  5290      8363          addq.l    #1,(A0)
0000475C  6000 004E 8364          bra       @vsprintf_getval_5
                    8365   @vsprintf_getval_1:
00004760  2042      8366          move.l    D2,A0
00004762  2050      8367          move.l    (A0),A0
00004764  1010      8368          move.b    (A0),D0
00004766  4880      8369          ext.w     D0
00004768  48C0      8370          ext.l     D0
0000476A  0C80 0000 8371          cmp.l     #48,D0
0000476E  0030      
00004770  6D00 003A 8372          blt       @vsprintf_getval_5
00004774  2042      8373          move.l    D2,A0
00004776  2050      8374          move.l    (A0),A0
00004778  1010      8375          move.b    (A0),D0
0000477A  4880      8376          ext.w     D0
0000477C  48C0      8377          ext.l     D0
0000477E  0C80 0000 8378          cmp.l     #57,D0
00004782  0039      
00004784  6E26      8379          bgt.s     @vsprintf_getval_5
00004786  2F03      8380          move.l    D3,-(A7)
00004788  4878 000A 8381          pea       10
0000478C  6100 069C 8382          bsr       LMUL
00004790  2017      8383          move.l    (A7),D0
00004792  504F      8384          addq.w    #8,A7
00004794  2042      8385          move.l    D2,A0
00004796  2250      8386          move.l    (A0),A1
00004798  5290      8387          addq.l    #1,(A0)
0000479A  1211      8388          move.b    (A1),D1
0000479C  4881      8389          ext.w     D1
0000479E  48C1      8390          ext.l     D1
000047A0  D081      8391          add.l     D1,D0
000047A2  0480 0000 8392          sub.l     #48,D0
000047A6  0030      
000047A8  2600      8393          move.l    D0,D3
000047AA  60B4      8394          bra       @vsprintf_getval_1
                    8395   @vsprintf_getval_5:
000047AC  2003      8396          move.l    D3,D0
000047AE  4CDF 000C 8397          movem.l   (A7)+,D2/D3
000047B2  4E5E      8398          unlk      A6
000047B4  4E75      8399          rts
                    8400   _vsprintf:
000047B6  4E56 FFCC 8401          link      A6,#-52
000047BA  48E7 3F3C 8402          movem.l   D2/D3/D4/D5/D6/D7/A2/A3/A4/A5,-(A7)
000047BE  45EE 0008 8403          lea       8(A6),A2
000047C2  47F8 4704 8404          lea       @vsprintf_copy,A3
000047C6  49F9 0000 8405          lea       _ultoa,A4
000047CA  5034      
000047CC  4286      8406          clr.l     D6
                    8407   vsprintf_1:
000047CE  206E 000C 8408          move.l    12(A6),A0
000047D2  4A10      8409          tst.b     (A0)
000047D4  6700 0624 8410          beq       vsprintf_3
000047D8  206E 000C 8411          move.l    12(A6),A0
000047DC  1010      8412          move.b    (A0),D0
000047DE  4880      8413          ext.w     D0
000047E0  48C0      8414          ext.l     D0
000047E2  0C80 0000 8415          cmp.l     #37,D0
000047E6  0025      
000047E8  671C      8416          beq.s     vsprintf_4
000047EA  206E 000C 8417          move.l    12(A6),A0
000047EE  52AE 000C 8418          addq.l    #1,12(A6)
000047F2  1210      8419          move.b    (A0),D1
000047F4  4881      8420          ext.w     D1
000047F6  48C1      8421          ext.l     D1
000047F8  2F01      8422          move.l    D1,-(A7)
000047FA  2F0A      8423          move.l    A2,-(A7)
000047FC  4E93      8424          jsr       (A3)
000047FE  504F      8425          addq.w    #8,A7
00004800  5286      8426          addq.l    #1,D6
00004802  6000 05F2 8427          bra       vsprintf_2
                    8428   vsprintf_4:
00004806  52AE 000C 8429          addq.l    #1,12(A6)
0000480A  422E FFD3 8430          clr.b     -45(A6)
0000480E  422E FFD2 8431          clr.b     -46(A6)
00004812  422E FFD0 8432          clr.b     -48(A6)
00004816  422E FFCF 8433          clr.b     -49(A6)
0000481A  422E FFCE 8434          clr.b     -50(A6)
0000481E  422E FFCD 8435          clr.b     -51(A6)
00004822  42AE FFFC 8436          clr.l     -4(A6)
00004826  7AFF      8437          moveq     #-1,D5
00004828  41EE FFDC 8438          lea       -36(A6),A0
0000482C  2608      8439          move.l    A0,D3
0000482E  2408      8440          move.l    A0,D2
                    8441   vsprintf_6:
00004830  206E 000C 8442          move.l    12(A6),A0
00004834  1010      8443          move.b    (A0),D0
00004836  4880      8444          ext.w     D0
00004838  48C0      8445          ext.l     D0
0000483A  0C80 0000 8446          cmp.l     #43,D0
0000483E  002B      
00004840  6730      8447          beq.s     vsprintf_12
00004842  6E18      8448          bgt.s     vsprintf_15
00004844  0C80 0000 8449          cmp.l     #35,D0
00004848  0023      
0000484A  6700 003E 8450          beq       vsprintf_14
0000484E  6E00 0046 8451          bgt       vsprintf_9
00004852  0C80 0000 8452          cmp.l     #32,D0
00004856  0020      
00004858  6724      8453          beq.s     vsprintf_13
0000485A  603A      8454          bra.s     vsprintf_9
                    8455   vsprintf_15:
0000485C  0C80 0000 8456          cmp.l     #45,D0
00004860  002D      
00004862  6702      8457          beq.s     vsprintf_11
00004864  6030      8458          bra.s     vsprintf_9
                    8459   vsprintf_11:
00004866  1D7C 0001 8460          move.b    #1,-51(A6)
0000486A  FFCD      
0000486C  52AE 000C 8461          addq.l    #1,12(A6)
00004870  6026      8462          bra.s     vsprintf_7
                    8463   vsprintf_12:
00004872  1D7C 0001 8464          move.b    #1,-50(A6)
00004876  FFCE      
00004878  52AE 000C 8465          addq.l    #1,12(A6)
0000487C  601A      8466          bra.s     vsprintf_7
                    8467   vsprintf_13:
0000487E  1D7C 0001 8468          move.b    #1,-49(A6)
00004882  FFCF      
00004884  52AE 000C 8469          addq.l    #1,12(A6)
00004888  600E      8470          bra.s     vsprintf_7
                    8471   vsprintf_14:
0000488A  1D7C 0001 8472          move.b    #1,-48(A6)
0000488E  FFD0      
00004890  52AE 000C 8473          addq.l    #1,12(A6)
00004894  6002      8474          bra.s     vsprintf_7
                    8475   vsprintf_9:
00004896  6002      8476          bra.s     vsprintf_8
                    8477   vsprintf_7:
00004898  6096      8478          bra       vsprintf_6
                    8479   vsprintf_8:
0000489A  206E 000C 8480          move.l    12(A6),A0
0000489E  1010      8481          move.b    (A0),D0
000048A0  4880      8482          ext.w     D0
000048A2  48C0      8483          ext.l     D0
000048A4  0C80 0000 8484          cmp.l     #48,D0
000048A8  0030      
000048AA  660A      8485          bne.s     vsprintf_16
000048AC  52AE 000C 8486          addq.l    #1,12(A6)
000048B0  1D7C 0001 8487          move.b    #1,-46(A6)
000048B4  FFD2      
                    8488   vsprintf_16:
000048B6  486E 0010 8489          pea       16(A6)
000048BA  486E 000C 8490          pea       12(A6)
000048BE  6100 FE6E 8491          bsr       @vsprintf_getval
000048C2  504F      8492          addq.w    #8,A7
000048C4  2A40      8493          move.l    D0,A5
000048C6  206E 000C 8494          move.l    12(A6),A0
000048CA  1010      8495          move.b    (A0),D0
000048CC  4880      8496          ext.w     D0
000048CE  48C0      8497          ext.l     D0
000048D0  0C80 0000 8498          cmp.l     #46,D0
000048D4  002E      
000048D6  6614      8499          bne.s     vsprintf_18
000048D8  52AE 000C 8500          addq.l    #1,12(A6)
000048DC  486E 0010 8501          pea       16(A6)
000048E0  486E 000C 8502          pea       12(A6)
000048E4  6100 FE48 8503          bsr       @vsprintf_getval
000048E8  504F      8504          addq.w    #8,A7
000048EA  2A00      8505          move.l    D0,D5
                    8506   vsprintf_18:
000048EC  206E 000C 8507          move.l    12(A6),A0
000048F0  1010      8508          move.b    (A0),D0
000048F2  4880      8509          ext.w     D0
000048F4  48C0      8510          ext.l     D0
000048F6  0C80 0000 8511          cmp.l     #108,D0
000048FA  006C      
000048FC  660A      8512          bne.s     vsprintf_20
000048FE  52AE 000C 8513          addq.l    #1,12(A6)
00004902  1D7C 0001 8514          move.b    #1,-45(A6)
00004906  FFD3      
                    8515   vsprintf_20:
00004908  206E 000C 8516          move.l    12(A6),A0
0000490C  1010      8517          move.b    (A0),D0
0000490E  4880      8518          ext.w     D0
00004910  48C0      8519          ext.l     D0
00004912  0C80 0000 8520          cmp.l     #111,D0
00004916  006F      
00004918  6700 00D4 8521          beq       vsprintf_27
0000491C  6E34      8522          bgt.s     vsprintf_33
0000491E  0C80 0000 8523          cmp.l     #100,D0
00004922  0064      
00004924  6700 0054 8524          beq       vsprintf_24
00004928  6E1C      8525          bgt.s     vsprintf_34
0000492A  0C80 0000 8526          cmp.l     #99,D0
0000492E  0063      
00004930  6700 012C 8527          beq       vsprintf_30
00004934  6E00 016A 8528          bgt       vsprintf_22
00004938  0C80 0000 8529          cmp.l     #88,D0
0000493C  0058      
0000493E  6700 00E6 8530          beq       vsprintf_28
00004942  6000 015C 8531          bra       vsprintf_22
                    8532   vsprintf_34:
00004946  0C80 0000 8533          cmp.l     #105,D0
0000494A  0069      
0000494C  672C      8534          beq.s     vsprintf_24
0000494E  6000 0150 8535          bra       vsprintf_22
                    8536   vsprintf_33:
00004952  0C80 0000 8537          cmp.l     #117,D0
00004956  0075      
00004958  6700 005C 8538          beq       vsprintf_26
0000495C  6E0E      8539          bgt.s     vsprintf_35
0000495E  0C80 0000 8540          cmp.l     #115,D0
00004962  0073      
00004964  6700 011C 8541          beq       vsprintf_31
00004968  6000 0136 8542          bra       vsprintf_22
                    8543   vsprintf_35:
0000496C  0C80 0000 8544          cmp.l     #120,D0
00004970  0078      
00004972  6700 00B2 8545          beq       vsprintf_28
00004976  6000 0128 8546          bra       vsprintf_22
                    8547   vsprintf_24:
0000497A  4A2E FFD3 8548          tst.b     -45(A6)
0000497E  671A      8549          beq.s     vsprintf_36
00004980  4878 000A 8550          pea       10
00004984  2F03      8551          move.l    D3,-(A7)
00004986  206E 0010 8552          move.l    16(A6),A0
0000498A  58AE 0010 8553          addq.l    #4,16(A6)
0000498E  2F10      8554          move.l    (A0),-(A7)
00004990  6100 061E 8555          bsr       _ltoa
00004994  DEFC 000C 8556          add.w     #12,A7
00004998  6018      8557          bra.s     vsprintf_37
                    8558   vsprintf_36:
0000499A  4878 000A 8559          pea       10
0000499E  2F03      8560          move.l    D3,-(A7)
000049A0  206E 0010 8561          move.l    16(A6),A0
000049A4  58AE 0010 8562          addq.l    #4,16(A6)
000049A8  2F10      8563          move.l    (A0),-(A7)
000049AA  6100 0604 8564          bsr       _ltoa
000049AE  DEFC 000C 8565          add.w     #12,A7
                    8566   vsprintf_37:
000049B2  6000 00FA 8567          bra       vsprintf_23
                    8568   vsprintf_26:
000049B6  4A2E FFD3 8569          tst.b     -45(A6)
000049BA  6718      8570          beq.s     vsprintf_38
000049BC  4878 000A 8571          pea       10
000049C0  2F03      8572          move.l    D3,-(A7)
000049C2  206E 0010 8573          move.l    16(A6),A0
000049C6  58AE 0010 8574          addq.l    #4,16(A6)
000049CA  2F10      8575          move.l    (A0),-(A7)
000049CC  4E94      8576          jsr       (A4)
000049CE  DEFC 000C 8577          add.w     #12,A7
000049D2  6016      8578          bra.s     vsprintf_39
                    8579   vsprintf_38:
000049D4  4878 000A 8580          pea       10
000049D8  2F03      8581          move.l    D3,-(A7)
000049DA  206E 0010 8582          move.l    16(A6),A0
000049DE  58AE 0010 8583          addq.l    #4,16(A6)
000049E2  2F10      8584          move.l    (A0),-(A7)
000049E4  4E94      8585          jsr       (A4)
000049E6  DEFC 000C 8586          add.w     #12,A7
                    8587   vsprintf_39:
000049EA  6000 00C2 8588          bra       vsprintf_23
                    8589   vsprintf_27:
000049EE  4A2E FFD3 8590          tst.b     -45(A6)
000049F2  6718      8591          beq.s     vsprintf_40
000049F4  4878 0008 8592          pea       8
000049F8  2F03      8593          move.l    D3,-(A7)
000049FA  206E 0010 8594          move.l    16(A6),A0
000049FE  58AE 0010 8595          addq.l    #4,16(A6)
00004A02  2F10      8596          move.l    (A0),-(A7)
00004A04  4E94      8597          jsr       (A4)
00004A06  DEFC 000C 8598          add.w     #12,A7
00004A0A  6016      8599          bra.s     vsprintf_41
                    8600   vsprintf_40:
00004A0C  4878 0008 8601          pea       8
00004A10  2F03      8602          move.l    D3,-(A7)
00004A12  206E 0010 8603          move.l    16(A6),A0
00004A16  58AE 0010 8604          addq.l    #4,16(A6)
00004A1A  2F10      8605          move.l    (A0),-(A7)
00004A1C  4E94      8606          jsr       (A4)
00004A1E  DEFC 000C 8607          add.w     #12,A7
                    8608   vsprintf_41:
00004A22  6000 008A 8609          bra       vsprintf_23
                    8610   vsprintf_28:
00004A26  4A2E FFD3 8611          tst.b     -45(A6)
00004A2A  6718      8612          beq.s     vsprintf_42
00004A2C  4878 0010 8613          pea       16
00004A30  2F03      8614          move.l    D3,-(A7)
00004A32  206E 0010 8615          move.l    16(A6),A0
00004A36  58AE 0010 8616          addq.l    #4,16(A6)
00004A3A  2F10      8617          move.l    (A0),-(A7)
00004A3C  4E94      8618          jsr       (A4)
00004A3E  DEFC 000C 8619          add.w     #12,A7
00004A42  6016      8620          bra.s     vsprintf_43
                    8621   vsprintf_42:
00004A44  4878 0010 8622          pea       16
00004A48  2F03      8623          move.l    D3,-(A7)
00004A4A  206E 0010 8624          move.l    16(A6),A0
00004A4E  58AE 0010 8625          addq.l    #4,16(A6)
00004A52  2F10      8626          move.l    (A0),-(A7)
00004A54  4E94      8627          jsr       (A4)
00004A56  DEFC 000C 8628          add.w     #12,A7
                    8629   vsprintf_43:
00004A5A  6000 0052 8630          bra       vsprintf_23
                    8631   vsprintf_30:
00004A5E  206E 0010 8632          move.l    16(A6),A0
00004A62  58AE 0010 8633          addq.l    #4,16(A6)
00004A66  2010      8634          move.l    (A0),D0
00004A68  2042      8635          move.l    D2,A0
00004A6A  5282      8636          addq.l    #1,D2
00004A6C  1080      8637          move.b    D0,(A0)
00004A6E  2042      8638          move.l    D2,A0
00004A70  4210      8639          clr.b     (A0)
00004A72  200D      8640          move.l    A5,D0
00004A74  6704      8641          beq.s     vsprintf_44
00004A76  200D      8642          move.l    A5,D0
00004A78  6002      8643          bra.s     vsprintf_45
                    8644   vsprintf_44:
00004A7A  7001      8645          moveq     #1,D0
                    8646   vsprintf_45:
00004A7C  2A00      8647          move.l    D0,D5
00004A7E  6000 002E 8648          bra       vsprintf_23
                    8649   vsprintf_31:
00004A82  206E 0010 8650          move.l    16(A6),A0
00004A86  58AE 0010 8651          addq.l    #4,16(A6)
00004A8A  2610      8652          move.l    (A0),D3
00004A8C  0C85 FFFF 8653          cmp.l     #-1,D5
00004A90  FFFF      
00004A92  660A      8654          bne.s     vsprintf_46
00004A94  2F03      8655          move.l    D3,-(A7)
00004A96  6100 05FE 8656          bsr       _strlen
00004A9A  584F      8657          addq.w    #4,A7
00004A9C  2A00      8658          move.l    D0,D5
                    8659   vsprintf_46:
00004A9E  600E      8660          bra.s     vsprintf_23
                    8661   vsprintf_22:
00004AA0  206E 000C 8662          move.l    12(A6),A0
00004AA4  2242      8663          move.l    D2,A1
00004AA6  5282      8664          addq.l    #1,D2
00004AA8  1290      8665          move.b    (A0),(A1)
00004AAA  2042      8666          move.l    D2,A0
00004AAC  4210      8667          clr.b     (A0)
                    8668   vsprintf_23:
00004AAE  2F03      8669          move.l    D3,-(A7)
00004AB0  6100 05E4 8670          bsr       _strlen
00004AB4  584F      8671          addq.w    #4,A7
00004AB6  1800      8672          move.b    D0,D4
00004AB8  206E 000C 8673          move.l    12(A6),A0
00004ABC  1010      8674          move.b    (A0),D0
00004ABE  4880      8675          ext.w     D0
00004AC0  48C0      8676          ext.l     D0
00004AC2  0C80 0000 8677          cmp.l     #115,D0
00004AC6  0073      
00004AC8  6618      8678          bne.s     vsprintf_48
00004ACA  0C85 0000 8679          cmp.l     #0,D5
00004ACE  0000      
00004AD0  6D10      8680          blt.s     vsprintf_48
00004AD2  4884      8681          ext.w     D4
00004AD4  48C4      8682          ext.l     D4
00004AD6  B885      8683          cmp.l     D5,D4
00004AD8  6F04      8684          ble.s     vsprintf_50
00004ADA  1005      8685          move.b    D5,D0
00004ADC  6002      8686          bra.s     vsprintf_51
                    8687   vsprintf_50:
00004ADE  1004      8688          move.b    D4,D0
                    8689   vsprintf_51:
00004AE0  1800      8690          move.b    D0,D4
                    8691   vsprintf_48:
00004AE2  206E 000C 8692          move.l    12(A6),A0
00004AE6  1010      8693          move.b    (A0),D0
00004AE8  4880      8694          ext.w     D0
00004AEA  48C0      8695          ext.l     D0
00004AEC  0C80 0000 8696          cmp.l     #88,D0
00004AF0  0058      
00004AF2  6600 0026 8697          bne       vsprintf_56
00004AF6  41EE FFDC 8698          lea       -36(A6),A0
00004AFA  2408      8699          move.l    A0,D2
                    8700   vsprintf_54:
00004AFC  2042      8701          move.l    D2,A0
00004AFE  4A10      8702          tst.b     (A0)
00004B00  6718      8703          beq.s     vsprintf_56
00004B02  2042      8704          move.l    D2,A0
00004B04  1210      8705          move.b    (A0),D1
00004B06  4881      8706          ext.w     D1
00004B08  48C1      8707          ext.l     D1
00004B0A  2F01      8708          move.l    D1,-(A7)
00004B0C  6100 F334 8709          bsr       _toupper
00004B10  584F      8710          addq.w    #4,A7
00004B12  2042      8711          move.l    D2,A0
00004B14  1080      8712          move.b    D0,(A0)
00004B16  5282      8713          addq.l    #1,D2
00004B18  60E2      8714          bra       vsprintf_54
                    8715   vsprintf_56:
00004B1A  7E00      8716          moveq     #0,D7
00004B1C  41EE FFD4 8717          lea       -44(A6),A0
00004B20  2408      8718          move.l    A0,D2
00004B22  206E 000C 8719          move.l    12(A6),A0
00004B26  1010      8720          move.b    (A0),D0
00004B28  4880      8721          ext.w     D0
00004B2A  48C0      8722          ext.l     D0
00004B2C  0C80 0000 8723          cmp.l     #100,D0
00004B30  0064      
00004B32  6714      8724          beq.s     vsprintf_59
00004B34  206E 000C 8725          move.l    12(A6),A0
00004B38  1010      8726          move.b    (A0),D0
00004B3A  4880      8727          ext.w     D0
00004B3C  48C0      8728          ext.l     D0
00004B3E  0C80 0000 8729          cmp.l     #105,D0
00004B42  0069      
00004B44  6600 0076 8730          bne       vsprintf_65
                    8731   vsprintf_59:
00004B48  4A2E FFCE 8732          tst.b     -50(A6)
00004B4C  6612      8733          bne.s     vsprintf_62
00004B4E  2043      8734          move.l    D3,A0
00004B50  1010      8735          move.b    (A0),D0
00004B52  4880      8736          ext.w     D0
00004B54  48C0      8737          ext.l     D0
00004B56  0C80 0000 8738          cmp.l     #45,D0
00004B5A  002D      
00004B5C  6600 002E 8739          bne       vsprintf_60
                    8740   vsprintf_62:
00004B60  2043      8741          move.l    D3,A0
00004B62  1010      8742          move.b    (A0),D0
00004B64  4880      8743          ext.w     D0
00004B66  48C0      8744          ext.l     D0
00004B68  0C80 0000 8745          cmp.l     #45,D0
00004B6C  002D      
00004B6E  660E      8746          bne.s     vsprintf_63
00004B70  2043      8747          move.l    D3,A0
00004B72  5283      8748          addq.l    #1,D3
00004B74  2242      8749          move.l    D2,A1
00004B76  5282      8750          addq.l    #1,D2
00004B78  1290      8751          move.b    (A0),(A1)
00004B7A  5304      8752          subq.b    #1,D4
00004B7C  6008      8753          bra.s     vsprintf_64
                    8754   vsprintf_63:
00004B7E  2042      8755          move.l    D2,A0
00004B80  5282      8756          addq.l    #1,D2
00004B82  10BC 002B 8757          move.b    #43,(A0)
                    8758   vsprintf_64:
00004B86  5287      8759          addq.l    #1,D7
00004B88  6000 0032 8760          bra       vsprintf_65
                    8761   vsprintf_60:
00004B8C  4A2E FFCF 8762          tst.b     -49(A6)
00004B90  6700 002A 8763          beq       vsprintf_65
00004B94  2043      8764          move.l    D3,A0
00004B96  1010      8765          move.b    (A0),D0
00004B98  4880      8766          ext.w     D0
00004B9A  48C0      8767          ext.l     D0
00004B9C  0C80 0000 8768          cmp.l     #45,D0
00004BA0  002D      
00004BA2  660E      8769          bne.s     vsprintf_67
00004BA4  2043      8770          move.l    D3,A0
00004BA6  5283      8771          addq.l    #1,D3
00004BA8  2242      8772          move.l    D2,A1
00004BAA  5282      8773          addq.l    #1,D2
00004BAC  1290      8774          move.b    (A0),(A1)
00004BAE  5304      8775          subq.b    #1,D4
00004BB0  6008      8776          bra.s     vsprintf_68
                    8777   vsprintf_67:
00004BB2  2042      8778          move.l    D2,A0
00004BB4  5282      8779          addq.l    #1,D2
00004BB6  10BC 0020 8780          move.b    #32,(A0)
                    8781   vsprintf_68:
00004BBA  5287      8782          addq.l    #1,D7
                    8783   vsprintf_65:
00004BBC  4A2E FFD0 8784          tst.b     -48(A6)
00004BC0  6700 0066 8785          beq       vsprintf_77
00004BC4  206E 000C 8786          move.l    12(A6),A0
00004BC8  1010      8787          move.b    (A0),D0
00004BCA  4880      8788          ext.w     D0
00004BCC  48C0      8789          ext.l     D0
00004BCE  0C80 0000 8790          cmp.l     #111,D0
00004BD2  006F      
00004BD4  671A      8791          beq.s     vsprintf_73
00004BD6  6E0C      8792          bgt.s     vsprintf_76
00004BD8  0C80 0000 8793          cmp.l     #88,D0
00004BDC  0058      
00004BDE  6710      8794          beq.s     vsprintf_73
00004BE0  6000 0046 8795          bra       vsprintf_77
                    8796   vsprintf_76:
00004BE4  0C80 0000 8797          cmp.l     #120,D0
00004BE8  0078      
00004BEA  6704      8798          beq.s     vsprintf_73
00004BEC  6000 003A 8799          bra       vsprintf_77
                    8800   vsprintf_73:
00004BF0  2042      8801          move.l    D2,A0
00004BF2  5282      8802          addq.l    #1,D2
00004BF4  10BC 0030 8803          move.b    #48,(A0)
00004BF8  5287      8804          addq.l    #1,D7
00004BFA  206E 000C 8805          move.l    12(A6),A0
00004BFE  1010      8806          move.b    (A0),D0
00004C00  4880      8807          ext.w     D0
00004C02  48C0      8808          ext.l     D0
00004C04  0C80 0000 8809          cmp.l     #120,D0
00004C08  0078      
00004C0A  6712      8810          beq.s     vsprintf_79
00004C0C  206E 000C 8811          move.l    12(A6),A0
00004C10  1010      8812          move.b    (A0),D0
00004C12  4880      8813          ext.w     D0
00004C14  48C0      8814          ext.l     D0
00004C16  0C80 0000 8815          cmp.l     #88,D0
00004C1A  0058      
00004C1C  660A      8816          bne.s     vsprintf_77
                    8817   vsprintf_79:
00004C1E  2042      8818          move.l    D2,A0
00004C20  5282      8819          addq.l    #1,D2
00004C22  10BC 0078 8820          move.b    #120,(A0)
00004C26  5287      8821          addq.l    #1,D7
                    8822   vsprintf_77:
00004C28  2042      8823          move.l    D2,A0
00004C2A  4210      8824          clr.b     (A0)
00004C2C  206E 000C 8825          move.l    12(A6),A0
00004C30  1010      8826          move.b    (A0),D0
00004C32  4880      8827          ext.w     D0
00004C34  48C0      8828          ext.l     D0
00004C36  0C80 0000 8829          cmp.l     #105,D0
00004C3A  0069      
00004C3C  6700 0076 8830          beq       vsprintf_82
00004C40  6E42      8831          bgt.s     vsprintf_93
00004C42  0C80 0000 8832          cmp.l     #99,D0
00004C46  0063      
00004C48  6700 0084 8833          beq       vsprintf_96
00004C4C  6E1C      8834          bgt.s     vsprintf_94
00004C4E  0C80 0000 8835          cmp.l     #88,D0
00004C52  0058      
00004C54  6700 005E 8836          beq       vsprintf_82
00004C58  6E00 0184 8837          bgt       vsprintf_80
00004C5C  0C80 0000 8838          cmp.l     #69,D0
00004C60  0045      
00004C62  6700 0050 8839          beq       vsprintf_82
00004C66  6000 0176 8840          bra       vsprintf_80
                    8841   vsprintf_94:
00004C6A  0C80 0000 8842          cmp.l     #101,D0
00004C6E  0065      
00004C70  6700 0042 8843          beq       vsprintf_82
00004C74  6E00 0168 8844          bgt       vsprintf_80
00004C78  0C80 0000 8845          cmp.l     #100,D0
00004C7C  0064      
00004C7E  6734      8846          beq.s     vsprintf_82
00004C80  6000 015C 8847          bra       vsprintf_80
                    8848   vsprintf_93:
00004C84  0C80 0000 8849          cmp.l     #117,D0
00004C88  0075      
00004C8A  6728      8850          beq.s     vsprintf_82
00004C8C  6E1A      8851          bgt.s     vsprintf_95
00004C8E  0C80 0000 8852          cmp.l     #115,D0
00004C92  0073      
00004C94  6700 0038 8853          beq       vsprintf_96
00004C98  6E00 0144 8854          bgt       vsprintf_80
00004C9C  0C80 0000 8855          cmp.l     #111,D0
00004CA0  006F      
00004CA2  6710      8856          beq.s     vsprintf_82
00004CA4  6000 0138 8857          bra       vsprintf_80
                    8858   vsprintf_95:
00004CA8  0C80 0000 8859          cmp.l     #120,D0
00004CAC  0078      
00004CAE  6704      8860          beq.s     vsprintf_82
00004CB0  6000 012C 8861          bra       vsprintf_80
                    8862   vsprintf_82:
00004CB4  4A2E FFD2 8863          tst.b     -46(A6)
00004CB8  6714      8864          beq.s     vsprintf_96
00004CBA  4A2E FFCD 8865          tst.b     -51(A6)
00004CBE  660E      8866          bne.s     vsprintf_96
00004CC0  200D      8867          move.l    A5,D0
00004CC2  9087      8868          sub.l     D7,D0
00004CC4  4884      8869          ext.w     D4
00004CC6  48C4      8870          ext.l     D4
00004CC8  9084      8871          sub.l     D4,D0
00004CCA  2D40 FFFC 8872          move.l    D0,-4(A6)
                    8873   vsprintf_96:
00004CCE  202E FFFC 8874          move.l    -4(A6),D0
00004CD2  0C80 0000 8875          cmp.l     #0,D0
00004CD6  0000      
00004CD8  6C04      8876          bge.s     vsprintf_98
00004CDA  42AE FFFC 8877          clr.l     -4(A6)
                    8878   vsprintf_98:
00004CDE  4A2E FFCD 8879          tst.b     -51(A6)
00004CE2  6600 0030 8880          bne       vsprintf_104
00004CE6  4884      8881          ext.w     D4
00004CE8  48C4      8882          ext.l     D4
00004CEA  2004      8883          move.l    D4,D0
00004CEC  D0AE FFFC 8884          add.l     -4(A6),D0
00004CF0  D087      8885          add.l     D7,D0
00004CF2  1D40 FFD1 8886          move.b    D0,-47(A6)
                    8887   vsprintf_102:
00004CF6  102E FFD1 8888          move.b    -47(A6),D0
00004CFA  4880      8889          ext.w     D0
00004CFC  48C0      8890          ext.l     D0
00004CFE  220D      8891          move.l    A5,D1
00004D00  534D      8892          subq.w    #1,A5
00004D02  B081      8893          cmp.l     D1,D0
00004D04  6C0E      8894          bge.s     vsprintf_104
00004D06  4878 0020 8895          pea       32
00004D0A  2F0A      8896          move.l    A2,-(A7)
00004D0C  4E93      8897          jsr       (A3)
00004D0E  504F      8898          addq.w    #8,A7
00004D10  5286      8899          addq.l    #1,D6
00004D12  60E2      8900          bra       vsprintf_102
                    8901   vsprintf_104:
00004D14  41EE FFD4 8902          lea       -44(A6),A0
00004D18  2408      8903          move.l    A0,D2
                    8904   vsprintf_105:
00004D1A  2042      8905          move.l    D2,A0
00004D1C  4A10      8906          tst.b     (A0)
00004D1E  6716      8907          beq.s     vsprintf_107
00004D20  2042      8908          move.l    D2,A0
00004D22  5282      8909          addq.l    #1,D2
00004D24  1210      8910          move.b    (A0),D1
00004D26  4881      8911          ext.w     D1
00004D28  48C1      8912          ext.l     D1
00004D2A  2F01      8913          move.l    D1,-(A7)
00004D2C  2F0A      8914          move.l    A2,-(A7)
00004D2E  4E93      8915          jsr       (A3)
00004D30  504F      8916          addq.w    #8,A7
00004D32  5286      8917          addq.l    #1,D6
00004D34  60E4      8918          bra       vsprintf_105
                    8919   vsprintf_107:
00004D36  202E FFFC 8920          move.l    -4(A6),D0
00004D3A  1D40 FFD1 8921          move.b    D0,-47(A6)
                    8922   vsprintf_108:
00004D3E  102E FFD1 8923          move.b    -47(A6),D0
00004D42  532E FFD1 8924          subq.b    #1,-47(A6)
00004D46  4A00      8925          tst.b     D0
00004D48  670E      8926          beq.s     vsprintf_110
00004D4A  4878 0030 8927          pea       48
00004D4E  2F0A      8928          move.l    A2,-(A7)
00004D50  4E93      8929          jsr       (A3)
00004D52  504F      8930          addq.w    #8,A7
00004D54  5286      8931          addq.l    #1,D6
00004D56  60E6      8932          bra       vsprintf_108
                    8933   vsprintf_110:
00004D58  2043      8934          move.l    D3,A0
00004D5A  4A10      8935          tst.b     (A0)
00004D5C  6700 0048 8936          beq       vsprintf_113
00004D60  206E 000C 8937          move.l    12(A6),A0
00004D64  1010      8938          move.b    (A0),D0
00004D66  4880      8939          ext.w     D0
00004D68  48C0      8940          ext.l     D0
00004D6A  0C80 0000 8941          cmp.l     #115,D0
00004D6E  0073      
00004D70  670C      8942          beq.s     vsprintf_116
00004D72  6E18      8943          bgt.s     vsprintf_119
00004D74  0C80 0000 8944          cmp.l     #99,D0
00004D78  0063      
00004D7A  6702      8945          beq.s     vsprintf_116
00004D7C  600E      8946          bra.s     vsprintf_119
                    8947   vsprintf_116:
00004D7E  2005      8948          move.l    D5,D0
00004D80  5385      8949          subq.l    #1,D5
00004D82  0C80 0000 8950          cmp.l     #0,D0
00004D86  0000      
00004D88  6E02      8951          bgt.s     vsprintf_119
00004D8A  6016      8952          bra.s     vsprintf_115
                    8953   vsprintf_119:
00004D8C  2043      8954          move.l    D3,A0
00004D8E  5283      8955          addq.l    #1,D3
00004D90  1210      8956          move.b    (A0),D1
00004D92  4881      8957          ext.w     D1
00004D94  48C1      8958          ext.l     D1
00004D96  2F01      8959          move.l    D1,-(A7)
00004D98  2F0A      8960          move.l    A2,-(A7)
00004D9A  4E93      8961          jsr       (A3)
00004D9C  504F      8962          addq.w    #8,A7
00004D9E  5286      8963          addq.l    #1,D6
00004DA0  6002      8964          bra.s     vsprintf_112
                    8965   vsprintf_115:
00004DA2  6002      8966          bra.s     vsprintf_113
                    8967   vsprintf_112:
00004DA4  60B2      8968          bra       vsprintf_110
                    8969   vsprintf_113:
00004DA6  4A2E FFCD 8970          tst.b     -51(A6)
00004DAA  6700 0030 8971          beq       vsprintf_125
00004DAE  4884      8972          ext.w     D4
00004DB0  48C4      8973          ext.l     D4
00004DB2  2004      8974          move.l    D4,D0
00004DB4  D0AE FFFC 8975          add.l     -4(A6),D0
00004DB8  D087      8976          add.l     D7,D0
00004DBA  1D40 FFD1 8977          move.b    D0,-47(A6)
                    8978   vsprintf_123:
00004DBE  102E FFD1 8979          move.b    -47(A6),D0
00004DC2  4880      8980          ext.w     D0
00004DC4  48C0      8981          ext.l     D0
00004DC6  220D      8982          move.l    A5,D1
00004DC8  534D      8983          subq.w    #1,A5
00004DCA  B081      8984          cmp.l     D1,D0
00004DCC  6C0E      8985          bge.s     vsprintf_125
00004DCE  4878 0020 8986          pea       32
00004DD2  2F0A      8987          move.l    A2,-(A7)
00004DD4  4E93      8988          jsr       (A3)
00004DD6  504F      8989          addq.w    #8,A7
00004DD8  5386      8990          subq.l    #1,D6
00004DDA  60E2      8991          bra       vsprintf_123
                    8992   vsprintf_125:
00004DDC  6014      8993          bra.s     vsprintf_81
                    8994   vsprintf_80:
00004DDE  206E 000C 8995          move.l    12(A6),A0
00004DE2  1210      8996          move.b    (A0),D1
00004DE4  4881      8997          ext.w     D1
00004DE6  48C1      8998          ext.l     D1
00004DE8  2F01      8999          move.l    D1,-(A7)
00004DEA  2F0A      9000          move.l    A2,-(A7)
00004DEC  4E93      9001          jsr       (A3)
00004DEE  504F      9002          addq.w    #8,A7
00004DF0  5286      9003          addq.l    #1,D6
                    9004   vsprintf_81:
00004DF2  52AE 000C 9005          addq.l    #1,12(A6)
                    9006   vsprintf_2:
00004DF6  6000 F9D6 9007          bra       vsprintf_1
                    9008   vsprintf_3:
00004DFA  4A92      9009          tst.l     (A2)
00004DFC  6710      9010          beq.s     vsprintf_126
00004DFE  4201      9011          clr.b     D1
00004E00  C2BC 0000 9012          and.l     #255,D1
00004E04  00FF      
00004E06  2F01      9013          move.l    D1,-(A7)
00004E08  2F0A      9014          move.l    A2,-(A7)
00004E0A  4E93      9015          jsr       (A3)
00004E0C  504F      9016          addq.w    #8,A7
                    9017   vsprintf_126:
00004E0E  2006      9018          move.l    D6,D0
00004E10  4CDF 3CFC 9019          movem.l   (A7)+,D2/D3/D4/D5/D6/D7/A2/A3/A4/A5
00004E14  4E5E      9020          unlk      A6
00004E16  4E75      9021          rts
                    9022   ULMUL:
00004E18  4E56 0000 9023          link    A6,#0
00004E1C  48E7 C000 9024          movem.l D0/D1,-(A7)
00004E20  222E 0008 9025          move.l  8(A6),D1
00004E24  202E 000C 9026          move.l  12(A6),D0
00004E28  602C      9027          bra.s   lmul_3
                    9028   LMUL:
00004E2A  4E56 0000 9029          link    A6,#0
00004E2E  48E7 C000 9030          movem.l D0/D1,-(A7)
00004E32  222E 0008 9031          move.l  8(A6),D1
00004E36  202E 000C 9032          move.l  12(A6),D0
00004E3A  4A80      9033          tst.l   D0
00004E3C  6A0A      9034          bpl.s   lmul_1
00004E3E  4480      9035          neg.l   D0
00004E40  4A81      9036          tst.l   D1
00004E42  6A0A      9037          bpl.s   lmul_2
00004E44  4481      9038          neg.l   D1
00004E46  600E      9039          bra.s   lmul_3
                    9040   lmul_1:
00004E48  4A81      9041          tst.l   D1
00004E4A  6A0A      9042          bpl.s   lmul_3
00004E4C  4481      9043          neg.l   D1
                    9044   lmul_2:
00004E4E  6114      9045          bsr.s   domul
00004E50  4481      9046          neg.l   D1
00004E52  4080      9047          negx.l  D0
00004E54  6002      9048          bra.s   lmul_4
                    9049   lmul_3:
00004E56  610C      9050          bsr.s   domul
                    9051   lmul_4:
00004E58  2D41 0008 9052          move.l  D1,8(A6)
00004E5C  4CDF 0003 9053          movem.l (A7)+,D0/D1
00004E60  4E5E      9054          unlk    A6
00004E62  4E75      9055          rts
                    9056   domul:
00004E64  0C81 0000 9057          cmpi.l  #$FFFF,D1
00004E68  FFFF      
00004E6A  620C      9058          bhi.s   domul_1
00004E6C  0C80 0000 9059          cmpi.l  #$FFFF,D0
00004E70  FFFF      
00004E72  620E      9060          bhi.s   domul_2
00004E74  C2C0      9061          mulu    D0,D1
00004E76  4E75      9062          rts
                    9063   domul_1:
00004E78  0C80 0000 9064          cmpi.l  #$FFFF,D0
00004E7C  FFFF      
00004E7E  6218      9065          bhi.s   domul_4
00004E80  6002      9066          bra.s   domul_3
                    9067   domul_2
00004E82  C141      9068          exg     D0,D1
                    9069   domul_3:
00004E84  2F02      9070          move.l  D2,-(A7)
00004E86  2401      9071          move.l  D1,D2
00004E88  4842      9072          swap    D2
00004E8A  C2C0      9073          mulu    D0,D1
00004E8C  C4C0      9074          mulu    D0,D2
00004E8E  4842      9075          swap    D2
00004E90  4242      9076          clr.w   D2
00004E92  D282      9077          add.l   D2,D1
00004E94  241F      9078          move.l  (A7)+,D2
00004E96  4E75      9079          rts
                    9080   domul_4:
00004E98  48E7 3000 9081          movem.l D2/D3,-(A7)
00004E9C  2401      9082          move.l  D1,D2
00004E9E  2601      9083          move.l  D1,D3
00004EA0  C2C0      9084          mulu    D0,D1
00004EA2  4842      9085          swap    D2
00004EA4  C4C0      9086          mulu    D0,D2
00004EA6  4840      9087          swap    D0
00004EA8  C6C0      9088          mulu    D0,D3
00004EAA  D483      9089          add.l   D3,D2
00004EAC  4842      9090          swap    D2
00004EAE  4242      9091          clr.w   D2
00004EB0  D282      9092          add.l   D2,D1
00004EB2  4CDF 000C 9093          movem.l (A7)+,D2/D3
00004EB6  4E75      9094          rts
                    9095   _gets:
00004EB8  4E56 0000 9096          link      A6,#0
00004EBC  48E7 3820 9097          movem.l   D2/D3/D4/A2,-(A7)
00004EC0  45F8 3D48 9098          lea       _putch,A2
00004EC4  282E 0008 9099          move.l    8(A6),D4
00004EC8  2404      9100          move.l    D4,D2
                    9101   gets_1:
00004ECA  6100 EEAC 9102          bsr       _getch
00004ECE  2600      9103          move.l    D0,D3
00004ED0  0C80 0000 9104          cmp.l     #10,D0
00004ED4  000A      
00004ED6  6700 003C 9105          beq       gets_3
00004EDA  0C83 0000 9106          cmp.l     #8,D3
00004EDE  0008      
00004EE0  6712      9107          beq.s     gets_4
00004EE2  2042      9108          move.l    D2,A0
00004EE4  5282      9109          addq.l    #1,D2
00004EE6  1083      9110          move.b    D3,(A0)
00004EE8  4883      9111          ext.w     D3
00004EEA  48C3      9112          ext.l     D3
00004EEC  2F03      9113          move.l    D3,-(A7)
00004EEE  4E92      9114          jsr       (A2)
00004EF0  584F      9115          addq.w    #4,A7
00004EF2  601E      9116          bra.s     gets_6
                    9117   gets_4:
00004EF4  B484      9118          cmp.l     D4,D2
00004EF6  631A      9119          bls.s     gets_6
00004EF8  4878 0008 9120          pea       8
00004EFC  4E92      9121          jsr       (A2)
00004EFE  584F      9122          addq.w    #4,A7
00004F00  4878 0020 9123          pea       32
00004F04  4E92      9124          jsr       (A2)
00004F06  584F      9125          addq.w    #4,A7
00004F08  4878 0008 9126          pea       8
00004F0C  4E92      9127          jsr       (A2)
00004F0E  584F      9128          addq.w    #4,A7
00004F10  5382      9129          subq.l    #1,D2
                    9130   gets_6:
00004F12  60B6      9131          bra       gets_1
                    9132   gets_3:
00004F14  4878 000A 9133          pea       10
00004F18  4E92      9134          jsr       (A2)
00004F1A  584F      9135          addq.w    #4,A7
00004F1C  2042      9136          move.l    D2,A0
00004F1E  4210      9137          clr.b     (A0)
00004F20  2004      9138          move.l    D4,D0
00004F22  4CDF 041C 9139          movem.l   (A7)+,D2/D3/D4/A2
00004F26  4E5E      9140          unlk      A6
00004F28  4E75      9141          rts
                    9142   _ungetch:
00004F2A  4E56 0000 9143          link      A6,#0
00004F2E  23EE 0008 9144          move.l    8(A6),__ungetbuf
00004F32  0B00 00C0 
00004F36  202E 0008 9145          move.l    8(A6),D0
00004F3A  4E5E      9146          unlk      A6
00004F3C  4E75      9147          rts
                    9148   @itoa_convert:
00004F3E  4E56 0000 9149          link      A6,#0
00004F42  48E7 3C00 9150          movem.l   D2/D3/D4/D5,-(A7)
00004F46  242E 0008 9151          move.l    8(A6),D2
00004F4A  262E 0010 9152          move.l    16(A6),D3
00004F4E  2A2E 000C 9153          move.l    12(A6),D5
00004F52  2F05      9154          move.l    D5,-(A7)
00004F54  2F03      9155          move.l    D3,-(A7)
00004F56  6100 ED12 9156          bsr       ULDIV
00004F5A  202F 0004 9157          move.l    4(A7),D0
00004F5E  504F      9158          addq.w    #8,A7
00004F60  2800      9159          move.l    D0,D4
00004F62  BA83      9160          cmp.l     D3,D5
00004F64  651A      9161          blo.s     @itoa_convert_1
00004F66  2F03      9162          move.l    D3,-(A7)
00004F68  2F05      9163          move.l    D5,-(A7)
00004F6A  2F03      9164          move.l    D3,-(A7)
00004F6C  6100 ECFC 9165          bsr       ULDIV
00004F70  2217      9166          move.l    (A7),D1
00004F72  504F      9167          addq.w    #8,A7
00004F74  2F01      9168          move.l    D1,-(A7)
00004F76  2F02      9169          move.l    D2,-(A7)
00004F78  61C4      9170          bsr       @itoa_convert
00004F7A  DEFC 000C 9171          add.w     #12,A7
00004F7E  2400      9172          move.l    D0,D2
                    9173   @itoa_convert_1:
00004F80  0C84 0000 9174          cmp.l     #9,D4
00004F84  0009      
00004F86  6E0A      9175          bgt.s     @itoa_convert_3
00004F88  2004      9176          move.l    D4,D0
00004F8A  0680 0000 9177          add.l     #48,D0
00004F8E  0030      
00004F90  600E      9178          bra.s     @itoa_convert_4
                    9179   @itoa_convert_3:
00004F92  2004      9180          move.l    D4,D0
00004F94  0680 0000 9181          add.l     #97,D0
00004F98  0061      
00004F9A  0480 0000 9182          sub.l     #10,D0
00004F9E  000A      
                    9183   @itoa_convert_4:
00004FA0  2042      9184          move.l    D2,A0
00004FA2  1080      9185          move.b    D0,(A0)
00004FA4  2002      9186          move.l    D2,D0
00004FA6  5280      9187          addq.l    #1,D0
00004FA8  4CDF 003C 9188          movem.l   (A7)+,D2/D3/D4/D5
00004FAC  4E5E      9189          unlk      A6
00004FAE  4E75      9190          rts
                    9191   _ltoa:
00004FB0  4E56 0000 9192          link      A6,#0
00004FB4  48E7 3C00 9193          movem.l   D2/D3/D4/D5,-(A7)
00004FB8  242E 0008 9194          move.l    8(A6),D2
00004FBC  262E 000C 9195          move.l    12(A6),D3
00004FC0  2A2E 0010 9196          move.l    16(A6),D5
00004FC4  2803      9197          move.l    D3,D4
00004FC6  0C85 0000 9198          cmp.l     #2,D5
00004FCA  0002      
00004FCC  6D08      9199          blt.s     ltoa_3
00004FCE  0C85 0000 9200          cmp.l     #36,D5
00004FD2  0024      
00004FD4  6F06      9201          ble.s     ltoa_1
                    9202   ltoa_3:
00004FD6  2003      9203          move.l    D3,D0
00004FD8  6000 0052 9204          bra       ltoa_4
                    9205   ltoa_1:
00004FDC  0C85 0000 9206          cmp.l     #10,D5
00004FE0  000A      
00004FE2  6600 0032 9207          bne       ltoa_5
00004FE6  0C82 0000 9208          cmp.l     #0,D2
00004FEA  0000      
00004FEC  6C28      9209          bge.s     ltoa_5
00004FEE  2002      9210          move.l    D2,D0
00004FF0  4480      9211          neg.l     D0
00004FF2  2400      9212          move.l    D0,D2
00004FF4  0C82 0000 9213          cmp.l     #0,D2
00004FF8  0000      
00004FFA  6C12      9214          bge.s     ltoa_7
00004FFC  4879 0000 9215          pea       @itoa_1
00005000  6A3E      
00005002  2F03      9216          move.l    D3,-(A7)
00005004  6100 EC54 9217          bsr       _strcpy
00005008  504F      9218          addq.w    #8,A7
0000500A  2003      9219          move.l    D3,D0
0000500C  601E      9220          bra.s     ltoa_4
                    9221   ltoa_7:
0000500E  2044      9222          move.l    D4,A0
00005010  5284      9223          addq.l    #1,D4
00005012  10BC 002D 9224          move.b    #45,(A0)
                    9225   ltoa_5:
00005016  2F05      9226          move.l    D5,-(A7)
00005018  2F02      9227          move.l    D2,-(A7)
0000501A  2F04      9228          move.l    D4,-(A7)
0000501C  6100 FF20 9229          bsr       @itoa_convert
00005020  DEFC 000C 9230          add.w     #12,A7
00005024  2800      9231          move.l    D0,D4
00005026  2044      9232          move.l    D4,A0
00005028  4210      9233          clr.b     (A0)
0000502A  2003      9234          move.l    D3,D0
                    9235   ltoa_4:
0000502C  4CDF 003C 9236          movem.l   (A7)+,D2/D3/D4/D5
00005030  4E5E      9237          unlk      A6
00005032  4E75      9238          rts
                    9239   _ultoa:
00005034  4E56 0000 9240          link      A6,#0
00005038  48E7 3800 9241          movem.l   D2/D3/D4,-(A7)
0000503C  262E 0010 9242          move.l    16(A6),D3
00005040  282E 000C 9243          move.l    12(A6),D4
00005044  2404      9244          move.l    D4,D2
00005046  0C83 0000 9245          cmp.l     #2,D3
0000504A  0002      
0000504C  6D08      9246          blt.s     ultoa_3
0000504E  0C83 0000 9247          cmp.l     #36,D3
00005052  0024      
00005054  6F04      9248          ble.s     ultoa_1
                    9249   ultoa_3:
00005056  2004      9250          move.l    D4,D0
00005058  6018      9251          bra.s     ultoa_4
                    9252   ultoa_1:
0000505A  2F03      9253          move.l    D3,-(A7)
0000505C  2F2E 0008 9254          move.l    8(A6),-(A7)
00005060  2F02      9255          move.l    D2,-(A7)
00005062  6100 FEDA 9256          bsr       @itoa_convert
00005066  DEFC 000C 9257          add.w     #12,A7
0000506A  2400      9258          move.l    D0,D2
0000506C  2042      9259          move.l    D2,A0
0000506E  4210      9260          clr.b     (A0)
00005070  2004      9261          move.l    D4,D0
                    9262   ultoa_4:
00005072  4CDF 001C 9263          movem.l   (A7)+,D2/D3/D4
00005076  4E5E      9264          unlk      A6
00005078  4E75      9265          rts
                    9266   _itoa:
0000507A  4E56 0000 9267          link      A6,#0
0000507E  2F2E 0010 9268          move.l    16(A6),-(A7)
00005082  2F2E 000C 9269          move.l    12(A6),-(A7)
00005086  2F2E 0008 9270          move.l    8(A6),-(A7)
0000508A  6100 FF24 9271          bsr       _ltoa
0000508E  DEFC 000C 9272          add.w     #12,A7
00005092  4E5E      9273          unlk      A6
00005094  4E75      9274          rts
                    9275   _strlen:
00005096  206F 0004 9276          move.l    (4,A7),A0
0000509A  2248      9277          move.l    A0,A1
                    9278   strlen_1:
0000509C  4A19      9279          tst.b     (A1)+
0000509E  66FC      9280          bne       strlen_1
000050A0  2009      9281          move.l    A1,D0
000050A2  9088      9282          sub.l     A0,D0
000050A4  5380      9283          subq.l    #1,D0
000050A6  4E75      9284          rts
                    9285          section   const
                    9286   
                    9287   @canbus~1_1:
000050A8  0D0A 0D0A 9288          dc.b      13,10,13,10,45,45,45,45,32,67,65,78,66,85,83
000050AC  2D2D 2D2D 
000050B0  2043 414E 
000050B4  4255 53   
000050B7  2054 6573 9289          dc.b      32,84,101,115,116,32,45,45,45,45,13,10,0
000050BB  7420 2D2D 
000050BF  2D2D 0D0A 
000050C3  00        
                    9290   @canbus~1_2:
000050C4  0D0A 00   9291          dc.b      13,10,0
                    9292   @m68kde~1_1:
000050C8  0D0A 00   9293          dc.b      13,10,0
                    9294   @m68kde~1_2:
000050CC  0D53 7769 9295          dc.b      13,83,119,105,116,99,104,101,115,32,83,87,91
000050D0  7463 6865 
000050D4  7320 5357 
000050D8  5B        
000050D9  372D 305D 9296          dc.b      55,45,48,93,32,61,32,0
000050DD  203D 2000 
                    9297   @m68kde~1_3:
000050E2  3000      9298          dc.b      48,0
                    9299   @m68kde~1_4:
000050E4  3100      9300          dc.b      49,0
                    9301   @m68kde~1_5:
000050E6  0D0A 4475 9302          dc.b      13,10,68,117,109,112,32,77,101,109,111,114,121
000050EA  6D70 204D 
000050EE  656D 6F72 
000050F2  79        
000050F3  2042 6C6F 9303          dc.b      32,66,108,111,99,107,58,32,60,69,83,67,62,32
000050F7  636B 3A20 
000050FB  3C45 5343 
000050FF  3E20      
00005101  746F 2041 9304          dc.b      116,111,32,65,98,111,114,116,44,32,60,83,80
00005105  626F 7274 
00005109  2C20 3C53 
0000510D  50        
0000510E  4143 453E 9305          dc.b      65,67,69,62,32,116,111,32,67,111,110,116,105
00005112  2074 6F20 
00005116  436F 6E74 
0000511A  69        
0000511B  6E75 6500 9306          dc.b      110,117,101,0
                    9307   @m68kde~1_6:
00005120  0D0A 456E 9308          dc.b      13,10,69,110,116,101,114,32,83,116,97,114,116
00005124  7465 7220 
00005128  5374 6172 
0000512C  74        
0000512D  2041 6464 9309          dc.b      32,65,100,100,114,101,115,115,58,32,0
00005131  7265 7373 
00005135  3A20 00   
                    9310   @m68kde~1_7:
00005138  0D0A 2530 9311          dc.b      13,10,37,48,56,120,32,0
0000513C  3878 2000 
                    9312   @m68kde~1_8:
00005140  2530 3258 9313          dc.b      37,48,50,88,0
00005144  00        
                    9314   @m68kde~1_9:
00005146  2020 00   9315          dc.b      32,32,0
                    9316   @m68kde~1_10:
0000514A  0D0A 4669 9317          dc.b      13,10,70,105,108,108,32,77,101,109,111,114,121
0000514E  6C6C 204D 
00005152  656D 6F72 
00005156  79        
00005157  2042 6C6F 9318          dc.b      32,66,108,111,99,107,0
0000515B  636B 00   
                    9319   @m68kde~1_11:
0000515E  0D0A 456E 9320          dc.b      13,10,69,110,116,101,114,32,69,110,100,32,65
00005162  7465 7220 
00005166  456E 6420 
0000516A  41        
0000516B  6464 7265 9321          dc.b      100,100,114,101,115,115,58,32,0
0000516F  7373 3A20 
00005173  00        
                    9322   @m68kde~1_12:
00005174  0D0A 456E 9323          dc.b      13,10,69,110,116,101,114,32,70,105,108,108,32
00005178  7465 7220 
0000517C  4669 6C6C 
00005180  20        
00005181  4461 7461 9324          dc.b      68,97,116,97,58,32,0
00005185  3A20 00   
                    9325   @m68kde~1_13:
00005188  0D0A 4669 9326          dc.b      13,10,70,105,108,108,105,110,103,32,65,100,100
0000518C  6C6C 696E 
00005190  6720 4164 
00005194  64        
00005195  7265 7373 9327          dc.b      114,101,115,115,101,115,32,91,36,37,48,56,88
00005199  6573 205B 
0000519D  2425 3038 
000051A1  58        
000051A2  202D 2024 9328          dc.b      32,45,32,36,37,48,56,88,93,32,119,105,116,104
000051A6  2530 3858 
000051AA  5D20 7769 
000051AE  7468      
000051B0  2024 2530 9329          dc.b      32,36,37,48,50,88,0
000051B4  3258 00   
                    9330   @m68kde~1_14:
000051B8  0D0A 5573 9331          dc.b      13,10,85,115,101,32,72,121,112,101,114,84,101
000051BC  6520 4879 
000051C0  7065 7254 
000051C4  65        
000051C5  726D 696E 9332          dc.b      114,109,105,110,97,108,32,116,111,32,83,101
000051C9  616C 2074 
000051CD  6F20 5365 
000051D1  6E64 2054 9333          dc.b      110,100,32,84,101,120,116,32,70,105,108,101
000051D5  6578 7420 
000051D9  4669 6C65 
000051DD  2028 2E68 9334          dc.b      32,40,46,104,101,120,41,13,10,0
000051E1  6578 290D 
000051E5  0A00      
                    9335   @m68kde~1_15:
000051E8  0D0A 4C6F 9336          dc.b      13,10,76,111,97,100,32,70,97,105,108,101,100
000051EC  6164 2046 
000051F0  6169 6C65 
000051F4  64        
000051F5  2061 7420 9337          dc.b      32,97,116,32,65,100,100,114,101,115,115,32,61
000051F9  4164 6472 
000051FD  6573 7320 
00005201  3D        
00005202  205B 2425 9338          dc.b      32,91,36,37,48,56,88,93,13,10,0
00005206  3038 585D 
0000520A  0D0A 00   
                    9339   @m68kde~1_16:
0000520E  0D0A 5375 9340          dc.b      13,10,83,117,99,99,101,115,115,58,32,68,111
00005212  6363 6573 
00005216  733A 2044 
0000521A  6F        
0000521B  776E 6C6F 9341          dc.b      119,110,108,111,97,100,101,100,32,37,100,32
0000521F  6164 6564 
00005223  2025 6420 
00005227  6279 7465 9342          dc.b      98,121,116,101,115,13,10,0
0000522B  730D 0A00 
                    9343   @m68kde~1_17:
00005230  0D0A 4578 9344          dc.b      13,10,69,120,97,109,105,110,101,32,97,110,100
00005234  616D 696E 
00005238  6520 616E 
0000523C  64        
0000523D  2043 6861 9345          dc.b      32,67,104,97,110,103,101,32,77,101,109,111,114
00005241  6E67 6520 
00005245  4D65 6D6F 
00005249  72        
0000524A  7900      9346          dc.b      121,0
                    9347   @m68kde~1_18:
0000524C  0D0A 3C45 9348          dc.b      13,10,60,69,83,67,62,32,116,111,32,83,116,111
00005250  5343 3E20 
00005254  746F 2053 
00005258  746F      
0000525A  702C 203C 9349          dc.b      112,44,32,60,83,80,65,67,69,62,32,116,111,32
0000525E  5350 4143 
00005262  453E 2074 
00005266  6F20      
00005268  4164 7661 9350          dc.b      65,100,118,97,110,99,101,44,32,39,45,39,32,116
0000526C  6E63 652C 
00005270  2027 2D27 
00005274  2074      
00005276  6F20 476F 9351          dc.b      111,32,71,111,32,66,97,99,107,44,32,60,68,65
0000527A  2042 6163 
0000527E  6B2C 203C 
00005282  4441      
00005284  5441 3E20 9352          dc.b      84,65,62,32,116,111,32,99,104,97,110,103,101
00005288  746F 2063 
0000528C  6861 6E67 
00005290  65        
00005291  00        9353          dc.b      0
                    9354   @m68kde~1_19:
00005292  0D0A 456E 9355          dc.b      13,10,69,110,116,101,114,32,65,100,100,114,101
00005296  7465 7220 
0000529A  4164 6472 
0000529E  65        
0000529F  7373 3A20 9356          dc.b      115,115,58,32,0
000052A3  00        
                    9357   @m68kde~1_20:
000052A4  0D0A 5B25 9358          dc.b      13,10,91,37,48,56,120,93,32,58,32,37,48,50,120
000052A8  3038 785D 
000052AC  203A 2025 
000052B0  3032 78   
000052B3  2020 00   9359          dc.b      32,32,0
                    9360   @m68kde~1_21:
000052B6  0D0A 5761 9361          dc.b      13,10,87,97,114,110,105,110,103,32,67,104,97
000052BA  726E 696E 
000052BE  6720 4368 
000052C2  61        
000052C3  6E67 6520 9362          dc.b      110,103,101,32,70,97,105,108,101,100,58,32,87
000052C7  4661 696C 
000052CB  6564 3A20 
000052CF  57        
000052D0  726F 7465 9363          dc.b      114,111,116,101,32,91,37,48,50,120,93,44,32
000052D4  205B 2530 
000052D8  3278 5D2C 
000052DC  20        
000052DD  5265 6164 9364          dc.b      82,101,97,100,32,91,37,48,50,120,93,0
000052E1  205B 2530 
000052E5  3278 5D00 
                    9365   @m68kde~1_22:
000052EA  0A45 7261 9366          dc.b      10,69,114,97,115,105,110,103,46,46,46,10,0
000052EE  7369 6E67 
000052F2  2E2E 2E0A 
000052F6  00        
                    9367   @m68kde~1_23:
000052F8  0D0A 2050 9368          dc.b      13,10,32,80,114,111,103,114,97,109,109,105,110
000052FC  726F 6772 
00005300  616D 6D69 
00005304  6E        
00005305  6720 436F 9369          dc.b      103,32,67,111,109,112,108,101,116,101,33,0
00005309  6D70 6C65 
0000530D  7465 2100 
                    9370   @m68kde~1_24:
00005312  0D0A 204C 9371          dc.b      13,10,32,76,111,97,100,105,110,103,32,80,114
00005316  6F61 6469 
0000531A  6E67 2050 
0000531E  72        
0000531F  6F67 7261 9372          dc.b      111,103,114,97,109,32,70,114,111,109,32,83,80
00005323  6D20 4672 
00005327  6F6D 2053 
0000532B  50        
0000532C  4920 466C 9373          dc.b      73,32,70,108,97,115,104,46,46,46,46,0
00005330  6173 682E 
00005334  2E2E 2E00 
                    9374   @m68kde~1_25:
00005338  0D0A 2052 9375          dc.b      13,10,32,82,101,97,100,32,68,97,116,97,58,32
0000533C  6561 6420 
00005340  4461 7461 
00005344  3A20      
00005346  2530 3878 9376          dc.b      37,48,56,120,32,10,0
0000534A  200A 00   
                    9377   @m68kde~1_26:
0000534E  4949 435F 9378          dc.b      73,73,67,95,67,82,83,82,32,84,114,97,110,115
00005352  4352 5352 
00005356  2054 7261 
0000535A  6E73      
0000535C  6D69 7420 9379          dc.b      109,105,116,32,40,66,105,110,97,114,121,41,58
00005360  2842 696E 
00005364  6172 7929 
00005368  3A        
00005369  2000      9380          dc.b      32,0
                    9381   @m68kde~1_27:
0000536C  2564 00   9382          dc.b      37,100,0
                    9383   @m68kde~1_28:
00005370  0A00      9384          dc.b      10,0
                    9385   @m68kde~1_29:
00005372  4545 5052 9386          dc.b      69,69,80,82,79,77,32,70,108,97,115,104,32,80
00005376  4F4D 2046 
0000537A  6C61 7368 
0000537E  2050      
00005380  6167 6520 9387          dc.b      97,103,101,32,87,114,105,116,101,58,32,83,116
00005384  5772 6974 
00005388  653A 2053 
0000538C  74        
0000538D  6172 7420 9388          dc.b      97,114,116,32,65,100,100,114,101,115,115,58
00005391  4164 6472 
00005395  6573 733A 
00005399  2030 7825 9389          dc.b      32,48,120,37,120,44,32,110,117,109,98,121,116
0000539D  782C 206E 
000053A1  756D 6279 
000053A5  74        
000053A6  6573 3A20 9390          dc.b      101,115,58,32,37,100,10,0
000053AA  2564 0A00 
                    9391   @m68kde~1_30:
000053AE  0D0A 2042 9392          dc.b      13,10,32,66,108,111,99,107,32,48,32,65,100,100
000053B2  6C6F 636B 
000053B6  2030 2041 
000053BA  6464      
000053BC  7265 7373 9393          dc.b      114,101,115,115,58,32,48,120,37,48,52,88,58
000053C0  3A20 3078 
000053C4  2530 3458 
000053C8  3A        
000053C9  2025 640A 9394          dc.b      32,37,100,10,0
000053CD  00        
                    9395   @m68kde~1_31:
000053CE  0D0A 2045 9396          dc.b      13,10,32,69,120,105,116,105,110,103,32,69,69
000053D2  7869 7469 
000053D6  6E67 2045 
000053DA  45        
000053DB  5052 4F4D 9397          dc.b      80,82,79,77,32,82,101,97,100,32,66,108,111,99
000053DF  2052 6561 
000053E3  6420 426C 
000053E7  6F63      
000053E9  6B20 300A 9398          dc.b      107,32,48,10,0
000053ED  00        
                    9399   @m68kde~1_32:
000053EE  0D0A 2042 9400          dc.b      13,10,32,66,108,111,99,107,32,49,32,65,100,100
000053F2  6C6F 636B 
000053F6  2031 2041 
000053FA  6464      
000053FC  7265 7373 9401          dc.b      114,101,115,115,58,32,48,120,37,48,52,88,58
00005400  3A20 3078 
00005404  2530 3458 
00005408  3A        
00005409  2025 640A 9402          dc.b      32,37,100,10,0
0000540D  00        
                    9403   @m68kde~1_33:
0000540E  0D0A 2045 9404          dc.b      13,10,32,69,120,105,116,105,110,103,32,69,69
00005412  7869 7469 
00005416  6E67 2045 
0000541A  45        
0000541B  5052 4F4D 9405          dc.b      80,82,79,77,32,82,101,97,100,32,66,108,111,99
0000541F  2052 6561 
00005423  6420 426C 
00005427  6F63      
00005429  6B20 310A 9406          dc.b      107,32,49,10,0
0000542D  00        
                    9407   @m68kde~1_34:
0000542E  0D0A 2049 9408          dc.b      13,10,32,73,50,67,32,84,101,115,116,10,0
00005432  3243 2054 
00005436  6573 740A 
0000543A  00        
                    9409   @m68kde~1_35:
0000543C  0D0A 496E 9410          dc.b      13,10,73,110,105,116,105,97,108,105,122,105
00005440  6974 6961 
00005444  6C69 7A69 
00005448  6E67 2049 9411          dc.b      110,103,32,73,50,67,46,46,46,10,0
0000544C  3243 2E2E 
00005450  2E0A 00   
                    9412   @m68kde~1_36:
00005454  0D0A 4368 9413          dc.b      13,10,67,104,111,111,115,101,32,111,112,116
00005458  6F6F 7365 
0000545C  206F 7074 
00005460  696F 6E3A 9414          dc.b      105,111,110,58,10,0
00005464  0A00      
                    9415   @m68kde~1_37:
00005466  3120 5265 9416          dc.b      49,32,82,101,97,100,32,83,105,110,103,108,101
0000546A  6164 2053 
0000546E  696E 676C 
00005472  65        
00005473  2042 7974 9417          dc.b      32,66,121,116,101,32,102,114,111,109,32,69,69
00005477  6520 6672 
0000547B  6F6D 2045 
0000547F  45        
00005480  5052 4F4D 9418          dc.b      80,82,79,77,10,0
00005484  0A00      
                    9419   @m68kde~1_38:
00005486  3220 5772 9420          dc.b      50,32,87,114,105,116,101,32,83,105,110,103,108
0000548A  6974 6520 
0000548E  5369 6E67 
00005492  6C        
00005493  6520 4279 9421          dc.b      101,32,66,121,116,101,32,116,111,32,69,69,80
00005497  7465 2074 
0000549B  6F20 4545 
0000549F  50        
000054A0  524F 4D0A 9422          dc.b      82,79,77,10,0
000054A4  00        
                    9423   @m68kde~1_39:
000054A6  3320 5265 9424          dc.b      51,32,82,101,97,100,32,66,108,111,99,107,32
000054AA  6164 2042 
000054AE  6C6F 636B 
000054B2  20        
000054B3  6F66 2044 9425          dc.b      111,102,32,68,97,116,97,32,102,114,111,109,32
000054B7  6174 6120 
000054BB  6672 6F6D 
000054BF  20        
000054C0  4545 5052 9426          dc.b      69,69,80,82,79,77,10,0
000054C4  4F4D 0A00 
                    9427   @m68kde~1_40:
000054C8  3420 5772 9428          dc.b      52,32,87,114,105,116,101,32,66,108,111,99,107
000054CC  6974 6520 
000054D0  426C 6F63 
000054D4  6B        
000054D5  206F 6620 9429          dc.b      32,111,102,32,68,97,116,97,32,116,111,32,69
000054D9  4461 7461 
000054DD  2074 6F20 
000054E1  45        
000054E2  4550 524F 9430          dc.b      69,80,82,79,77,10,0
000054E6  4D0A 00   
                    9431   @m68kde~1_41:
000054EA  0D0A 5265 9432          dc.b      13,10,82,101,97,100,32,83,105,110,103,108,101
000054EE  6164 2053 
000054F2  696E 676C 
000054F6  65        
000054F7  2042 7974 9433          dc.b      32,66,121,116,101,10,0
000054FB  650A 00   
                    9434   @m68kde~1_42:
000054FE  456E 7465 9435          dc.b      69,110,116,101,114,32,97,100,100,114,101,115
00005502  7220 6164 
00005506  6472 6573 
0000550A  7320 2868 9436          dc.b      115,32,40,104,101,120,41,58,32,48,120,0
0000550E  6578 293A 
00005512  2030 7800 
                    9437   @m68kde~1_43:
00005516  0D0A 5265 9438          dc.b      13,10,82,101,97,100,32,102,114,111,109,32,97
0000551A  6164 2066 
0000551E  726F 6D20 
00005522  61        
00005523  6464 7265 9439          dc.b      100,100,114,101,115,115,32,48,120,37,88,58,32
00005527  7373 2030 
0000552B  7825 583A 
0000552F  20        
00005530  3078 2530 9440          dc.b      48,120,37,48,50,88,10,0
00005534  3258 0A00 
                    9441   @m68kde~1_44:
00005538  0D0A 5772 9442          dc.b      13,10,87,114,105,116,101,32,83,105,110,103,108
0000553C  6974 6520 
00005540  5369 6E67 
00005544  6C        
00005545  6520 4279 9443          dc.b      101,32,66,121,116,101,10,0
00005549  7465 0A00 
                    9444   @m68kde~1_45:
0000554E  0D0A 456E 9445          dc.b      13,10,69,110,116,101,114,32,97,100,100,114,101
00005552  7465 7220 
00005556  6164 6472 
0000555A  65        
0000555B  7373 2028 9446          dc.b      115,115,32,40,104,101,120,41,58,32,48,120,0
0000555F  6865 7829 
00005563  3A20 3078 
00005567  00        
                    9447   @m68kde~1_46:
00005568  0A45 6E74 9448          dc.b      10,69,110,116,101,114,32,119,104,105,99,104
0000556C  6572 2077 
00005570  6869 6368 
00005574  2064 6174 9449          dc.b      32,100,97,116,97,32,112,97,116,116,101,114,110
00005578  6120 7061 
0000557C  7474 6572 
00005580  6E        
00005581  2079 6F75 9450          dc.b      32,121,111,117,32,119,97,110,116,32,116,111
00005585  2077 616E 
00005589  7420 746F 
0000558D  2077 7269 9451          dc.b      32,119,114,105,116,101,32,105,110,116,111,32
00005591  7465 2069 
00005595  6E74 6F20 
00005599  6D65 6D6F 9452          dc.b      109,101,109,111,114,121,58,10,0
0000559D  7279 3A0A 
000055A1  00        
                    9453   @m68kde~1_47:
000055A2  2030 3A20 9454          dc.b      32,48,58,32,48,120,48,48,10,32,49,58,32,48,120
000055A6  3078 3030 
000055AA  0A20 313A 
000055AE  2030 78   
000055B1  4232 0A20 9455          dc.b      66,50,10,32,50,58,32,48,120,67,51,10,32,51,58
000055B5  323A 2030 
000055B9  7843 330A 
000055BD  2033 3A   
000055C0  2030 7844 9456          dc.b      32,48,120,68,52,10,32,52,58,32,67,117,115,116
000055C4  340A 2034 
000055C8  3A20 4375 
000055CC  7374      
000055CE  6F6D 2076 9457          dc.b      111,109,32,118,97,108,117,101,10,0
000055D2  616C 7565 
000055D6  0A00      
                    9458   @m68kde~1_48:
000055D8  5365 6C65 9459          dc.b      83,101,108,101,99,116,32,112,97,116,116,101
000055DC  6374 2070 
000055E0  6174 7465 
000055E4  726E 00   9460          dc.b      114,110,0
                    9461   @m68kde~1_49:
000055E8  5772 6F74 9462          dc.b      87,114,111,116,101,32,48,120,37,48,50,88,32
000055EC  6520 3078 
000055F0  2530 3258 
000055F4  20        
000055F5  746F 2061 9463          dc.b      116,111,32,97,100,100,114,101,115,115,32,48
000055F9  6464 7265 
000055FD  7373 2030 
00005601  7825 580A 9464          dc.b      120,37,88,10,0
00005605  00        
                    9465   @m68kde~1_50:
00005606  5265 6164 9466          dc.b      82,101,97,100,32,98,97,99,107,58,32,48,120,37
0000560A  2062 6163 
0000560E  6B3A 2030 
00005612  7825      
00005614  3032 580A 9467          dc.b      48,50,88,10,0
00005618  00        
                    9468   @m68kde~1_51:
0000561A  0D0A 5265 9469          dc.b      13,10,82,101,97,100,32,66,108,111,99,107,32
0000561E  6164 2042 
00005622  6C6F 636B 
00005626  20        
00005627  6F66 2044 9470          dc.b      111,102,32,68,97,116,97,10,0
0000562B  6174 610A 
0000562F  00        
                    9471   @m68kde~1_52:
00005630  456E 7465 9472          dc.b      69,110,116,101,114,32,115,116,97,114,116,32
00005634  7220 7374 
00005638  6172 7420 
0000563C  6164 6472 9473          dc.b      97,100,100,114,101,115,115,32,40,104,101,120
00005640  6573 7320 
00005644  2868 6578 
00005648  293A 2030 9474          dc.b      41,58,32,48,120,0
0000564C  7800      
                    9475   @m68kde~1_53:
0000564E  0D0A 456E 9476          dc.b      13,10,69,110,116,101,114,32,110,117,109,98,101
00005652  7465 7220 
00005656  6E75 6D62 
0000565A  65        
0000565B  7220 6F66 9477          dc.b      114,32,111,102,32,98,121,116,101,115,32,116
0000565F  2062 7974 
00005663  6573 2074 
00005667  6F20 7265 9478          dc.b      111,32,114,101,97,100,32,40,104,101,120,41,58
0000566B  6164 2028 
0000566F  6865 7829 
00005673  3A        
00005674  2030 7800 9479          dc.b      32,48,120,0
                    9480   @m68kde~1_54:
00005678  0D0A 5265 9481          dc.b      13,10,82,101,97,100,105,110,103,32,48,120,37
0000567C  6164 696E 
00005680  6720 3078 
00005684  25        
00005685  5820 2825 9482          dc.b      88,32,40,37,100,41,32,98,121,116,101,115,32
00005689  6429 2062 
0000568D  7974 6573 
00005691  20        
00005692  7374 6172 9483          dc.b      115,116,97,114,116,105,110,103,32,102,114,111
00005696  7469 6E67 
0000569A  2066 726F 
0000569E  6D20 6164 9484          dc.b      109,32,97,100,100,114,101,115,115,32,48,120
000056A2  6472 6573 
000056A6  7320 3078 
000056AA  2558 2E2E 9485          dc.b      37,88,46,46,46,10,0
000056AE  2E0A 00   
                    9486   @m68kde~1_55:
000056B2  0D0A 5772 9487          dc.b      13,10,87,114,105,116,101,32,66,108,111,99,107
000056B6  6974 6520 
000056BA  426C 6F63 
000056BE  6B        
000056BF  206F 6620 9488          dc.b      32,111,102,32,68,97,116,97,10,0
000056C3  4461 7461 
000056C7  0A00      
                    9489   @m68kde~1_56:
000056CA  0D0A 456E 9490          dc.b      13,10,69,110,116,101,114,32,110,117,109,98,101
000056CE  7465 7220 
000056D2  6E75 6D62 
000056D6  65        
000056D7  7220 6F66 9491          dc.b      114,32,111,102,32,98,121,116,101,115,32,116
000056DB  2062 7974 
000056DF  6573 2074 
000056E3  6F20 7772 9492          dc.b      111,32,119,114,105,116,101,32,40,104,101,120
000056E7  6974 6520 
000056EB  2868 6578 
000056EF  293A 2030 9493          dc.b      41,58,32,48,120,0
000056F3  7800      
                    9494   @m68kde~1_57:
000056F6  0D0A 456E 9495          dc.b      13,10,69,110,116,101,114,32,119,104,105,99,104
000056FA  7465 7220 
000056FE  7768 6963 
00005702  68        
00005703  2064 6174 9496          dc.b      32,100,97,116,97,32,112,97,116,116,101,114,110
00005707  6120 7061 
0000570B  7474 6572 
0000570F  6E        
00005710  2079 6F75 9497          dc.b      32,121,111,117,32,119,97,110,116,32,116,111
00005714  2077 616E 
00005718  7420 746F 
0000571C  2077 7269 9498          dc.b      32,119,114,105,116,101,32,105,110,116,111,32
00005720  7465 2069 
00005724  6E74 6F20 
00005728  6D65 6D6F 9499          dc.b      109,101,109,111,114,121,58,10,0
0000572C  7279 3A0A 
00005730  00        
                    9500   @m68kde~1_58:
00005732  2030 3A20 9501          dc.b      32,48,58,32,48,120,48,48,10,32,49,58,32,48,120
00005736  3078 3030 
0000573A  0A20 313A 
0000573E  2030 78   
00005741  4232 0A20 9502          dc.b      66,50,10,32,50,58,32,48,120,67,51,10,32,51,58
00005745  323A 2030 
00005749  7843 330A 
0000574D  2033 3A   
00005750  2030 7844 9503          dc.b      32,48,120,68,52,10,32,52,58,32,73,110,99,114
00005754  340A 2034 
00005758  3A20 496E 
0000575C  6372      
0000575E  656D 656E 9504          dc.b      101,109,101,110,116,105,110,103,32,112,97,116
00005762  7469 6E67 
00005766  2070 6174 
0000576A  7465 726E 9505          dc.b      116,101,114,110,10,0
0000576E  0A00      
                    9506   @m68kde~1_59:
00005770  5365 6C65 9507          dc.b      83,101,108,101,99,116,101,100,32,105,110,99
00005774  6374 6564 
00005778  2069 6E63 
0000577C  7265 6D65 9508          dc.b      114,101,109,101,110,116,105,110,103,32,112,97
00005780  6E74 696E 
00005784  6720 7061 
00005788  7474 6572 9509          dc.b      116,116,101,114,110,32,40,97,100,100,114,101
0000578C  6E20 2861 
00005790  6464 7265 
00005794  7373 2026 9510          dc.b      115,115,32,38,32,48,120,70,70,41,10,0
00005798  2030 7846 
0000579C  4629 0A00 
                    9511   @m68kde~1_60:
000057A0  5365 6C65 9512          dc.b      83,101,108,101,99,116,101,100,32,112,97,116
000057A4  6374 6564 
000057A8  2070 6174 
000057AC  7465 726E 9513          dc.b      116,101,114,110,58,32,48,120,37,48,50,88,10
000057B0  3A20 3078 
000057B4  2530 3258 
000057B8  0A        
000057B9  00        9514          dc.b      0
                    9515   @m68kde~1_61:
000057BA  0D0A 5072 9516          dc.b      13,10,80,114,101,112,97,114,105,110,103,32,116
000057BE  6570 6172 
000057C2  696E 6720 
000057C6  74        
000057C7  6F20 7772 9517          dc.b      111,32,119,114,105,116,101,32,48,120,37,88,32
000057CB  6974 6520 
000057CF  3078 2558 
000057D3  20        
000057D4  2825 6429 9518          dc.b      40,37,100,41,32,98,121,116,101,115,32,111,102
000057D8  2062 7974 
000057DC  6573 206F 
000057E0  66        
000057E1  2064 6174 9519          dc.b      32,100,97,116,97,32,115,116,97,114,116,105,110
000057E5  6120 7374 
000057E9  6172 7469 
000057ED  6E        
000057EE  6720 6174 9520          dc.b      103,32,97,116,32,97,100,100,114,101,115,115
000057F2  2061 6464 
000057F6  7265 7373 
000057FA  2030 7825 9521          dc.b      32,48,120,37,88,46,46,46,10,0
000057FE  582E 2E2E 
00005802  0A00      
                    9522   @m68kde~1_62:
00005804  0D50 7269 9523          dc.b      13,80,114,105,110,116,105,110,103,32,69,110
00005808  6E74 696E 
0000580C  6720 456E 
00005810  7469 7265 9524          dc.b      116,105,114,101,32,69,69,80,82,79,77,10,0
00005814  2045 4550 
00005818  524F 4D0A 
0000581C  00        
                    9525   @m68kde~1_63:
0000581E  0D0A 2041 9526          dc.b      13,10,32,65,68,67,32,82,101,97,100,58,32,37
00005822  4443 2052 
00005826  6561 643A 
0000582A  2025      
0000582C  640A 00   9527          dc.b      100,10,0
                    9528   @m68kde~1_64:
00005830  2425 3038 9529          dc.b      36,37,48,56,88,32,32,0
00005834  5820 2000 
                    9530   @m68kde~1_65:
00005838  2000      9531          dc.b      32,0
                    9532   @m68kde~1_66:
0000583A  2E00      9533          dc.b      46,0
                    9534   @m68kde~1_67:
0000583C  2563 00   9535          dc.b      37,99,0
                    9536   @m68kde~1_68:
00005840  00        9537          dc.b      0
                    9538   @m68kde~1_69:
00005842  0D0A 0D0A 9539          dc.b      13,10,13,10,32,68,48,32,61,32,36,37,48,56,88
00005846  2044 3020 
0000584A  3D20 2425 
0000584E  3038 58   
00005851  2020 4130 9540          dc.b      32,32,65,48,32,61,32,36,37,48,56,88,0
00005855  203D 2024 
00005859  2530 3858 
0000585D  00        
                    9541   @m68kde~1_70:
0000585E  0D0A 2044 9542          dc.b      13,10,32,68,49,32,61,32,36,37,48,56,88,32,32
00005862  3120 3D20 
00005866  2425 3038 
0000586A  5820 20   
0000586D  4131 203D 9543          dc.b      65,49,32,61,32,36,37,48,56,88,0
00005871  2024 2530 
00005875  3858 00   
                    9544   @m68kde~1_71:
00005878  0D0A 2044 9545          dc.b      13,10,32,68,50,32,61,32,36,37,48,56,88,32,32
0000587C  3220 3D20 
00005880  2425 3038 
00005884  5820 20   
00005887  4132 203D 9546          dc.b      65,50,32,61,32,36,37,48,56,88,0
0000588B  2024 2530 
0000588F  3858 00   
                    9547   @m68kde~1_72:
00005892  0D0A 2044 9548          dc.b      13,10,32,68,51,32,61,32,36,37,48,56,88,32,32
00005896  3320 3D20 
0000589A  2425 3038 
0000589E  5820 20   
000058A1  4133 203D 9549          dc.b      65,51,32,61,32,36,37,48,56,88,0
000058A5  2024 2530 
000058A9  3858 00   
                    9550   @m68kde~1_73:
000058AC  0D0A 2044 9551          dc.b      13,10,32,68,52,32,61,32,36,37,48,56,88,32,32
000058B0  3420 3D20 
000058B4  2425 3038 
000058B8  5820 20   
000058BB  4134 203D 9552          dc.b      65,52,32,61,32,36,37,48,56,88,0
000058BF  2024 2530 
000058C3  3858 00   
                    9553   @m68kde~1_74:
000058C6  0D0A 2044 9554          dc.b      13,10,32,68,53,32,61,32,36,37,48,56,88,32,32
000058CA  3520 3D20 
000058CE  2425 3038 
000058D2  5820 20   
000058D5  4135 203D 9555          dc.b      65,53,32,61,32,36,37,48,56,88,0
000058D9  2024 2530 
000058DD  3858 00   
                    9556   @m68kde~1_75:
000058E0  0D0A 2044 9557          dc.b      13,10,32,68,54,32,61,32,36,37,48,56,88,32,32
000058E4  3620 3D20 
000058E8  2425 3038 
000058EC  5820 20   
000058EF  4136 203D 9558          dc.b      65,54,32,61,32,36,37,48,56,88,0
000058F3  2024 2530 
000058F7  3858 00   
                    9559   @m68kde~1_76:
000058FA  0D0A 2044 9560          dc.b      13,10,32,68,55,32,61,32,36,37,48,56,88,32,32
000058FE  3720 3D20 
00005902  2425 3038 
00005906  5820 20   
00005909  4137 203D 9561          dc.b      65,55,32,61,32,36,37,48,56,88,0
0000590D  2024 2530 
00005911  3858 00   
                    9562   @m68kde~1_77:
00005914  0D0A 0D0A 9563          dc.b      13,10,13,10,85,83,80,32,61,32,36,37,48,56,88
00005918  5553 5020 
0000591C  3D20 2425 
00005920  3038 58   
00005923  2020 2841 9564          dc.b      32,32,40,65,55,41,32,85,115,101,114,32,83,80
00005927  3729 2055 
0000592B  7365 7220 
0000592F  5350      
00005931  00        9565          dc.b      0
                    9566   @m68kde~1_78:
00005932  0D0A 5353 9567          dc.b      13,10,83,83,80,32,61,32,36,37,48,56,88,32,32
00005936  5020 3D20 
0000593A  2425 3038 
0000593E  5820 20   
00005941  2841 3729 9568          dc.b      40,65,55,41,32,83,117,112,101,114,118,105,115
00005945  2053 7570 
00005949  6572 7669 
0000594D  73        
0000594E  6F72 2053 9569          dc.b      111,114,32,83,80,0
00005952  5000      
                    9570   @m68kde~1_79:
00005954  0D0A 2053 9571          dc.b      13,10,32,83,82,32,61,32,36,37,48,52,88,32,32
00005958  5220 3D20 
0000595C  2425 3034 
00005960  5820 20   
00005963  2000      9572          dc.b      32,0
                    9573   @m68kde~1_80:
00005966  2020 205B 9574          dc.b      32,32,32,91,0
0000596A  00        
                    9575   @m68kde~1_81:
0000596C  0D0A 2050 9576          dc.b      13,10,32,80,67,32,61,32,36,37,48,56,88,32,32
00005970  4320 3D20 
00005974  2425 3038 
00005978  5820 20   
0000597B  00        9577          dc.b      0
                    9578   @m68kde~1_82:
0000597C  5B40 2042 9579          dc.b      91,64,32,66,82,69,65,75,80,79,73,78,84,93,0
00005980  5245 414B 
00005984  504F 494E 
00005988  545D 00   
                    9580   @m68kde~1_83:
0000598C  0D0A 5750 9581          dc.b      13,10,87,80,37,100,32,61,32,37,115,0
00005990  2564 203D 
00005994  2025 7300 
                    9582   @m68kde~1_84:
00005998  0D0A 0D0A 9583          dc.b      13,10,13,10,13,10,13,10,13,10,13,10,83,105,110
0000599C  0D0A 0D0A 
000059A0  0D0A 0D0A 
000059A4  5369 6E   
000059A7  676C 6520 9584          dc.b      103,108,101,32,83,116,101,112,32,32,58,91,79
000059AB  5374 6570 
000059AF  2020 3A5B 
000059B3  4F        
000059B4  4E5D 00   9585          dc.b      78,93,0
                    9586   @m68kde~1_85:
000059B8  0D0A 4272 9587          dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
000059BC  6561 6B20 
000059C0  506F 696E 
000059C4  74        
000059C5  7320 3A5B 9588          dc.b      115,32,58,91,68,105,115,97,98,108,101,100,93
000059C9  4469 7361 
000059CD  626C 6564 
000059D1  5D        
000059D2  00        9589          dc.b      0
                    9590   @m68kde~1_86:
000059D4  0D0A 5072 9591          dc.b      13,10,80,114,101,115,115,32,60,83,80,65,67,69
000059D8  6573 7320 
000059DC  3C53 5041 
000059E0  4345      
000059E2  3E20 746F 9592          dc.b      62,32,116,111,32,69,120,101,99,117,116,101,32
000059E6  2045 7865 
000059EA  6375 7465 
000059EE  20        
000059EF  4E65 7874 9593          dc.b      78,101,120,116,32,73,110,115,116,114,117,99
000059F3  2049 6E73 
000059F7  7472 7563 
000059FB  7469 6F6E 9594          dc.b      116,105,111,110,0
000059FF  00        
                    9595   @m68kde~1_87:
00005A00  0D0A 5072 9596          dc.b      13,10,80,114,101,115,115,32,60,69,83,67,62,32
00005A04  6573 7320 
00005A08  3C45 5343 
00005A0C  3E20      
00005A0E  746F 2052 9597          dc.b      116,111,32,82,101,115,117,109,101,32,80,114
00005A12  6573 756D 
00005A16  6520 5072 
00005A1A  6F67 7261 9598          dc.b      111,103,114,97,109,0
00005A1E  6D00      
                    9599   @m68kde~1_88:
00005A20  0D0A 496C 9600          dc.b      13,10,73,108,108,101,103,97,108,32,68,97,116
00005A24  6C65 6761 
00005A28  6C20 4461 
00005A2C  74        
00005A2D  6120 5265 9601          dc.b      97,32,82,101,103,105,115,116,101,114,32,58,32
00005A31  6769 7374 
00005A35  6572 203A 
00005A39  20        
00005A3A  5573 6520 9602          dc.b      85,115,101,32,68,48,45,68,55,46,46,46,46,46
00005A3E  4430 2D44 
00005A42  372E 2E2E 
00005A46  2E2E      
00005A48  0D0A 00   9603          dc.b      13,10,0
                    9604   @m68kde~1_89:
00005A4C  0D0A 4425 9605          dc.b      13,10,68,37,99,32,61,32,0
00005A50  6320 3D20 
00005A54  00        
                    9606   @m68kde~1_90:
00005A56  0D0A 496C 9607          dc.b      13,10,73,108,108,101,103,97,108,32,65,100,100
00005A5A  6C65 6761 
00005A5E  6C20 4164 
00005A62  64        
00005A63  7265 7373 9608          dc.b      114,101,115,115,32,82,101,103,105,115,116,101
00005A67  2052 6567 
00005A6B  6973 7465 
00005A6F  7220 3A20 9609          dc.b      114,32,58,32,85,115,101,32,65,48,45,65,55,46
00005A73  5573 6520 
00005A77  4130 2D41 
00005A7B  372E      
00005A7D  2E2E 2E2E 9610          dc.b      46,46,46,46,13,10,0
00005A81  0D0A 00   
                    9611   @m68kde~1_91:
00005A84  0D0A 4125 9612          dc.b      13,10,65,37,99,32,61,32,0
00005A88  6320 3D20 
00005A8C  00        
                    9613   @m68kde~1_92:
00005A8E  0D0A 5573 9614          dc.b      13,10,85,115,101,114,32,83,80,32,61,32,0
00005A92  6572 2053 
00005A96  5020 3D20 
00005A9A  00        
                    9615   @m68kde~1_93:
00005A9C  0D0A 496C 9616          dc.b      13,10,73,108,108,101,103,97,108,32,82,101,103
00005AA0  6C65 6761 
00005AA4  6C20 5265 
00005AA8  67        
00005AA9  6973 7465 9617          dc.b      105,115,116,101,114,46,46,46,46,0
00005AAD  722E 2E2E 
00005AB1  2E00      
                    9618   @m68kde~1_94:
00005AB4  0D0A 5379 9619          dc.b      13,10,83,121,115,116,101,109,32,83,80,32,61
00005AB8  7374 656D 
00005ABC  2053 5020 
00005AC0  3D        
00005AC1  2000      9620          dc.b      32,0
                    9621   @m68kde~1_95:
00005AC4  0D0A 5043 9622          dc.b      13,10,80,67,32,61,32,0
00005AC8  203D 2000 
                    9623   @m68kde~1_96:
00005ACC  0D0A 5352 9624          dc.b      13,10,83,82,32,61,32,0
00005AD0  203D 2000 
                    9625   @m68kde~1_97:
00005AD4  0D0A 496C 9626          dc.b      13,10,73,108,108,101,103,97,108,32,82,101,103
00005AD8  6C65 6761 
00005ADC  6C20 5265 
00005AE0  67        
00005AE1  6973 7465 9627          dc.b      105,115,116,101,114,58,32,85,115,101,32,65,48
00005AE5  723A 2055 
00005AE9  7365 2041 
00005AED  30        
00005AEE  2D41 372C 9628          dc.b      45,65,55,44,32,68,48,45,68,55,44,32,83,83,80
00005AF2  2044 302D 
00005AF6  4437 2C20 
00005AFA  5353 50   
00005AFD  2C20 5553 9629          dc.b      44,32,85,83,80,44,32,80,67,32,111,114,32,83
00005B01  502C 2050 
00005B05  4320 6F72 
00005B09  2053      
00005B0B  520D 0A00 9630          dc.b      82,13,10,0
                    9631   @m68kde~1_98:
00005B10  0D0A 0D0A 9632          dc.b      13,10,13,10,78,117,109,32,32,32,32,32,65,100
00005B14  4E75 6D20 
00005B18  2020 2020 
00005B1C  4164      
00005B1E  6472 6573 9633          dc.b      100,114,101,115,115,32,32,32,32,32,32,73,110
00005B22  7320 2020 
00005B26  2020 2049 
00005B2A  6E        
00005B2B  7374 7275 9634          dc.b      115,116,114,117,99,116,105,111,110,0
00005B2F  6374 696F 
00005B33  6E00      
                    9635   @m68kde~1_99:
00005B36  0D0A 2D2D 9636          dc.b      13,10,45,45,45,32,32,32,32,32,45,45,45,45,45
00005B3A  2D20 2020 
00005B3E  2020 2D2D 
00005B42  2D2D 2D   
00005B45  2D2D 2D2D 9637          dc.b      45,45,45,45,32,32,32,32,45,45,45,45,45,45,45
00005B49  2020 2020 
00005B4D  2D2D 2D2D 
00005B51  2D2D 2D   
00005B54  2D2D 2D2D 9638          dc.b      45,45,45,45,0
00005B58  00        
                    9639   @m68kde~1_100:
00005B5A  0D0A 4E6F 9640          dc.b      13,10,78,111,32,66,114,101,97,107,80,111,105
00005B5E  2042 7265 
00005B62  616B 506F 
00005B66  69        
00005B67  6E74 7320 9641          dc.b      110,116,115,32,83,101,116,0
00005B6B  5365 7400 
                    9642   @m68kde~1_101:
00005B70  0D0A 2533 9643          dc.b      13,10,37,51,100,32,32,32,32,32,36,37,48,56,120
00005B74  6420 2020 
00005B78  2020 2425 
00005B7C  3038 78   
00005B7F  00        9644          dc.b      0
                    9645   @m68kde~1_102:
00005B80  0D0A 4E75 9646          dc.b      13,10,78,117,109,32,32,32,32,32,65,100,100,114
00005B84  6D20 2020 
00005B88  2020 4164 
00005B8C  6472      
00005B8E  6573 7300 9647          dc.b      101,115,115,0
                    9648   @m68kde~1_103:
00005B92  0D0A 2D2D 9649          dc.b      13,10,45,45,45,32,32,32,32,32,45,45,45,45,45
00005B96  2D20 2020 
00005B9A  2020 2D2D 
00005B9E  2D2D 2D   
00005BA1  2D2D 2D2D 9650          dc.b      45,45,45,45,0
00005BA5  00        
                    9651   @m68kde~1_104:
00005BA6  0D0A 4E6F 9652          dc.b      13,10,78,111,32,87,97,116,99,104,80,111,105
00005BAA  2057 6174 
00005BAE  6368 506F 
00005BB2  69        
00005BB3  6E74 7320 9653          dc.b      110,116,115,32,83,101,116,0
00005BB7  5365 7400 
                    9654   @m68kde~1_105:
00005BBC  0D0A 456E 9655          dc.b      13,10,69,110,116,101,114,32,66,114,101,97,107
00005BC0  7465 7220 
00005BC4  4272 6561 
00005BC8  6B        
00005BC9  2050 6F69 9656          dc.b      32,80,111,105,110,116,32,78,117,109,98,101,114
00005BCD  6E74 204E 
00005BD1  756D 6265 
00005BD5  72        
00005BD6  3A20 00   9657          dc.b      58,32,0
                    9658   @m68kde~1_106:
00005BDA  0D0A 496C 9659          dc.b      13,10,73,108,108,101,103,97,108,32,82,97,110
00005BDE  6C65 6761 
00005BE2  6C20 5261 
00005BE6  6E        
00005BE7  6765 203A 9660          dc.b      103,101,32,58,32,85,115,101,32,48,32,45,32,55
00005BEB  2055 7365 
00005BEF  2030 202D 
00005BF3  2037      
00005BF5  00        9661          dc.b      0
                    9662   @m68kde~1_107:
00005BF6  0D0A 4272 9663          dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
00005BFA  6561 6B20 
00005BFE  506F 696E 
00005C02  74        
00005C03  2043 6C65 9664          dc.b      32,67,108,101,97,114,101,100,46,46,46,46,46
00005C07  6172 6564 
00005C0B  2E2E 2E2E 
00005C0F  2E        
00005C10  0D0A 00   9665          dc.b      13,10,0
                    9666   @m68kde~1_108:
00005C14  0D0A 4272 9667          dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
00005C18  6561 6B20 
00005C1C  506F 696E 
00005C20  74        
00005C21  2077 6173 9668          dc.b      32,119,97,115,110,39,116,32,83,101,116,46,46
00005C25  6E27 7420 
00005C29  5365 742E 
00005C2D  2E        
00005C2E  2E2E 2E00 9669          dc.b      46,46,46,0
                    9670   @m68kde~1_109:
00005C32  0D0A 456E 9671          dc.b      13,10,69,110,116,101,114,32,87,97,116,99,104
00005C36  7465 7220 
00005C3A  5761 7463 
00005C3E  68        
00005C3F  2050 6F69 9672          dc.b      32,80,111,105,110,116,32,78,117,109,98,101,114
00005C43  6E74 204E 
00005C47  756D 6265 
00005C4B  72        
00005C4C  3A20 00   9673          dc.b      58,32,0
                    9674   @m68kde~1_110:
00005C50  0D0A 5761 9675          dc.b      13,10,87,97,116,99,104,32,80,111,105,110,116
00005C54  7463 6820 
00005C58  506F 696E 
00005C5C  74        
00005C5D  2043 6C65 9676          dc.b      32,67,108,101,97,114,101,100,46,46,46,46,46
00005C61  6172 6564 
00005C65  2E2E 2E2E 
00005C69  2E        
00005C6A  0D0A 00   9677          dc.b      13,10,0
                    9678   @m68kde~1_111:
00005C6E  0D0A 5761 9679          dc.b      13,10,87,97,116,99,104,32,80,111,105,110,116
00005C72  7463 6820 
00005C76  506F 696E 
00005C7A  74        
00005C7B  2057 6173 9680          dc.b      32,87,97,115,32,110,111,116,32,83,101,116,46
00005C7F  206E 6F74 
00005C83  2053 6574 
00005C87  2E        
00005C88  2E2E 2E2E 9681          dc.b      46,46,46,46,0
00005C8C  00        
                    9682   @m68kde~1_112:
00005C8E  0D0A 4E6F 9683          dc.b      13,10,78,111,32,70,82,69,69,32,66,114,101,97
00005C92  2046 5245 
00005C96  4520 4272 
00005C9A  6561      
00005C9C  6B20 506F 9684          dc.b      107,32,80,111,105,110,116,115,46,46,46,46,46
00005CA0  696E 7473 
00005CA4  2E2E 2E2E 
00005CA8  2E        
00005CA9  00        9685          dc.b      0
                    9686   @m68kde~1_113:
00005CAA  0D0A 4272 9687          dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
00005CAE  6561 6B20 
00005CB2  506F 696E 
00005CB6  74        
00005CB7  2041 6464 9688          dc.b      32,65,100,100,114,101,115,115,58,32,0
00005CBB  7265 7373 
00005CBF  3A20 00   
                    9689   @m68kde~1_114:
00005CC2  0D0A 4572 9690          dc.b      13,10,69,114,114,111,114,32,58,32,66,114,101
00005CC6  726F 7220 
00005CCA  3A20 4272 
00005CCE  65        
00005CCF  616B 2050 9691          dc.b      97,107,32,80,111,105,110,116,115,32,67,65,78
00005CD3  6F69 6E74 
00005CD7  7320 4341 
00005CDB  4E        
00005CDC  4E4F 5420 9692          dc.b      78,79,84,32,98,101,32,115,101,116,32,97,116
00005CE0  6265 2073 
00005CE4  6574 2061 
00005CE8  74        
00005CE9  204F 4444 9693          dc.b      32,79,68,68,32,97,100,100,114,101,115,115,101
00005CED  2061 6464 
00005CF1  7265 7373 
00005CF5  65        
00005CF6  7300      9694          dc.b      115,0
                    9695   @m68kde~1_115:
00005CF8  0D0A 4572 9696          dc.b      13,10,69,114,114,111,114,32,58,32,66,114,101
00005CFC  726F 7220 
00005D00  3A20 4272 
00005D04  65        
00005D05  616B 2050 9697          dc.b      97,107,32,80,111,105,110,116,115,32,67,65,78
00005D09  6F69 6E74 
00005D0D  7320 4341 
00005D11  4E        
00005D12  4E4F 5420 9698          dc.b      78,79,84,32,98,101,32,115,101,116,32,102,111
00005D16  6265 2073 
00005D1A  6574 2066 
00005D1E  6F        
00005D1F  7220 524F 9699          dc.b      114,32,82,79,77,32,105,110,32,82,97,110,103
00005D23  4D20 696E 
00005D27  2052 616E 
00005D2B  67        
00005D2C  6520 3A20 9700          dc.b      101,32,58,32,91,36,48,45,36,48,48,48,48,55,70
00005D30  5B24 302D 
00005D34  2430 3030 
00005D38  3037 46   
00005D3B  4646 5D00 9701          dc.b      70,70,93,0
                    9702   @m68kde~1_116:
00005D40  0D0A 4572 9703          dc.b      13,10,69,114,114,111,114,58,32,66,114,101,97
00005D44  726F 723A 
00005D48  2042 7265 
00005D4C  61        
00005D4D  6B20 506F 9704          dc.b      107,32,80,111,105,110,116,32,65,108,114,101
00005D51  696E 7420 
00005D55  416C 7265 
00005D59  6164 7920 9705          dc.b      97,100,121,32,69,120,105,115,116,115,32,97,116
00005D5D  4578 6973 
00005D61  7473 2061 
00005D65  74        
00005D66  2041 6464 9706          dc.b      32,65,100,100,114,101,115,115,32,58,32,37,48
00005D6A  7265 7373 
00005D6E  203A 2025 
00005D72  30        
00005D73  3878 0D0A 9707          dc.b      56,120,13,10,0
00005D77  00        
                    9708   @m68kde~1_117:
00005D78  0D0A 4272 9709          dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
00005D7C  6561 6B20 
00005D80  506F 696E 
00005D84  74        
00005D85  2053 6574 9710          dc.b      32,83,101,116,32,97,116,32,65,100,100,114,101
00005D89  2061 7420 
00005D8D  4164 6472 
00005D91  65        
00005D92  7373 3A20 9711          dc.b      115,115,58,32,91,36,37,48,56,120,93,0
00005D96  5B24 2530 
00005D9A  3878 5D00 
                    9712   @m68kde~1_118:
00005D9E  0D0A 4E6F 9713          dc.b      13,10,78,111,32,70,82,69,69,32,87,97,116,99
00005DA2  2046 5245 
00005DA6  4520 5761 
00005DAA  7463      
00005DAC  6820 506F 9714          dc.b      104,32,80,111,105,110,116,115,46,46,46,46,46
00005DB0  696E 7473 
00005DB4  2E2E 2E2E 
00005DB8  2E        
00005DB9  00        9715          dc.b      0
                    9716   @m68kde~1_119:
00005DBA  0D0A 5761 9717          dc.b      13,10,87,97,116,99,104,32,80,111,105,110,116
00005DBE  7463 6820 
00005DC2  506F 696E 
00005DC6  74        
00005DC7  2041 6464 9718          dc.b      32,65,100,100,114,101,115,115,58,32,0
00005DCB  7265 7373 
00005DCF  3A20 00   
                    9719   @m68kde~1_120:
00005DD2  0D0A 4572 9720          dc.b      13,10,69,114,114,111,114,58,32,87,97,116,99
00005DD6  726F 723A 
00005DDA  2057 6174 
00005DDE  63        
00005DDF  6820 506F 9721          dc.b      104,32,80,111,105,110,116,32,65,108,114,101
00005DE3  696E 7420 
00005DE7  416C 7265 
00005DEB  6164 7920 9722          dc.b      97,100,121,32,83,101,116,32,97,116,32,65,100
00005DEF  5365 7420 
00005DF3  6174 2041 
00005DF7  64        
00005DF8  6472 6573 9723          dc.b      100,114,101,115,115,32,58,32,37,48,56,120,13
00005DFC  7320 3A20 
00005E00  2530 3878 
00005E04  0D        
00005E05  0A00      9724          dc.b      10,0
                    9725   @m68kde~1_121:
00005E08  0D0A 5761 9726          dc.b      13,10,87,97,116,99,104,32,80,111,105,110,116
00005E0C  7463 6820 
00005E10  506F 696E 
00005E14  74        
00005E15  2053 6574 9727          dc.b      32,83,101,116,32,97,116,32,65,100,100,114,101
00005E19  2061 7420 
00005E1D  4164 6472 
00005E21  65        
00005E22  7373 3A20 9728          dc.b      115,115,58,32,91,36,37,48,56,120,93,0
00005E26  5B24 2530 
00005E2A  3878 5D00 
                    9729   @m68kde~1_122:
00005E2E  0D0A 0D0A 9730          dc.b      13,10,13,10,13,10,13,10,64,66,82,69,65,75,80
00005E32  0D0A 0D0A 
00005E36  4042 5245 
00005E3A  414B 50   
00005E3D  4F49 4E54 9731          dc.b      79,73,78,84,0
00005E41  00        
                    9732   @m68kde~1_123:
00005E42  0D0A 5369 9733          dc.b      13,10,83,105,110,103,108,101,32,83,116,101,112
00005E46  6E67 6C65 
00005E4A  2053 7465 
00005E4E  70        
00005E4F  203A 205B 9734          dc.b      32,58,32,91,79,78,93,0
00005E53  4F4E 5D00 
                    9735   @m68kde~1_124:
00005E58  0D0A 4272 9736          dc.b      13,10,66,114,101,97,107,80,111,105,110,116,115
00005E5C  6561 6B50 
00005E60  6F69 6E74 
00005E64  73        
00005E65  203A 205B 9737          dc.b      32,58,32,91,69,110,97,98,108,101,100,93,0
00005E69  456E 6162 
00005E6D  6C65 645D 
00005E71  00        
                    9738   @m68kde~1_125:
00005E72  0D0A 5072 9739          dc.b      13,10,80,114,101,115,115,32,60,69,83,67,62,32
00005E76  6573 7320 
00005E7A  3C45 5343 
00005E7E  3E20      
00005E80  746F 2052 9740          dc.b      116,111,32,82,101,115,117,109,101,32,85,115
00005E84  6573 756D 
00005E88  6520 5573 
00005E8C  6572 2050 9741          dc.b      101,114,32,80,114,111,103,114,97,109,13,10,0
00005E90  726F 6772 
00005E94  616D 0D0A 
00005E98  00        
                    9742   @m68kde~1_126:
00005E9A  0D0A 556E 9743          dc.b      13,10,85,110,107,110,111,119,110,32,67,111,109
00005E9E  6B6E 6F77 
00005EA2  6E20 436F 
00005EA6  6D        
00005EA7  6D61 6E64 9744          dc.b      109,97,110,100,46,46,46,46,46,13,10,0
00005EAB  2E2E 2E2E 
00005EAF  2E0D 0A00 
                    9745   @m68kde~1_127:
00005EB4  0D0A 5072 9746          dc.b      13,10,80,114,111,103,114,97,109,32,69,110,100
00005EB8  6F67 7261 
00005EBC  6D20 456E 
00005EC0  64        
00005EC1  6564 2028 9747          dc.b      101,100,32,40,84,82,65,80,32,35,49,53,41,46
00005EC5  5452 4150 
00005EC9  2023 3135 
00005ECD  292E      
00005ECF  2E2E 2E00 9748          dc.b      46,46,46,0
                    9749   @m68kde~1_128:
00005ED4  0D0A 4B69 9750          dc.b      13,10,75,105,108,108,32,65,108,108,32,66,114
00005ED8  6C6C 2041 
00005EDC  6C6C 2042 
00005EE0  72        
00005EE1  6561 6B20 9751          dc.b      101,97,107,32,80,111,105,110,116,115,46,46,46
00005EE5  506F 696E 
00005EE9  7473 2E2E 
00005EED  2E        
00005EEE  2879 2F6E 9752          dc.b      40,121,47,110,41,63,0
00005EF2  293F 00   
                    9753   @m68kde~1_129:
00005EF6  0D0A 4B69 9754          dc.b      13,10,75,105,108,108,32,65,108,108,32,87,97
00005EFA  6C6C 2041 
00005EFE  6C6C 2057 
00005F02  61        
00005F03  7463 6820 9755          dc.b      116,99,104,32,80,111,105,110,116,115,46,46,46
00005F07  506F 696E 
00005F0B  7473 2E2E 
00005F0F  2E        
00005F10  2879 2F6E 9756          dc.b      40,121,47,110,41,63,0
00005F14  293F 00   
                    9757   @m68kde~1_130:
00005F18  0D0A 2D2D 9758          dc.b      13,10,45,45,45,45,45,45,45,45,45,45,45,45,45
00005F1C  2D2D 2D2D 
00005F20  2D2D 2D2D 
00005F24  2D2D 2D   
00005F27  2D2D 2D2D 9759          dc.b      45,45,45,45,45,45,45,45,45,45,45,45,45,45,45
00005F2B  2D2D 2D2D 
00005F2F  2D2D 2D2D 
00005F33  2D2D 2D   
00005F36  2D2D 2D2D 9760          dc.b      45,45,45,45,45,45,45,45,45,45,45,45,45,45,45
00005F3A  2D2D 2D2D 
00005F3E  2D2D 2D2D 
00005F42  2D2D 2D   
00005F45  2D2D 2D2D 9761          dc.b      45,45,45,45,45,45,45,45,45,45,45,45,45,45,45
00005F49  2D2D 2D2D 
00005F4D  2D2D 2D2D 
00005F51  2D2D 2D   
00005F54  2D2D 2D2D 9762          dc.b      45,45,45,45,45,45,0
00005F58  2D2D 00   
                    9763   @m68kde~1_131:
00005F5C  0D0A 2020 9764          dc.b      13,10,32,32,68,101,98,117,103,103,101,114,32
00005F60  4465 6275 
00005F64  6767 6572 
00005F68  20        
00005F69  436F 6D6D 9765          dc.b      67,111,109,109,97,110,100,32,83,117,109,109
00005F6D  616E 6420 
00005F71  5375 6D6D 
00005F75  6172 7900 9766          dc.b      97,114,121,0
                    9767   @m68kde~1_132:
00005F7A  0D0A 2020 9768          dc.b      13,10,32,32,46,40,114,101,103,41,32,32,32,32
00005F7E  2E28 7265 
00005F82  6729 2020 
00005F86  2020      
00005F88  2020 202D 9769          dc.b      32,32,32,45,32,67,104,97,110,103,101,32,82,101
00005F8C  2043 6861 
00005F90  6E67 6520 
00005F94  5265      
00005F96  6769 7374 9770          dc.b      103,105,115,116,101,114,115,58,32,101,46,103
00005F9A  6572 733A 
00005F9E  2065 2E67 
00005FA2  2041 302D 9771          dc.b      32,65,48,45,65,55,44,68,48,45,68,55,44,80,67
00005FA6  4137 2C44 
00005FAA  302D 4437 
00005FAE  2C50 43   
00005FB1  2C53 5350 9772          dc.b      44,83,83,80,44,85,83,80,44,83,82,0
00005FB5  2C55 5350 
00005FB9  2C53 5200 
                    9773   @m68kde~1_133:
00005FBE  0D0A 2020 9774          dc.b      13,10,32,32,66,68,47,66,83,47,66,67,47,66,75
00005FC2  4244 2F42 
00005FC6  532F 4243 
00005FCA  2F42 4B   
00005FCD  2020 2D20 9775          dc.b      32,32,45,32,66,114,101,97,107,32,80,111,105
00005FD1  4272 6561 
00005FD5  6B20 506F 
00005FD9  69        
00005FDA  6E74 3A20 9776          dc.b      110,116,58,32,68,105,115,112,108,97,121,47,83
00005FDE  4469 7370 
00005FE2  6C61 792F 
00005FE6  53        
00005FE7  6574 2F43 9777          dc.b      101,116,47,67,108,101,97,114,47,75,105,108,108
00005FEB  6C65 6172 
00005FEF  2F4B 696C 
00005FF3  6C        
00005FF4  00        9778          dc.b      0
                    9779   @m68kde~1_134:
00005FF6  0D0A 2020 9780          dc.b      13,10,32,32,67,32,32,32,32,32,32,32,32,32,32
00005FFA  4320 2020 
00005FFE  2020 2020 
00006002  2020 20   
00006005  2020 2D20 9781          dc.b      32,32,45,32,67,111,112,121,32,80,114,111,103
00006009  436F 7079 
0000600D  2050 726F 
00006011  67        
00006012  7261 6D20 9782          dc.b      114,97,109,32,102,114,111,109,32,70,108,97,115
00006016  6672 6F6D 
0000601A  2046 6C61 
0000601E  73        
0000601F  6820 746F 9783          dc.b      104,32,116,111,32,77,97,105,110,32,77,101,109
00006023  204D 6169 
00006027  6E20 4D65 
0000602B  6D        
0000602C  6F72 7900 9784          dc.b      111,114,121,0
                    9785   @m68kde~1_135:
00006030  0D0A 2020 9786          dc.b      13,10,32,32,68,32,32,32,32,32,32,32,32,32,32
00006034  4420 2020 
00006038  2020 2020 
0000603C  2020 20   
0000603F  2020 2D20 9787          dc.b      32,32,45,32,68,117,109,112,32,77,101,109,111
00006043  4475 6D70 
00006047  204D 656D 
0000604B  6F        
0000604C  7279 2043 9788          dc.b      114,121,32,67,111,110,116,101,110,116,115,32
00006050  6F6E 7465 
00006054  6E74 7320 
00006058  746F 2053 9789          dc.b      116,111,32,83,99,114,101,101,110,0
0000605C  6372 6565 
00006060  6E00      
                    9790   @m68kde~1_136:
00006062  0D0A 2020 9791          dc.b      13,10,32,32,69,32,32,32,32,32,32,32,32,32,32
00006066  4520 2020 
0000606A  2020 2020 
0000606E  2020 20   
00006071  2020 2D20 9792          dc.b      32,32,45,32,69,110,116,101,114,32,83,116,114
00006075  456E 7465 
00006079  7220 5374 
0000607D  72        
0000607E  696E 6720 9793          dc.b      105,110,103,32,105,110,116,111,32,77,101,109
00006082  696E 746F 
00006086  204D 656D 
0000608A  6F72 7900 9794          dc.b      111,114,121,0
                    9795   @m68kde~1_137:
0000608E  0D0A 2020 9796          dc.b      13,10,32,32,70,32,32,32,32,32,32,32,32,32,32
00006092  4620 2020 
00006096  2020 2020 
0000609A  2020 20   
0000609D  2020 2D20 9797          dc.b      32,32,45,32,70,105,108,108,32,77,101,109,111
000060A1  4669 6C6C 
000060A5  204D 656D 
000060A9  6F        
000060AA  7279 2077 9798          dc.b      114,121,32,119,105,116,104,32,68,97,116,97,0
000060AE  6974 6820 
000060B2  4461 7461 
000060B6  00        
                    9799   @m68kde~1_138:
000060B8  0D0A 2020 9800          dc.b      13,10,32,32,71,32,32,32,32,32,32,32,32,32,32
000060BC  4720 2020 
000060C0  2020 2020 
000060C4  2020 20   
000060C7  2020 2D20 9801          dc.b      32,32,45,32,71,111,32,80,114,111,103,114,97
000060CB  476F 2050 
000060CF  726F 6772 
000060D3  61        
000060D4  6D20 5374 9802          dc.b      109,32,83,116,97,114,116,105,110,103,32,97,116
000060D8  6172 7469 
000060DC  6E67 2061 
000060E0  74        
000060E1  2041 6464 9803          dc.b      32,65,100,100,114,101,115,115,58,32,36,37,48
000060E5  7265 7373 
000060E9  3A20 2425 
000060ED  30        
000060EE  3858 00   9804          dc.b      56,88,0
                    9805   @m68kde~1_139:
000060F2  0D0A 2020 9806          dc.b      13,10,32,32,76,32,32,32,32,32,32,32,32,32,32
000060F6  4C20 2020 
000060FA  2020 2020 
000060FE  2020 20   
00006101  2020 2D20 9807          dc.b      32,32,45,32,76,111,97,100,32,80,114,111,103
00006105  4C6F 6164 
00006109  2050 726F 
0000610D  67        
0000610E  7261 6D20 9808          dc.b      114,97,109,32,40,46,72,69,88,32,102,105,108
00006112  282E 4845 
00006116  5820 6669 
0000611A  6C        
0000611B  6529 2066 9809          dc.b      101,41,32,102,114,111,109,32,76,97,112,116,111
0000611F  726F 6D20 
00006123  4C61 7074 
00006127  6F        
00006128  7000      9810          dc.b      112,0
                    9811   @m68kde~1_140:
0000612A  0D0A 2020 9812          dc.b      13,10,32,32,77,32,32,32,32,32,32,32,32,32,32
0000612E  4D20 2020 
00006132  2020 2020 
00006136  2020 20   
00006139  2020 2D20 9813          dc.b      32,32,45,32,77,101,109,111,114,121,32,69,120
0000613D  4D65 6D6F 
00006141  7279 2045 
00006145  78        
00006146  616D 696E 9814          dc.b      97,109,105,110,101,32,97,110,100,32,67,104,97
0000614A  6520 616E 
0000614E  6420 4368 
00006152  61        
00006153  6E67 6500 9815          dc.b      110,103,101,0
                    9816   @m68kde~1_141:
00006158  0D0A 2020 9817          dc.b      13,10,32,32,80,32,32,32,32,32,32,32,32,32,32
0000615C  5020 2020 
00006160  2020 2020 
00006164  2020 20   
00006167  2020 2D20 9818          dc.b      32,32,45,32,80,114,111,103,114,97,109,32,70
0000616B  5072 6F67 
0000616F  7261 6D20 
00006173  46        
00006174  6C61 7368 9819          dc.b      108,97,115,104,32,77,101,109,111,114,121,32
00006178  204D 656D 
0000617C  6F72 7920 
00006180  7769 7468 9820          dc.b      119,105,116,104,32,85,115,101,114,32,80,114
00006184  2055 7365 
00006188  7220 5072 
0000618C  6F67 7261 9821          dc.b      111,103,114,97,109,0
00006190  6D00      
                    9822   @m68kde~1_142:
00006192  0D0A 2020 9823          dc.b      13,10,32,32,82,32,32,32,32,32,32,32,32,32,32
00006196  5220 2020 
0000619A  2020 2020 
0000619E  2020 20   
000061A1  2020 2D20 9824          dc.b      32,32,45,32,68,105,115,112,108,97,121,32,54
000061A5  4469 7370 
000061A9  6C61 7920 
000061AD  36        
000061AE  3830 3030 9825          dc.b      56,48,48,48,32,82,101,103,105,115,116,101,114
000061B2  2052 6567 
000061B6  6973 7465 
000061BA  72        
000061BB  7300      9826          dc.b      115,0
                    9827   @m68kde~1_143:
000061BE  0D0A 2020 9828          dc.b      13,10,32,32,83,32,32,32,32,32,32,32,32,32,32
000061C2  5320 2020 
000061C6  2020 2020 
000061CA  2020 20   
000061CD  2020 2D20 9829          dc.b      32,32,45,32,84,111,103,103,108,101,32,79,78
000061D1  546F 6767 
000061D5  6C65 204F 
000061D9  4E        
000061DA  2F4F 4646 9830          dc.b      47,79,70,70,32,83,105,110,103,108,101,32,83
000061DE  2053 696E 
000061E2  676C 6520 
000061E6  53        
000061E7  7465 7020 9831          dc.b      116,101,112,32,77,111,100,101,0
000061EB  4D6F 6465 
000061EF  00        
                    9832   @m68kde~1_144:
000061F0  0D0A 2020 9833          dc.b      13,10,32,32,84,77,32,32,32,32,32,32,32,32,32
000061F4  544D 2020 
000061F8  2020 2020 
000061FC  2020 20   
000061FF  2020 2D20 9834          dc.b      32,32,45,32,84,101,115,116,32,77,101,109,111
00006203  5465 7374 
00006207  204D 656D 
0000620B  6F        
0000620C  7279 00   9835          dc.b      114,121,0
                    9836   @m68kde~1_145:
00006210  0D0A 2020 9837          dc.b      13,10,32,32,84,83,32,32,32,32,32,32,32,32,32
00006214  5453 2020 
00006218  2020 2020 
0000621C  2020 20   
0000621F  2020 2D20 9838          dc.b      32,32,45,32,84,101,115,116,32,83,119,105,116
00006223  5465 7374 
00006227  2053 7769 
0000622B  74        
0000622C  6368 6573 9839          dc.b      99,104,101,115,58,32,83,87,55,45,48,0
00006230  3A20 5357 
00006234  372D 3000 
                    9840   @m68kde~1_146:
00006238  0D0A 2020 9841          dc.b      13,10,32,32,84,68,32,32,32,32,32,32,32,32,32
0000623C  5444 2020 
00006240  2020 2020 
00006244  2020 20   
00006247  2020 2D20 9842          dc.b      32,32,45,32,84,101,115,116,32,68,105,115,112
0000624B  5465 7374 
0000624F  2044 6973 
00006253  70        
00006254  6C61 7973 9843          dc.b      108,97,121,115,58,32,76,69,68,115,32,97,110
00006258  3A20 4C45 
0000625C  4473 2061 
00006260  6E        
00006261  6420 372D 9844          dc.b      100,32,55,45,83,101,103,109,101,110,116,0
00006265  5365 676D 
00006269  656E 7400 
                    9845   @m68kde~1_147:
0000626E  0D0A 2020 9846          dc.b      13,10,32,32,87,68,47,87,83,47,87,67,47,87,75
00006272  5744 2F57 
00006276  532F 5743 
0000627A  2F57 4B   
0000627D  2020 2D20 9847          dc.b      32,32,45,32,87,97,116,99,104,32,80,111,105,110
00006281  5761 7463 
00006285  6820 506F 
00006289  696E      
0000628B  743A 2044 9848          dc.b      116,58,32,68,105,115,112,108,97,121,47,83,101
0000628F  6973 706C 
00006293  6179 2F53 
00006297  65        
00006298  742F 436C 9849          dc.b      116,47,67,108,101,97,114,47,75,105,108,108,0
0000629C  6561 722F 
000062A0  4B69 6C6C 
000062A4  00        
                    9850   @m68kde~1_148:
000062A6  0D0A 2300 9851          dc.b      13,10,35,0
                    9852   @m68kde~1_149:
000062AA  0D0A 5072 9853          dc.b      13,10,80,114,111,103,114,97,109,32,82,117,110
000062AE  6F67 7261 
000062B2  6D20 5275 
000062B6  6E        
000062B7  6E69 6E67 9854          dc.b      110,105,110,103,46,46,46,46,46,0
000062BB  2E2E 2E2E 
000062BF  2E00      
                    9855   @m68kde~1_150:
000062C2  0D0A 5072 9856          dc.b      13,10,80,114,101,115,115,32,60,82,69,83,69,84
000062C6  6573 7320 
000062CA  3C52 4553 
000062CE  4554      
000062D0  3E20 6275 9857          dc.b      62,32,98,117,116,116,111,110,32,60,75,101,121
000062D4  7474 6F6E 
000062D8  203C 4B65 
000062DC  79        
000062DD  303E 206F 9858          dc.b      48,62,32,111,110,32,68,69,49,32,116,111,32,115
000062E1  6E20 4445 
000062E5  3120 746F 
000062E9  2073      
000062EB  746F 7000 9859          dc.b      116,111,112,0
                    9860   @m68kde~1_151:
000062F0  0D0A 4572 9861          dc.b      13,10,69,114,114,111,114,58,32,80,114,101,115
000062F4  726F 723A 
000062F8  2050 7265 
000062FC  73        
000062FD  7320 2747 9862          dc.b      115,32,39,71,39,32,102,105,114,115,116,32,116
00006301  2720 6669 
00006305  7273 7420 
00006309  74        
0000630A  6F20 7374 9863          dc.b      111,32,115,116,97,114,116,32,112,114,111,103
0000630E  6172 7420 
00006312  7072 6F67 
00006316  7261 6D00 9864          dc.b      114,97,109,0
                    9865   @m68kde~1_152:
0000631A  0D0A 5369 9866          dc.b      13,10,83,105,110,103,108,101,32,83,116,101,112
0000631E  6E67 6C65 
00006322  2053 7465 
00006326  70        
00006327  2020 3A5B 9867          dc.b      32,32,58,91,79,78,93,0
0000632B  4F4E 5D00 
                    9868   @m68kde~1_153:
00006330  0D0A 5072 9869          dc.b      13,10,80,114,101,115,115,32,39,71,39,32,116
00006334  6573 7320 
00006338  2747 2720 
0000633C  74        
0000633D  6F20 5472 9870          dc.b      111,32,84,114,97,99,101,32,80,114,111,103,114
00006341  6163 6520 
00006345  5072 6F67 
00006349  72        
0000634A  616D 2066 9871          dc.b      97,109,32,102,114,111,109,32,97,100,100,114
0000634E  726F 6D20 
00006352  6164 6472 
00006356  6573 7320 9872          dc.b      101,115,115,32,36,37,88,46,46,46,46,46,0
0000635A  2425 582E 
0000635E  2E2E 2E2E 
00006362  00        
                    9873   @m68kde~1_154:
00006364  0D0A 5075 9874          dc.b      13,10,80,117,115,104,32,60,82,69,83,69,84,32
00006368  7368 203C 
0000636C  5245 5345 
00006370  5420      
00006372  4275 7474 9875          dc.b      66,117,116,116,111,110,62,32,116,111,32,83,116
00006376  6F6E 3E20 
0000637A  746F 2053 
0000637E  74        
0000637F  6F70 2E2E 9876          dc.b      111,112,46,46,46,46,46,0
00006383  2E2E 2E00 
                    9877   @m68kde~1_155:
00006388  0D0A 5369 9878          dc.b      13,10,83,105,110,103,108,101,32,83,116,101,112
0000638C  6E67 6C65 
00006390  2053 7465 
00006394  70        
00006395  203A 205B 9879          dc.b      32,58,32,91,79,70,70,93,0
00006399  4F46 465D 
0000639D  00        
                    9880   @m68kde~1_156:
0000639E  0D0A 4272 9881          dc.b      13,10,66,114,101,97,107,32,80,111,105,110,116
000063A2  6561 6B20 
000063A6  506F 696E 
000063AA  74        
000063AB  7320 3A5B 9882          dc.b      115,32,58,91,69,110,97,98,108,101,100,93,0
000063AF  456E 6162 
000063B3  6C65 645D 
000063B7  00        
                    9883   @m68kde~1_157:
000063B8  0D0A 5072 9884          dc.b      13,10,80,114,101,115,115,32,60,69,83,67,62,32
000063BC  6573 7320 
000063C0  3C45 5343 
000063C4  3E20      
000063C6  746F 2052 9885          dc.b      116,111,32,82,101,115,117,109,101,32,85,115
000063CA  6573 756D 
000063CE  6520 5573 
000063D2  6572 2050 9886          dc.b      101,114,32,80,114,111,103,114,97,109,46,46,46
000063D6  726F 6772 
000063DA  616D 2E2E 
000063DE  2E        
000063DF  2E2E 00   9887          dc.b      46,46,0
                    9888   @m68kde~1_158:
000063E2  0D0A 5369 9889          dc.b      13,10,83,105,110,103,108,101,32,83,116,101,112
000063E6  6E67 6C65 
000063EA  2053 7465 
000063EE  70        
000063EF  2020 3A5B 9890          dc.b      32,32,58,91,79,70,70,93,0
000063F3  4F46 465D 
000063F7  00        
                    9891   @m68kde~1_159:
000063F8  0D0A 0D0A 9892          dc.b      13,10,13,10,80,114,111,103,114,97,109,32,65
000063FC  5072 6F67 
00006400  7261 6D20 
00006404  41        
00006405  424F 5254 9893          dc.b      66,79,82,84,32,33,33,33,33,33,33,13,10,0
00006409  2021 2121 
0000640D  2121 210D 
00006411  0A00      
                    9894   @m68kde~1_160:
00006414  2573 0D0A 9895          dc.b      37,115,13,10,0
00006418  00        
                    9896   @m68kde~1_161:
0000641A  0D0A 0D0A 9897          dc.b      13,10,13,10,80,114,111,103,114,97,109,32,65
0000641E  5072 6F67 
00006422  7261 6D20 
00006426  41        
00006427  424F 5254 9898          dc.b      66,79,82,84,32,33,33,33,33,33,0
0000642B  2021 2121 
0000642F  2121 00   
                    9899   @m68kde~1_162:
00006432  0D0A 556E 9900          dc.b      13,10,85,110,104,97,110,100,108,101,100,32,73
00006436  6861 6E64 
0000643A  6C65 6420 
0000643E  49        
0000643F  6E74 6572 9901          dc.b      110,116,101,114,114,117,112,116,58,32,73,82
00006443  7275 7074 
00006447  3A20 4952 
0000644B  5125 6420 9902          dc.b      81,37,100,32,33,33,33,33,33,0
0000644F  2121 2121 
00006453  2100      
                    9903   @m68kde~1_163:
00006456  4144 4452 9904          dc.b      65,68,68,82,69,83,83,32,69,82,82,79,82,58,32
0000645A  4553 5320 
0000645E  4552 524F 
00006462  523A 20   
00006465  3136 206F 9905          dc.b      49,54,32,111,114,32,51,50,32,66,105,116,32,84
00006469  7220 3332 
0000646D  2042 6974 
00006471  2054      
00006473  7261 6E73 9906          dc.b      114,97,110,115,102,101,114,32,116,111,47,102
00006477  6665 7220 
0000647B  746F 2F66 
0000647F  726F 6D20 9907          dc.b      114,111,109,32,97,110,32,79,68,68,32,65,100
00006483  616E 204F 
00006487  4444 2041 
0000648B  64        
0000648C  6472 6573 9908          dc.b      100,114,101,115,115,46,46,46,46,0
00006490  732E 2E2E 
00006494  2E00      
                    9909   @m68kde~1_164:
00006496  556E 6861 9910          dc.b      85,110,104,97,110,100,108,101,100,32,84,114
0000649A  6E64 6C65 
0000649E  6420 5472 
000064A2  6170 2021 9911          dc.b      97,112,32,33,33,33,33,33,0
000064A6  2121 2121 
000064AA  00        
                    9912   @m68kde~1_165:
000064AC  4255 5320 9913          dc.b      66,85,83,32,69,114,114,111,114,33,0
000064B0  4572 726F 
000064B4  7221 00   
                    9914   @m68kde~1_166:
000064B8  4144 4452 9915          dc.b      65,68,68,82,69,83,83,32,69,114,114,111,114,33
000064BC  4553 5320 
000064C0  4572 726F 
000064C4  7221      
000064C6  00        9916          dc.b      0
                    9917   @m68kde~1_167:
000064C8  494C 4C45 9918          dc.b      73,76,76,69,71,65,76,32,73,78,83,84,82,85,67
000064CC  4741 4C20 
000064D0  494E 5354 
000064D4  5255 43   
000064D7  5449 4F4E 9919          dc.b      84,73,79,78,0
000064DB  00        
                    9920   @m68kde~1_168:
000064DC  4449 5649 9921          dc.b      68,73,86,73,68,69,32,66,89,32,90,69,82,79,0
000064E0  4445 2042 
000064E4  5920 5A45 
000064E8  524F 00   
                    9922   @m68kde~1_169:
000064EC  2743 484B 9923          dc.b      39,67,72,75,39,32,73,78,83,84,82,85,67,84,73
000064F0  2720 494E 
000064F4  5354 5255 
000064F8  4354 49   
000064FB  4F4E 00   9924          dc.b      79,78,0
                    9925   @m68kde~1_170:
000064FE  5452 4150 9926          dc.b      84,82,65,80,86,32,73,78,83,84,82,85,67,84,73
00006502  5620 494E 
00006506  5354 5255 
0000650A  4354 49   
0000650D  4F4E 00   9927          dc.b      79,78,0
                    9928   @m68kde~1_171:
00006510  5052 4956 9929          dc.b      80,82,73,86,73,76,69,71,69,32,86,73,79,76,65
00006514  494C 4547 
00006518  4520 5649 
0000651C  4F4C 41   
0000651F  5449 4F4E 9930          dc.b      84,73,79,78,0
00006523  00        
                    9931   @m68kde~1_172:
00006524  554E 494E 9932          dc.b      85,78,73,78,73,84,73,65,76,73,83,69,68,32,73
00006528  4954 4941 
0000652C  4C49 5345 
00006530  4420 49   
00006533  5251 00   9933          dc.b      82,81,0
                    9934   @m68kde~1_173:
00006536  5350 5552 9935          dc.b      83,80,85,82,73,79,85,83,32,73,82,81,0
0000653A  494F 5553 
0000653E  2049 5251 
00006542  00        
                    9936   @m68kde~1_174:
00006544  0D0A 5374 9937          dc.b      13,10,83,116,97,114,116,32,65,100,100,114,101
00006548  6172 7420 
0000654C  4164 6472 
00006550  65        
00006551  7373 2069 9938          dc.b      115,115,32,105,110,32,77,101,109,111,114,121
00006555  6E20 4D65 
00006559  6D6F 7279 
0000655D  3A20 00   9939          dc.b      58,32,0
                    9940   @m68kde~1_175:
00006560  0D0A 456E 9941          dc.b      13,10,69,110,116,101,114,32,83,116,114,105,110
00006564  7465 7220 
00006568  5374 7269 
0000656C  6E        
0000656D  6720 2845 9942          dc.b      103,32,40,69,83,67,32,116,111,32,101,110,100
00006571  5343 2074 
00006575  6F20 656E 
00006579  64        
0000657A  2920 3A00 9943          dc.b      41,32,58,0
                    9944   @m68kde~1_176:
0000657E  0A45 6E74 9945          dc.b      10,69,110,116,101,114,32,119,104,97,116,32,115
00006582  6572 2077 
00006586  6861 7420 
0000658A  73        
0000658B  697A 6520 9946          dc.b      105,122,101,32,111,102,32,109,101,109,111,114
0000658F  6F66 206D 
00006593  656D 6F72 
00006597  7920 796F 9947          dc.b      121,32,121,111,117,32,119,97,110,116,32,116
0000659B  7520 7761 
0000659F  6E74 2074 
000065A3  6F20 7265 9948          dc.b      111,32,114,101,97,100,47,119,114,105,116,101
000065A7  6164 2F77 
000065AB  7269 7465 
000065AF  0A20 4279 9949          dc.b      10,32,66,121,116,101,32,61,32,48,10,32,87,111
000065B3  7465 203D 
000065B7  2030 0A20 
000065BB  576F      
000065BD  7264 203D 9950          dc.b      114,100,32,61,32,49,10,32,76,111,110,103,32
000065C1  2031 0A20 
000065C5  4C6F 6E67 
000065C9  20        
000065CA  576F 7264 9951          dc.b      87,111,114,100,32,61,32,50,10,0
000065CE  203D 2032 
000065D2  0A00      
                    9952   @m68kde~1_177:
000065D4  0A45 6E74 9953          dc.b      10,69,110,116,101,114,32,119,104,105,99,104
000065D8  6572 2077 
000065DC  6869 6368 
000065E0  2064 6174 9954          dc.b      32,100,97,116,97,32,112,97,116,116,101,114,110
000065E4  6120 7061 
000065E8  7474 6572 
000065EC  6E        
000065ED  2079 6F75 9955          dc.b      32,121,111,117,32,119,97,110,116,32,116,111
000065F1  2077 616E 
000065F5  7420 746F 
000065F9  2077 7269 9956          dc.b      32,119,114,105,116,101,32,105,110,116,111,32
000065FD  7465 2069 
00006601  6E74 6F20 
00006605  6D65 6D6F 9957          dc.b      109,101,109,111,114,121,10,32,48,120,48,48,32
00006609  7279 0A20 
0000660D  3078 3030 
00006611  20        
00006612  3D20 300A 9958          dc.b      61,32,48,10,32,48,120,66,50,32,61,32,49,10,32
00006616  2030 7842 
0000661A  3220 3D20 
0000661E  310A 20   
00006621  3078 4333 9959          dc.b      48,120,67,51,32,61,32,50,10,32,48,120,68,52
00006625  203D 2032 
00006629  0A20 3078 
0000662D  4434      
0000662F  203D 2033 9960          dc.b      32,61,32,51,10,0
00006633  0A00      
                    9961   @m68kde~1_178:
00006636  0A45 6E74 9962          dc.b      10,69,110,116,101,114,32,119,104,105,99,104
0000663A  6572 2077 
0000663E  6869 6368 
00006642  2064 6174 9963          dc.b      32,100,97,116,97,32,112,97,116,116,101,114,110
00006646  6120 7061 
0000664A  7474 6572 
0000664E  6E        
0000664F  2079 6F75 9964          dc.b      32,121,111,117,32,119,97,110,116,32,116,111
00006653  2077 616E 
00006657  7420 746F 
0000665B  2077 7269 9965          dc.b      32,119,114,105,116,101,32,105,110,116,111,32
0000665F  7465 2069 
00006663  6E74 6F20 
00006667  6D65 6D6F 9966          dc.b      109,101,109,111,114,121,10,32,48,120,48,48,48
0000666B  7279 0A20 
0000666F  3078 3030 
00006673  30        
00006674  3020 3D20 9967          dc.b      48,32,61,32,48,10,32,48,120,49,50,51,52,32,61
00006678  300A 2030 
0000667C  7831 3233 
00006680  3420 3D   
00006683  2031 0A20 9968          dc.b      32,49,10,32,48,120,65,49,66,50,32,61,32,50,10
00006687  3078 4131 
0000668B  4232 203D 
0000668F  2032 0A   
00006692  2030 7843 9969          dc.b      32,48,120,67,51,68,52,32,61,32,51,10,0
00006696  3344 3420 
0000669A  3D20 330A 
0000669E  00        
                    9970   @m68kde~1_179:
000066A0  0A45 6E74 9971          dc.b      10,69,110,116,101,114,32,119,104,105,99,104
000066A4  6572 2077 
000066A8  6869 6368 
000066AC  2064 6174 9972          dc.b      32,100,97,116,97,32,112,97,116,116,101,114,110
000066B0  6120 7061 
000066B4  7474 6572 
000066B8  6E        
000066B9  2079 6F75 9973          dc.b      32,121,111,117,32,119,97,110,116,32,116,111
000066BD  2077 616E 
000066C1  7420 746F 
000066C5  2077 7269 9974          dc.b      32,119,114,105,116,101,32,105,110,116,111,32
000066C9  7465 2069 
000066CD  6E74 6F20 
000066D1  6D65 6D6F 9975          dc.b      109,101,109,111,114,121,10,32,48,120,48,48,48
000066D5  7279 0A20 
000066D9  3078 3030 
000066DD  30        
000066DE  305F 3030 9976          dc.b      48,95,48,48,48,48,32,61,32,48,10,32,48,120,65
000066E2  3030 203D 
000066E6  2030 0A20 
000066EA  3078 41   
000066ED  4142 425F 9977          dc.b      65,66,66,95,67,67,68,68,32,61,32,49,10,32,48
000066F1  4343 4444 
000066F5  203D 2031 
000066F9  0A20 30   
000066FC  7831 3132 9978          dc.b      120,49,49,50,50,95,51,51,52,52,32,61,32,50,10
00006700  325F 3333 
00006704  3434 203D 
00006708  2032 0A   
0000670B  2030 7837 9979          dc.b      32,48,120,55,54,53,52,95,51,50,49,48,32,61,32
0000670F  3635 345F 
00006713  3332 3130 
00006717  203D 20   
0000671A  330A 00   9980          dc.b      51,10,0
                    9981   @m68kde~1_180:
0000671E  0A50 726F 9982          dc.b      10,80,114,111,118,105,100,101,32,83,116,97,114
00006722  7669 6465 
00006726  2053 7461 
0000672A  72        
0000672B  7420 4164 9983          dc.b      116,32,65,100,100,114,101,115,115,32,105,110
0000672F  6472 6573 
00006733  7320 696E 
00006737  2068 6578 9984          dc.b      32,104,101,120,32,40,100,111,32,110,111,116
0000673B  2028 646F 
0000673F  206E 6F74 
00006743  2075 7365 9985          dc.b      32,117,115,101,32,48,120,32,112,114,101,102
00006747  2030 7820 
0000674B  7072 6566 
0000674F  6978 290A 9986          dc.b      105,120,41,10,48,120,0
00006753  3078 00   
                    9987   @m68kde~1_181:
00006756  0A50 726F 9988          dc.b      10,80,114,111,118,105,100,101,32,69,110,100
0000675A  7669 6465 
0000675E  2045 6E64 
00006762  2041 6464 9989          dc.b      32,65,100,100,114,101,115,115,32,105,110,32
00006766  7265 7373 
0000676A  2069 6E20 
0000676E  6865 7820 9990          dc.b      104,101,120,32,40,100,111,32,110,111,116,32
00006772  2864 6F20 
00006776  6E6F 7420 
0000677A  7573 6520 9991          dc.b      117,115,101,32,48,120,32,112,114,101,102,105
0000677E  3078 2070 
00006782  7265 6669 
00006786  7829 0A30 9992          dc.b      120,41,10,48,120,0
0000678A  7800      
                    9993   @m68kde~1_182:
0000678C  0A53 7461 9994          dc.b      10,83,116,97,114,116,32,65,100,100,114,101,115
00006790  7274 2041 
00006794  6464 7265 
00006798  73        
00006799  7320 3078 9995          dc.b      115,32,48,120,37,48,56,120,10,0
0000679D  2530 3878 
000067A1  0A00      
                    9996   @m68kde~1_183:
000067A4  0A45 6E64 9997          dc.b      10,69,110,100,32,65,100,100,114,101,115,115
000067A8  2041 6464 
000067AC  7265 7373 
000067B0  3A20 3078 9998          dc.b      58,32,48,120,37,48,56,120,10,0
000067B4  2530 3878 
000067B8  0A00      
                    9999   @m68kde~1_184:
000067BA  4552 524F 10000          dc.b      69,82,82,79,82,46,46,46,32,65,100,100,114,101
000067BE  522E 2E2E 
000067C2  2041 6464 
000067C6  7265      
000067C8  7373 2030 10001          dc.b      115,115,32,48,120,37,120,32,105,115,32,98,101
000067CC  7825 7820 
000067D0  6973 2062 
000067D4  65        
000067D5  796F 6E64 10002          dc.b      121,111,110,100,32,116,104,101,32,109,101,109
000067D9  2074 6865 
000067DD  206D 656D 
000067E1  6F72 7920 10003          dc.b      111,114,121,32,114,97,110,103,101,10,0
000067E5  7261 6E67 
000067E9  650A 00   
                    10004   @m68kde~1_185:
000067EC  4552 524F 10005          dc.b      69,82,82,79,82,46,46,46,32,86,97,108,117,101
000067F0  522E 2E2E 
000067F4  2056 616C 
000067F8  7565      
000067FA  2077 7269 10006          dc.b      32,119,114,105,116,116,101,110,32,116,111,32
000067FE  7474 656E 
00006802  2074 6F20 
00006806  6164 6472 10007          dc.b      97,100,100,114,101,115,115,32,48,120,37,120
0000680A  6573 7320 
0000680E  3078 2578 
00006812  203D 3D20 10008          dc.b      32,61,61,32,48,120,37,120,46,32,86,97,108,117
00006816  3078 2578 
0000681A  2E20 5661 
0000681E  6C75      
00006820  6520 4578 10009          dc.b      101,32,69,120,112,101,99,116,101,100,58,32,48
00006824  7065 6374 
00006828  6564 3A20 
0000682C  30        
0000682D  7825 780A 10010          dc.b      120,37,120,10,0
00006831  00        
                    10011   @m68kde~1_186:
00006832  4164 6472 10012          dc.b      65,100,100,114,101,115,115,58,32,48,120,37,120
00006836  6573 733A 
0000683A  2030 7825 
0000683E  78        
0000683F  2056 616C 10013          dc.b      32,86,97,108,117,101,58,32,48,120,37,48,50,88
00006843  7565 3A20 
00006847  3078 2530 
0000684B  3258      
0000684D  0A00      10014          dc.b      10,0
                    10015   @m68kde~1_187:
00006850  4164 6472 10016          dc.b      65,100,100,114,101,115,115,58,32,48,120,37,120
00006854  6573 733A 
00006858  2030 7825 
0000685C  78        
0000685D  2056 616C 10017          dc.b      32,86,97,108,117,101,58,32,48,120,37,48,52,88
00006861  7565 3A20 
00006865  3078 2530 
00006869  3458      
0000686B  0A00      10018          dc.b      10,0
                    10019   @m68kde~1_188:
0000686E  4164 6472 10020          dc.b      65,100,100,114,101,115,115,58,32,48,120,37,120
00006872  6573 733A 
00006876  2030 7825 
0000687A  78        
0000687B  2056 616C 10021          dc.b      32,86,97,108,117,101,58,32,48,120,37,48,56,88
0000687F  7565 3A20 
00006883  3078 2530 
00006887  3858      
00006889  0A00      10022          dc.b      10,0
                    10023   @m68kde~1_189:
0000688C  4445 312D 10024          dc.b      68,69,49,45,54,56,107,32,66,117,103,32,86,49
00006890  3638 6B20 
00006894  4275 6720 
00006898  5631      
0000689A  2E37 3700 10025          dc.b      46,55,55,0
                    10026   @m68kde~1_190:
0000689E  436F 7079 10027          dc.b      67,111,112,121,114,105,103,104,116,32,40,67
000068A2  7269 6768 
000068A6  7420 2843 
000068AA  2920 504A 10028          dc.b      41,32,80,74,32,68,97,118,105,101,115,32,50,48
000068AE  2044 6176 
000068B2  6965 7320 
000068B6  3230      
000068B8  3136 00   10029          dc.b      49,54,0
                    10030   @m68kde~1_191:
000068BC  0D0A 5275 10031          dc.b      13,10,82,117,110,110,105,110,103,46,46,46,46
000068C0  6E6E 696E 
000068C4  672E 2E2E 
000068C8  2E        
000068C9  2E00      10032          dc.b      46,0
                    10033   @m68kde~1_192:
000068CC  5275 6E6E 10034          dc.b      82,117,110,110,105,110,103,46,46,46,46,46,0
000068D0  696E 672E 
000068D4  2E2E 2E2E 
000068D8  00        
                    10035   @m68kde~1_193:
000068DA  4279 3A20 10036          dc.b      66,121,58,32,80,74,32,68,97,118,105,101,115
000068DE  504A 2044 
000068E2  6176 6965 
000068E6  73        
000068E7  00        10037          dc.b      0
                    10038   @m68kde~1_194:
000068E8  0D0A 2573 10039          dc.b      13,10,37,115,0
000068EC  00        
                    10040   @m68kde~1_195:
000068EE  0A20 5374 10041          dc.b      10,32,83,116,117,100,101,110,116,32,78,97,109
000068F2  7564 656E 
000068F6  7420 4E61 
000068FA  6D        
000068FB  6573 3A0A 10042          dc.b      101,115,58,10,32,90,97,99,104,97,114,105,97
000068FF  205A 6163 
00006903  6861 7269 
00006907  61        
00006908  6820 4A6F 10043          dc.b      104,32,74,111,115,101,112,104,58,32,52,53,53
0000690C  7365 7068 
00006910  3A20 3435 
00006914  35        
00006915  3030 3035 10044          dc.b      48,48,48,53,53,32,10,32,85,109,97,105,114,32
00006919  3520 0A20 
0000691D  556D 6169 
00006921  7220      
00006923  4D61 7A68 10045          dc.b      77,97,122,104,97,114,58,32,50,48,51,51,51,51
00006927  6172 3A20 
0000692B  3230 3333 
0000692F  3333      
00006931  3038 0A00 10046          dc.b      48,56,10,0
                    10047          section   data
00006936            10048                   align
          0000 6936 10049   DataStart       equ       *
                    10050   
                    10051   *********************************************************************************************************
                    10052   * Data Section for Initialised Data - these will be placed in rom as constants and have to be copied
                    10053   * to ram as part of the CStart routine in this file
                    10054   *********************************************************************************************************
                    10055   
                    10056   @vsscanf_bufx:
00006936  0B00 0546 10057          dc.l      @vsscanf_buf
                    10058   @vsscanf_1:
0000693A  0A00      10059          dc.b      10,0
                    10060   __ctype:
0000693C  0040 4040 10061          dc.b      0,64,64,64,64,64,64,64,64,64,80,80,80,80,80
00006940  4040 4040 
00006944  4040 5050 
00006948  5050 50   
0000694B  4040 4040 10062          dc.b      64,64,64,64,64,64,64,64,64,64,64,64,64,64,64
0000694F  4040 4040 
00006953  4040 4040 
00006957  4040 40   
0000695A  4040 40D0 10063          dc.b      64,64,64,208,160,160,160,160,160,160,160,160
0000695E  A0A0 A0A0 
00006962  A0A0 A0A0 
00006966  A0A0 A0A0 10064          dc.b      160,160,160,160,160,160,160,140,140,140,140
0000696A  A0A0 A08C 
0000696E  8C8C 8C   
00006971  8C8C 8C8C 10065          dc.b      140,140,140,140,140,140,160,160,160,160,160
00006975  8C8C A0A0 
00006979  A0A0 A0   
0000697C  A0A0 8A8A 10066          dc.b      160,160,138,138,138,138,138,138,130,130,130
00006980  8A8A 8A8A 
00006984  8282 82   
00006987  8282 8282 10067          dc.b      130,130,130,130,130,130,130,130,130,130,130
0000698B  8282 8282 
0000698F  8282 82   
00006992  8282 8282 10068          dc.b      130,130,130,130,130,130,160,160,160,160,160
00006996  8282 A0A0 
0000699A  A0A0 A0   
0000699D  A089 8989 10069          dc.b      160,137,137,137,137,137,137,129,129,129,129
000069A1  8989 8981 
000069A5  8181 81   
000069A8  8181 8181 10070          dc.b      129,129,129,129,129,129,129,129,129,129,129
000069AC  8181 8181 
000069B0  8181 81   
000069B3  8181 8181 10071          dc.b      129,129,129,129,129,160,160,160,160,64,0,0,0
000069B7  81A0 A0A0 
000069BB  A040 0000 
000069BF  00        
000069C0  0000 0000 10072          dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
000069C4  0000 0000 
000069C8  0000 0000 
000069CC  0000 0000 
000069D0  0000 0000 
000069D4  0000      
000069D6  0000 0000 10073          dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
000069DA  0000 0000 
000069DE  0000 0000 
000069E2  0000 0000 
000069E6  0000 0000 
000069EA  0000      
000069EC  0000 0000 10074          dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
000069F0  0000 0000 
000069F4  0000 0000 
000069F8  0000 0000 
000069FC  0000 0000 
00006A00  0000      
00006A02  0000 0000 10075          dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
00006A06  0000 0000 
00006A0A  0000 0000 
00006A0E  0000 0000 
00006A12  0000 0000 
00006A16  0000      
00006A18  0000 0000 10076          dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
00006A1C  0000 0000 
00006A20  0000 0000 
00006A24  0000 0000 
00006A28  0000 0000 
00006A2C  0000      
00006A2E  0000 0000 10077          dc.b      0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
00006A32  0000 0000 
00006A36  0000 0000 
00006A3A  0000 00   
                    10078   @itoa_1:
00006A3E  2D32 3134 10079          dc.b      45,50,49,52,55,52,56,51,54,52,56,0
00006A42  3734 3833 
00006A46  3634 3800 
                    10080          section   bss
00006A4A            10081                   align
          0000 6A4A 10082   DataEnd         equ     *                       this label will equate to the address of the last byte of global variable in it
                    10083   
                    10084   *********************************************************************************************************
                    10085   * Section for Uninitialised Data held in ROM as constants
                    10086   *********************************************************************************************************
                    10087   
0B000000            10088                   org     RamVectorTable          Ram based vector table must be stored here otherwise InstallException Handler will not work
          0000 0114 10089   DataLength      equ     DataEnd-DataStart       length of data needed to copy to Ram on bootup
                    10090   
                    10091   
0B000000            10092   bss             org       bss
                    10093   
                    10094   *********************************************************************************************************
                    10095   * Build a ram based vector table for interrupts so we can install our own Exception Handlers in C code at run time
                    10096   * install the exception handler using the C function InstallExceptionHandler()
                    10097   *********************************************************************************************************
                    10098   
                    10099   
                    10100   
0B000000            10101   VInitialSP       ds.l    1      dummy as we can't really install a handler for this
0B000004            10102   VInitialPC       ds.l    1      dummy as we can't reallin install a handler for this
0B000008            10103   VBusError        ds.l    1      storage for address of Bus Error Handler
0B00000C            10104   VAddressError    ds.l    1      storage for address of Address Error Handler
0B000010            10105   VIllegalInstr    ds.l    1      storage for address of Illegal Instruction handler
0B000014            10106   VDividebyZero    ds.l    1      storage for address of divide by zero handler
0B000018            10107   VCheck           ds.l    1      ditto
0B00001C            10108   VTrapV           ds.l    1      ditto
0B000020            10109   VPrivilege       ds.l    1      ditto
0B000024            10110   VTrace           ds.l    1
0B000028            10111   VLine1010emul    ds.l    1
0B00002C            10112   VLine1111emul    ds.l    1
0B000030            10113   VUnassigned1     ds.l    1
0B000034            10114   VUnassigned2     ds.l    1
0B000038            10115   VUnassigned3     ds.l    1
0B00003C            10116   VUninit_IRQ      ds.l    1
0B000040            10117   VUnassigned4     ds.l    1
0B000044            10118   VUnassigned5     ds.l    1
0B000048            10119   VUnassigned6     ds.l    1
0B00004C            10120   VUnassigned7     ds.l    1
0B000050            10121   VUnassigned8     ds.l    1
0B000054            10122   VUnassigned9     ds.l    1
0B000058            10123   VUnassigned10    ds.l    1
0B00005C            10124   VUnassigned11    ds.l    1
0B000060            10125   VSpuriousIRQ     ds.l    1
                    10126   
                    10127   * Interrupt handlers Vector 25-31
0B000064            10128   VL1IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000068            10129   VL2IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0B00006C            10130   VL3IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000070            10131   VL4IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000074            10132   VL5IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000078            10133   VL6IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
0B00007C            10134   VL7IRQ           ds.l    1       storage for 4 byte address of IRQ handler in your C program - install the handler using the C function InstallExceptionHandler()
                    10135   
                    10136   * Trap Handler vectors 32-47
0B000080            10137   VTrap0           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000084            10138   VTrap1           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000088            10139   VTrap2           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B00008C            10140   VTrap3           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000090            10141   VTrap4           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000094            10142   VTrap5           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B000098            10143   VTrap6           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B00009C            10144   VTrap7           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000A0            10145   VTrap8           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000A4            10146   VTrap9           ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000A8            10147   VTrap10          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000AC            10148   VTrap11          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000B0            10149   VTrap12          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000B4            10150   VTrap13          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000B8            10151   VTrap14          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
0B0000BC            10152   VTrap15          ds.l   1        storage for 4 byte address of TRAP handler in your C program - install the handler using the C function InstallExceptionHandler()
                    10153   
                    10154   * the remaining exceptions are unassigned in the 68000 so no need to allocate storage for them here
                    10155   
                    10156   ***********************************************************************************************************
                    10157   * Other Variables
                    10158   ***********************************************************************************************************
                    10159   *__DebugA5       ds.l    1
                    10160   *__UserA5        ds.l    1
                    10161   
                    10162   ***********************************************************************************************************
0B0000C0            10163   __ungetbuf:     ds.l    1       ; ungetbuffer for stdio functions
0B0000C4            10164   __allocp:       ds.l    0       ; start of allocation units
0B0000C4            10165   __heap:         ds.l    0       ; pointers for malloc functions
                    10166   
                    10167   *__himem:       ds.l    himem            ; highest memory location + 1
                    10168   *__stklen:      ds.l    stklen           ; default stack size
                    10169   
                    10170   *********************************************************************************************************
                    10171   * Section for Heap
                    10172   *********************************************************************************************************
                    10173   
                    10174   _i:
0B0000C4            10175          ds.b      4
                    10176   _x:
0B0000C8            10177          ds.b      4
                    10178   _y:
0B0000CC            10179          ds.b      4
                    10180   _z:
0B0000D0            10181          ds.b      4
                    10182   _PortA_Count:
0B0000D4            10183          ds.b      4
                    10184   _Trace:
0B0000D8            10185          ds.b      4
                    10186   _GoFlag:
0B0000DC            10187          ds.b      4
                    10188   _Echo:
0B0000E0            10189          ds.b      4
                    10190   _d0:
0B0000E4            10191          ds.b      4
                    10192   _d1:
0B0000E8            10193          ds.b      4
                    10194   _d2:
0B0000EC            10195          ds.b      4
                    10196   _d3:
0B0000F0            10197          ds.b      4
                    10198   _d4:
0B0000F4            10199          ds.b      4
                    10200   _d5:
0B0000F8            10201          ds.b      4
                    10202   _d6:
0B0000FC            10203          ds.b      4
                    10204   _d7:
0B000100            10205          ds.b      4
                    10206   _a0:
0B000104            10207          ds.b      4
                    10208   _a1:
0B000108            10209          ds.b      4
                    10210   _a2:
0B00010C            10211          ds.b      4
                    10212   _a3:
0B000110            10213          ds.b      4
                    10214   _a4:
0B000114            10215          ds.b      4
                    10216   _a5:
0B000118            10217          ds.b      4
                    10218   _a6:
0B00011C            10219          ds.b      4
                    10220   _PC:
0B000120            10221          ds.b      4
                    10222   _SSP:
0B000124            10223          ds.b      4
                    10224   _USP:
0B000128            10225          ds.b      4
                    10226   _SR:
0B00012C            10227          ds.b      2
                    10228   _BreakPointAddress:
0B00012E            10229          ds.b      32
                    10230   _BreakPointInstruction:
0B00014E            10231          ds.b      16
                    10232   _BreakPointSetOrCleared:
0B00015E            10233          ds.b      32
                    10234   _InstructionSize:
0B00017E            10235          ds.b      4
                    10236   _WatchPointAddress:
0B000182            10237          ds.b      32
                    10238   _WatchPointSetOrCleared:
0B0001A2            10239          ds.b      32
                    10240   _WatchPointString:
0B0001C2            10241          ds.b      800
                    10242   _TempString:
0B0004E2            10243          ds.b      100
                    10244   @vsscanf_buf:
0B000546            10245          ds.b      80
                    10246          section   heap
0B000596            10247                   align
          0B00 0596 10248   bssEnd          equ *                   end of storage space for unitialised variables
                    10249   *                                       we have to copy all initialised variable from rom to here at startup
          0B00 0596 10250   heap   equ       *
0B000596            10251                    align
          0000 0000

Assembly errors: 0
